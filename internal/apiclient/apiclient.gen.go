// Package apiclient provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package apiclient

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	ApiKeyAuthScopes = "ApiKeyAuth.Scopes"
)

// Defines values for AssistantObjectObject.
const (
	AssistantObjectObjectAssistant AssistantObjectObject = "assistant"
)

// Defines values for AssistantToolsCodeType.
const (
	AssistantToolsCodeTypeCodeInterpreter AssistantToolsCodeType = "code_interpreter"
)

// Defines values for AssistantToolsFileSearchType.
const (
	AssistantToolsFileSearchTypeFileSearch AssistantToolsFileSearchType = "file_search"
)

// Defines values for AssistantToolsFileSearchTypeOnlyType.
const (
	AssistantToolsFileSearchTypeOnlyTypeFileSearch AssistantToolsFileSearchTypeOnlyType = "file_search"
)

// Defines values for AssistantToolsFunctionType.
const (
	AssistantToolsFunctionTypeFunction AssistantToolsFunctionType = "function"
)

// Defines values for AssistantsApiResponseFormatOption0.
const (
	AssistantsApiResponseFormatOption0Auto AssistantsApiResponseFormatOption0 = "auto"
)

// Defines values for AssistantsApiToolChoiceOption0.
const (
	AssistantsApiToolChoiceOption0Auto     AssistantsApiToolChoiceOption0 = "auto"
	AssistantsApiToolChoiceOption0None     AssistantsApiToolChoiceOption0 = "none"
	AssistantsApiToolChoiceOption0Required AssistantsApiToolChoiceOption0 = "required"
)

// Defines values for AssistantsNamedToolChoiceType.
const (
	AssistantsNamedToolChoiceTypeCodeInterpreter AssistantsNamedToolChoiceType = "code_interpreter"
	AssistantsNamedToolChoiceTypeFileSearch      AssistantsNamedToolChoiceType = "file_search"
	AssistantsNamedToolChoiceTypeFunction        AssistantsNamedToolChoiceType = "function"
)

// Defines values for AudioResponseFormat.
const (
	AudioResponseFormatJson        AudioResponseFormat = "json"
	AudioResponseFormatSrt         AudioResponseFormat = "srt"
	AudioResponseFormatText        AudioResponseFormat = "text"
	AudioResponseFormatVerboseJson AudioResponseFormat = "verbose_json"
	AudioResponseFormatVtt         AudioResponseFormat = "vtt"
)

// Defines values for AuditLogActorType.
const (
	ApiKey  AuditLogActorType = "api_key"
	Session AuditLogActorType = "session"
)

// Defines values for AuditLogActorApiKeyType.
const (
	AuditLogActorApiKeyTypeServiceAccount AuditLogActorApiKeyType = "service_account"
	AuditLogActorApiKeyTypeUser           AuditLogActorApiKeyType = "user"
)

// Defines values for AuditLogEventType.
const (
	ApiKeyCreated         AuditLogEventType = "api_key.created"
	ApiKeyDeleted         AuditLogEventType = "api_key.deleted"
	ApiKeyUpdated         AuditLogEventType = "api_key.updated"
	InviteAccepted        AuditLogEventType = "invite.accepted"
	InviteDeleted         AuditLogEventType = "invite.deleted"
	InviteSent            AuditLogEventType = "invite.sent"
	LoginFailed           AuditLogEventType = "login.failed"
	LoginSucceeded        AuditLogEventType = "login.succeeded"
	LogoutFailed          AuditLogEventType = "logout.failed"
	LogoutSucceeded       AuditLogEventType = "logout.succeeded"
	OrganizationUpdated   AuditLogEventType = "organization.updated"
	ProjectArchived       AuditLogEventType = "project.archived"
	ProjectCreated        AuditLogEventType = "project.created"
	ProjectUpdated        AuditLogEventType = "project.updated"
	RateLimitDeleted      AuditLogEventType = "rate_limit.deleted"
	RateLimitUpdated      AuditLogEventType = "rate_limit.updated"
	ServiceAccountCreated AuditLogEventType = "service_account.created"
	ServiceAccountDeleted AuditLogEventType = "service_account.deleted"
	ServiceAccountUpdated AuditLogEventType = "service_account.updated"
	UserAdded             AuditLogEventType = "user.added"
	UserDeleted           AuditLogEventType = "user.deleted"
	UserUpdated           AuditLogEventType = "user.updated"
)

// Defines values for AutoChunkingStrategyRequestParamType.
const (
	AutoChunkingStrategyRequestParamTypeAuto AutoChunkingStrategyRequestParamType = "auto"
)

// Defines values for BatchObject.
const (
	BatchObjectBatch BatchObject = "batch"
)

// Defines values for BatchStatus.
const (
	BatchStatusCancelled  BatchStatus = "cancelled"
	BatchStatusCancelling BatchStatus = "cancelling"
	BatchStatusCompleted  BatchStatus = "completed"
	BatchStatusExpired    BatchStatus = "expired"
	BatchStatusFailed     BatchStatus = "failed"
	BatchStatusFinalizing BatchStatus = "finalizing"
	BatchStatusInProgress BatchStatus = "in_progress"
	BatchStatusValidating BatchStatus = "validating"
)

// Defines values for ChatCompletionMessageToolCallType.
const (
	ChatCompletionMessageToolCallTypeFunction ChatCompletionMessageToolCallType = "function"
)

// Defines values for ChatCompletionNamedToolChoiceType.
const (
	ChatCompletionNamedToolChoiceTypeFunction ChatCompletionNamedToolChoiceType = "function"
)

// Defines values for ChatCompletionRequestAssistantMessageRole.
const (
	ChatCompletionRequestAssistantMessageRoleAssistant ChatCompletionRequestAssistantMessageRole = "assistant"
)

// Defines values for ChatCompletionRequestFunctionMessageRole.
const (
	ChatCompletionRequestFunctionMessageRoleFunction ChatCompletionRequestFunctionMessageRole = "function"
)

// Defines values for ChatCompletionRequestMessageContentPartAudioInputAudioFormat.
const (
	ChatCompletionRequestMessageContentPartAudioInputAudioFormatMp3 ChatCompletionRequestMessageContentPartAudioInputAudioFormat = "mp3"
	ChatCompletionRequestMessageContentPartAudioInputAudioFormatWav ChatCompletionRequestMessageContentPartAudioInputAudioFormat = "wav"
)

// Defines values for ChatCompletionRequestMessageContentPartAudioType.
const (
	InputAudio ChatCompletionRequestMessageContentPartAudioType = "input_audio"
)

// Defines values for ChatCompletionRequestMessageContentPartImageImageUrlDetail.
const (
	ChatCompletionRequestMessageContentPartImageImageUrlDetailAuto ChatCompletionRequestMessageContentPartImageImageUrlDetail = "auto"
	ChatCompletionRequestMessageContentPartImageImageUrlDetailHigh ChatCompletionRequestMessageContentPartImageImageUrlDetail = "high"
	ChatCompletionRequestMessageContentPartImageImageUrlDetailLow  ChatCompletionRequestMessageContentPartImageImageUrlDetail = "low"
)

// Defines values for ChatCompletionRequestMessageContentPartImageType.
const (
	ChatCompletionRequestMessageContentPartImageTypeImageUrl ChatCompletionRequestMessageContentPartImageType = "image_url"
)

// Defines values for ChatCompletionRequestMessageContentPartRefusalType.
const (
	ChatCompletionRequestMessageContentPartRefusalTypeRefusal ChatCompletionRequestMessageContentPartRefusalType = "refusal"
)

// Defines values for ChatCompletionRequestMessageContentPartTextType.
const (
	ChatCompletionRequestMessageContentPartTextTypeText ChatCompletionRequestMessageContentPartTextType = "text"
)

// Defines values for ChatCompletionRequestSystemMessageRole.
const (
	System ChatCompletionRequestSystemMessageRole = "system"
)

// Defines values for ChatCompletionRequestToolMessageRole.
const (
	Tool ChatCompletionRequestToolMessageRole = "tool"
)

// Defines values for ChatCompletionRequestUserMessageRole.
const (
	ChatCompletionRequestUserMessageRoleUser ChatCompletionRequestUserMessageRole = "user"
)

// Defines values for ChatCompletionResponseMessageRole.
const (
	ChatCompletionResponseMessageRoleAssistant ChatCompletionResponseMessageRole = "assistant"
)

// Defines values for ChatCompletionToolType.
const (
	ChatCompletionToolTypeFunction ChatCompletionToolType = "function"
)

// Defines values for ChatCompletionToolChoiceOption0.
const (
	ChatCompletionToolChoiceOption0Auto     ChatCompletionToolChoiceOption0 = "auto"
	ChatCompletionToolChoiceOption0None     ChatCompletionToolChoiceOption0 = "none"
	ChatCompletionToolChoiceOption0Required ChatCompletionToolChoiceOption0 = "required"
)

// Defines values for CreateAssistantRequestModel1.
const (
	CreateAssistantRequestModel1Gpt35Turbo        CreateAssistantRequestModel1 = "gpt-3.5-turbo"
	CreateAssistantRequestModel1Gpt35Turbo0125    CreateAssistantRequestModel1 = "gpt-3.5-turbo-0125"
	CreateAssistantRequestModel1Gpt35Turbo0613    CreateAssistantRequestModel1 = "gpt-3.5-turbo-0613"
	CreateAssistantRequestModel1Gpt35Turbo1106    CreateAssistantRequestModel1 = "gpt-3.5-turbo-1106"
	CreateAssistantRequestModel1Gpt35Turbo16k     CreateAssistantRequestModel1 = "gpt-3.5-turbo-16k"
	CreateAssistantRequestModel1Gpt35Turbo16k0613 CreateAssistantRequestModel1 = "gpt-3.5-turbo-16k-0613"
	CreateAssistantRequestModel1Gpt4              CreateAssistantRequestModel1 = "gpt-4"
	CreateAssistantRequestModel1Gpt40125Preview   CreateAssistantRequestModel1 = "gpt-4-0125-preview"
	CreateAssistantRequestModel1Gpt40314          CreateAssistantRequestModel1 = "gpt-4-0314"
	CreateAssistantRequestModel1Gpt40613          CreateAssistantRequestModel1 = "gpt-4-0613"
	CreateAssistantRequestModel1Gpt41106Preview   CreateAssistantRequestModel1 = "gpt-4-1106-preview"
	CreateAssistantRequestModel1Gpt432k           CreateAssistantRequestModel1 = "gpt-4-32k"
	CreateAssistantRequestModel1Gpt432k0314       CreateAssistantRequestModel1 = "gpt-4-32k-0314"
	CreateAssistantRequestModel1Gpt432k0613       CreateAssistantRequestModel1 = "gpt-4-32k-0613"
	CreateAssistantRequestModel1Gpt4Turbo         CreateAssistantRequestModel1 = "gpt-4-turbo"
	CreateAssistantRequestModel1Gpt4Turbo20240409 CreateAssistantRequestModel1 = "gpt-4-turbo-2024-04-09"
	CreateAssistantRequestModel1Gpt4TurboPreview  CreateAssistantRequestModel1 = "gpt-4-turbo-preview"
	CreateAssistantRequestModel1Gpt4VisionPreview CreateAssistantRequestModel1 = "gpt-4-vision-preview"
	CreateAssistantRequestModel1Gpt4o             CreateAssistantRequestModel1 = "gpt-4o"
	CreateAssistantRequestModel1Gpt4o20240513     CreateAssistantRequestModel1 = "gpt-4o-2024-05-13"
	CreateAssistantRequestModel1Gpt4o20240806     CreateAssistantRequestModel1 = "gpt-4o-2024-08-06"
	CreateAssistantRequestModel1Gpt4oMini         CreateAssistantRequestModel1 = "gpt-4o-mini"
	CreateAssistantRequestModel1Gpt4oMini20240718 CreateAssistantRequestModel1 = "gpt-4o-mini-2024-07-18"
)

// Defines values for CreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy0Type.
const (
	CreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy0TypeAuto CreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy0Type = "auto"
)

// Defines values for CreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy1Type.
const (
	CreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy1TypeStatic CreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy1Type = "static"
)

// Defines values for CreateChatCompletionRequestAudioFormat.
const (
	CreateChatCompletionRequestAudioFormatFlac  CreateChatCompletionRequestAudioFormat = "flac"
	CreateChatCompletionRequestAudioFormatMp3   CreateChatCompletionRequestAudioFormat = "mp3"
	CreateChatCompletionRequestAudioFormatOpus  CreateChatCompletionRequestAudioFormat = "opus"
	CreateChatCompletionRequestAudioFormatPcm16 CreateChatCompletionRequestAudioFormat = "pcm16"
	CreateChatCompletionRequestAudioFormatWav   CreateChatCompletionRequestAudioFormat = "wav"
)

// Defines values for CreateChatCompletionRequestAudioVoice.
const (
	CreateChatCompletionRequestAudioVoiceAlloy   CreateChatCompletionRequestAudioVoice = "alloy"
	CreateChatCompletionRequestAudioVoiceAsh     CreateChatCompletionRequestAudioVoice = "ash"
	CreateChatCompletionRequestAudioVoiceBallad  CreateChatCompletionRequestAudioVoice = "ballad"
	CreateChatCompletionRequestAudioVoiceCoral   CreateChatCompletionRequestAudioVoice = "coral"
	CreateChatCompletionRequestAudioVoiceEcho    CreateChatCompletionRequestAudioVoice = "echo"
	CreateChatCompletionRequestAudioVoiceSage    CreateChatCompletionRequestAudioVoice = "sage"
	CreateChatCompletionRequestAudioVoiceShimmer CreateChatCompletionRequestAudioVoice = "shimmer"
	CreateChatCompletionRequestAudioVoiceVerse   CreateChatCompletionRequestAudioVoice = "verse"
)

// Defines values for CreateChatCompletionRequestFunctionCall0.
const (
	CreateChatCompletionRequestFunctionCall0Auto CreateChatCompletionRequestFunctionCall0 = "auto"
	CreateChatCompletionRequestFunctionCall0None CreateChatCompletionRequestFunctionCall0 = "none"
)

// Defines values for CreateChatCompletionRequestModel1.
const (
	CreateChatCompletionRequestModel1Chatgpt4oLatest              CreateChatCompletionRequestModel1 = "chatgpt-4o-latest"
	CreateChatCompletionRequestModel1Gpt35Turbo                   CreateChatCompletionRequestModel1 = "gpt-3.5-turbo"
	CreateChatCompletionRequestModel1Gpt35Turbo0125               CreateChatCompletionRequestModel1 = "gpt-3.5-turbo-0125"
	CreateChatCompletionRequestModel1Gpt35Turbo0301               CreateChatCompletionRequestModel1 = "gpt-3.5-turbo-0301"
	CreateChatCompletionRequestModel1Gpt35Turbo0613               CreateChatCompletionRequestModel1 = "gpt-3.5-turbo-0613"
	CreateChatCompletionRequestModel1Gpt35Turbo1106               CreateChatCompletionRequestModel1 = "gpt-3.5-turbo-1106"
	CreateChatCompletionRequestModel1Gpt35Turbo16k                CreateChatCompletionRequestModel1 = "gpt-3.5-turbo-16k"
	CreateChatCompletionRequestModel1Gpt35Turbo16k0613            CreateChatCompletionRequestModel1 = "gpt-3.5-turbo-16k-0613"
	CreateChatCompletionRequestModel1Gpt4                         CreateChatCompletionRequestModel1 = "gpt-4"
	CreateChatCompletionRequestModel1Gpt40125Preview              CreateChatCompletionRequestModel1 = "gpt-4-0125-preview"
	CreateChatCompletionRequestModel1Gpt40314                     CreateChatCompletionRequestModel1 = "gpt-4-0314"
	CreateChatCompletionRequestModel1Gpt40613                     CreateChatCompletionRequestModel1 = "gpt-4-0613"
	CreateChatCompletionRequestModel1Gpt41106Preview              CreateChatCompletionRequestModel1 = "gpt-4-1106-preview"
	CreateChatCompletionRequestModel1Gpt432k                      CreateChatCompletionRequestModel1 = "gpt-4-32k"
	CreateChatCompletionRequestModel1Gpt432k0314                  CreateChatCompletionRequestModel1 = "gpt-4-32k-0314"
	CreateChatCompletionRequestModel1Gpt432k0613                  CreateChatCompletionRequestModel1 = "gpt-4-32k-0613"
	CreateChatCompletionRequestModel1Gpt4Turbo                    CreateChatCompletionRequestModel1 = "gpt-4-turbo"
	CreateChatCompletionRequestModel1Gpt4Turbo20240409            CreateChatCompletionRequestModel1 = "gpt-4-turbo-2024-04-09"
	CreateChatCompletionRequestModel1Gpt4TurboPreview             CreateChatCompletionRequestModel1 = "gpt-4-turbo-preview"
	CreateChatCompletionRequestModel1Gpt4VisionPreview            CreateChatCompletionRequestModel1 = "gpt-4-vision-preview"
	CreateChatCompletionRequestModel1Gpt4o                        CreateChatCompletionRequestModel1 = "gpt-4o"
	CreateChatCompletionRequestModel1Gpt4o20240513                CreateChatCompletionRequestModel1 = "gpt-4o-2024-05-13"
	CreateChatCompletionRequestModel1Gpt4o20240806                CreateChatCompletionRequestModel1 = "gpt-4o-2024-08-06"
	CreateChatCompletionRequestModel1Gpt4oAudioPreview            CreateChatCompletionRequestModel1 = "gpt-4o-audio-preview"
	CreateChatCompletionRequestModel1Gpt4oAudioPreview20241001    CreateChatCompletionRequestModel1 = "gpt-4o-audio-preview-2024-10-01"
	CreateChatCompletionRequestModel1Gpt4oMini                    CreateChatCompletionRequestModel1 = "gpt-4o-mini"
	CreateChatCompletionRequestModel1Gpt4oMini20240718            CreateChatCompletionRequestModel1 = "gpt-4o-mini-2024-07-18"
	CreateChatCompletionRequestModel1Gpt4oRealtimePreview         CreateChatCompletionRequestModel1 = "gpt-4o-realtime-preview"
	CreateChatCompletionRequestModel1Gpt4oRealtimePreview20241001 CreateChatCompletionRequestModel1 = "gpt-4o-realtime-preview-2024-10-01"
	CreateChatCompletionRequestModel1O1Mini                       CreateChatCompletionRequestModel1 = "o1-mini"
	CreateChatCompletionRequestModel1O1Mini20240912               CreateChatCompletionRequestModel1 = "o1-mini-2024-09-12"
	CreateChatCompletionRequestModel1O1Preview                    CreateChatCompletionRequestModel1 = "o1-preview"
	CreateChatCompletionRequestModel1O1Preview20240912            CreateChatCompletionRequestModel1 = "o1-preview-2024-09-12"
)

// Defines values for CreateChatCompletionRequestServiceTier.
const (
	CreateChatCompletionRequestServiceTierAuto    CreateChatCompletionRequestServiceTier = "auto"
	CreateChatCompletionRequestServiceTierDefault CreateChatCompletionRequestServiceTier = "default"
)

// Defines values for CreateChatCompletionResponseChoicesFinishReason.
const (
	CreateChatCompletionResponseChoicesFinishReasonContentFilter CreateChatCompletionResponseChoicesFinishReason = "content_filter"
	CreateChatCompletionResponseChoicesFinishReasonFunctionCall  CreateChatCompletionResponseChoicesFinishReason = "function_call"
	CreateChatCompletionResponseChoicesFinishReasonLength        CreateChatCompletionResponseChoicesFinishReason = "length"
	CreateChatCompletionResponseChoicesFinishReasonStop          CreateChatCompletionResponseChoicesFinishReason = "stop"
	CreateChatCompletionResponseChoicesFinishReasonToolCalls     CreateChatCompletionResponseChoicesFinishReason = "tool_calls"
)

// Defines values for CreateChatCompletionResponseObject.
const (
	ChatCompletion CreateChatCompletionResponseObject = "chat.completion"
)

// Defines values for CreateChatCompletionResponseServiceTier.
const (
	Default CreateChatCompletionResponseServiceTier = "default"
	Scale   CreateChatCompletionResponseServiceTier = "scale"
)

// Defines values for CreateCompletionRequestModel1.
const (
	CreateCompletionRequestModel1Babbage002         CreateCompletionRequestModel1 = "babbage-002"
	CreateCompletionRequestModel1Davinci002         CreateCompletionRequestModel1 = "davinci-002"
	CreateCompletionRequestModel1Gpt35TurboInstruct CreateCompletionRequestModel1 = "gpt-3.5-turbo-instruct"
)

// Defines values for CreateCompletionResponseChoicesFinishReason.
const (
	CreateCompletionResponseChoicesFinishReasonContentFilter CreateCompletionResponseChoicesFinishReason = "content_filter"
	CreateCompletionResponseChoicesFinishReasonLength        CreateCompletionResponseChoicesFinishReason = "length"
	CreateCompletionResponseChoicesFinishReasonStop          CreateCompletionResponseChoicesFinishReason = "stop"
)

// Defines values for CreateCompletionResponseObject.
const (
	TextCompletion CreateCompletionResponseObject = "text_completion"
)

// Defines values for CreateEmbeddingRequestEncodingFormat.
const (
	Base64 CreateEmbeddingRequestEncodingFormat = "base64"
	Float  CreateEmbeddingRequestEncodingFormat = "float"
)

// Defines values for CreateEmbeddingRequestModel1.
const (
	TextEmbedding3Large CreateEmbeddingRequestModel1 = "text-embedding-3-large"
	TextEmbedding3Small CreateEmbeddingRequestModel1 = "text-embedding-3-small"
	TextEmbeddingAda002 CreateEmbeddingRequestModel1 = "text-embedding-ada-002"
)

// Defines values for CreateEmbeddingResponseObject.
const (
	CreateEmbeddingResponseObjectList CreateEmbeddingResponseObject = "list"
)

// Defines values for CreateFileRequestPurpose.
const (
	CreateFileRequestPurposeAssistants CreateFileRequestPurpose = "assistants"
	CreateFileRequestPurposeBatch      CreateFileRequestPurpose = "batch"
	CreateFileRequestPurposeFineTune   CreateFileRequestPurpose = "fine-tune"
	CreateFileRequestPurposeVision     CreateFileRequestPurpose = "vision"
)

// Defines values for CreateFineTuningJobRequestHyperparametersBatchSize0.
const (
	CreateFineTuningJobRequestHyperparametersBatchSize0Auto CreateFineTuningJobRequestHyperparametersBatchSize0 = "auto"
)

// Defines values for CreateFineTuningJobRequestHyperparametersLearningRateMultiplier0.
const (
	CreateFineTuningJobRequestHyperparametersLearningRateMultiplier0Auto CreateFineTuningJobRequestHyperparametersLearningRateMultiplier0 = "auto"
)

// Defines values for CreateFineTuningJobRequestHyperparametersNEpochs0.
const (
	CreateFineTuningJobRequestHyperparametersNEpochs0Auto CreateFineTuningJobRequestHyperparametersNEpochs0 = "auto"
)

// Defines values for CreateFineTuningJobRequestIntegrationsType0.
const (
	CreateFineTuningJobRequestIntegrationsType0Wandb CreateFineTuningJobRequestIntegrationsType0 = "wandb"
)

// Defines values for CreateFineTuningJobRequestModel1.
const (
	CreateFineTuningJobRequestModel1Babbage002 CreateFineTuningJobRequestModel1 = "babbage-002"
	CreateFineTuningJobRequestModel1Davinci002 CreateFineTuningJobRequestModel1 = "davinci-002"
	CreateFineTuningJobRequestModel1Gpt35Turbo CreateFineTuningJobRequestModel1 = "gpt-3.5-turbo"
	CreateFineTuningJobRequestModel1Gpt4oMini  CreateFineTuningJobRequestModel1 = "gpt-4o-mini"
)

// Defines values for CreateImageEditRequestModel1.
const (
	CreateImageEditRequestModel1DallE2 CreateImageEditRequestModel1 = "dall-e-2"
)

// Defines values for CreateImageEditRequestResponseFormat.
const (
	CreateImageEditRequestResponseFormatB64Json CreateImageEditRequestResponseFormat = "b64_json"
	CreateImageEditRequestResponseFormatUrl     CreateImageEditRequestResponseFormat = "url"
)

// Defines values for CreateImageEditRequestSize.
const (
	CreateImageEditRequestSizeN1024x1024 CreateImageEditRequestSize = "1024x1024"
	CreateImageEditRequestSizeN256x256   CreateImageEditRequestSize = "256x256"
	CreateImageEditRequestSizeN512x512   CreateImageEditRequestSize = "512x512"
)

// Defines values for CreateImageRequestModel1.
const (
	CreateImageRequestModel1DallE2 CreateImageRequestModel1 = "dall-e-2"
	CreateImageRequestModel1DallE3 CreateImageRequestModel1 = "dall-e-3"
)

// Defines values for CreateImageRequestQuality.
const (
	Hd       CreateImageRequestQuality = "hd"
	Standard CreateImageRequestQuality = "standard"
)

// Defines values for CreateImageRequestResponseFormat.
const (
	CreateImageRequestResponseFormatB64Json CreateImageRequestResponseFormat = "b64_json"
	CreateImageRequestResponseFormatUrl     CreateImageRequestResponseFormat = "url"
)

// Defines values for CreateImageRequestSize.
const (
	CreateImageRequestSizeN1024x1024 CreateImageRequestSize = "1024x1024"
	CreateImageRequestSizeN1024x1792 CreateImageRequestSize = "1024x1792"
	CreateImageRequestSizeN1792x1024 CreateImageRequestSize = "1792x1024"
	CreateImageRequestSizeN256x256   CreateImageRequestSize = "256x256"
	CreateImageRequestSizeN512x512   CreateImageRequestSize = "512x512"
)

// Defines values for CreateImageRequestStyle.
const (
	Natural CreateImageRequestStyle = "natural"
	Vivid   CreateImageRequestStyle = "vivid"
)

// Defines values for CreateImageVariationRequestModel1.
const (
	DallE2 CreateImageVariationRequestModel1 = "dall-e-2"
)

// Defines values for CreateImageVariationRequestResponseFormat.
const (
	B64Json CreateImageVariationRequestResponseFormat = "b64_json"
	Url     CreateImageVariationRequestResponseFormat = "url"
)

// Defines values for CreateImageVariationRequestSize.
const (
	N1024x1024 CreateImageVariationRequestSize = "1024x1024"
	N256x256   CreateImageVariationRequestSize = "256x256"
	N512x512   CreateImageVariationRequestSize = "512x512"
)

// Defines values for CreateMessageRequestRole.
const (
	CreateMessageRequestRoleAssistant CreateMessageRequestRole = "assistant"
	CreateMessageRequestRoleUser      CreateMessageRequestRole = "user"
)

// Defines values for CreateModerationRequestInput20Type.
const (
	CreateModerationRequestInput20TypeImageUrl CreateModerationRequestInput20Type = "image_url"
)

// Defines values for CreateModerationRequestInput21Type.
const (
	CreateModerationRequestInput21TypeText CreateModerationRequestInput21Type = "text"
)

// Defines values for CreateModerationRequestModel1.
const (
	OmniModeration20240926 CreateModerationRequestModel1 = "omni-moderation-2024-09-26"
	OmniModerationLatest   CreateModerationRequestModel1 = "omni-moderation-latest"
	TextModerationLatest   CreateModerationRequestModel1 = "text-moderation-latest"
	TextModerationStable   CreateModerationRequestModel1 = "text-moderation-stable"
)

// Defines values for CreateModerationResponseResultsCategoryAppliedInputTypesHarassment.
const (
	CreateModerationResponseResultsCategoryAppliedInputTypesHarassmentText CreateModerationResponseResultsCategoryAppliedInputTypesHarassment = "text"
)

// Defines values for CreateModerationResponseResultsCategoryAppliedInputTypesHarassmentthreatening.
const (
	CreateModerationResponseResultsCategoryAppliedInputTypesHarassmentthreateningText CreateModerationResponseResultsCategoryAppliedInputTypesHarassmentthreatening = "text"
)

// Defines values for CreateModerationResponseResultsCategoryAppliedInputTypesHate.
const (
	CreateModerationResponseResultsCategoryAppliedInputTypesHateText CreateModerationResponseResultsCategoryAppliedInputTypesHate = "text"
)

// Defines values for CreateModerationResponseResultsCategoryAppliedInputTypesHatethreatening.
const (
	CreateModerationResponseResultsCategoryAppliedInputTypesHatethreateningText CreateModerationResponseResultsCategoryAppliedInputTypesHatethreatening = "text"
)

// Defines values for CreateModerationResponseResultsCategoryAppliedInputTypesIllicit.
const (
	CreateModerationResponseResultsCategoryAppliedInputTypesIllicitText CreateModerationResponseResultsCategoryAppliedInputTypesIllicit = "text"
)

// Defines values for CreateModerationResponseResultsCategoryAppliedInputTypesIllicitviolent.
const (
	CreateModerationResponseResultsCategoryAppliedInputTypesIllicitviolentText CreateModerationResponseResultsCategoryAppliedInputTypesIllicitviolent = "text"
)

// Defines values for CreateModerationResponseResultsCategoryAppliedInputTypesSelfHarm.
const (
	CreateModerationResponseResultsCategoryAppliedInputTypesSelfHarmImage CreateModerationResponseResultsCategoryAppliedInputTypesSelfHarm = "image"
	CreateModerationResponseResultsCategoryAppliedInputTypesSelfHarmText  CreateModerationResponseResultsCategoryAppliedInputTypesSelfHarm = "text"
)

// Defines values for CreateModerationResponseResultsCategoryAppliedInputTypesSelfHarminstructions.
const (
	CreateModerationResponseResultsCategoryAppliedInputTypesSelfHarminstructionsImage CreateModerationResponseResultsCategoryAppliedInputTypesSelfHarminstructions = "image"
	CreateModerationResponseResultsCategoryAppliedInputTypesSelfHarminstructionsText  CreateModerationResponseResultsCategoryAppliedInputTypesSelfHarminstructions = "text"
)

// Defines values for CreateModerationResponseResultsCategoryAppliedInputTypesSelfHarmintent.
const (
	CreateModerationResponseResultsCategoryAppliedInputTypesSelfHarmintentImage CreateModerationResponseResultsCategoryAppliedInputTypesSelfHarmintent = "image"
	CreateModerationResponseResultsCategoryAppliedInputTypesSelfHarmintentText  CreateModerationResponseResultsCategoryAppliedInputTypesSelfHarmintent = "text"
)

// Defines values for CreateModerationResponseResultsCategoryAppliedInputTypesSexual.
const (
	CreateModerationResponseResultsCategoryAppliedInputTypesSexualImage CreateModerationResponseResultsCategoryAppliedInputTypesSexual = "image"
	CreateModerationResponseResultsCategoryAppliedInputTypesSexualText  CreateModerationResponseResultsCategoryAppliedInputTypesSexual = "text"
)

// Defines values for CreateModerationResponseResultsCategoryAppliedInputTypesSexualminors.
const (
	CreateModerationResponseResultsCategoryAppliedInputTypesSexualminorsText CreateModerationResponseResultsCategoryAppliedInputTypesSexualminors = "text"
)

// Defines values for CreateModerationResponseResultsCategoryAppliedInputTypesViolence.
const (
	CreateModerationResponseResultsCategoryAppliedInputTypesViolenceImage CreateModerationResponseResultsCategoryAppliedInputTypesViolence = "image"
	CreateModerationResponseResultsCategoryAppliedInputTypesViolenceText  CreateModerationResponseResultsCategoryAppliedInputTypesViolence = "text"
)

// Defines values for CreateModerationResponseResultsCategoryAppliedInputTypesViolencegraphic.
const (
	CreateModerationResponseResultsCategoryAppliedInputTypesViolencegraphicImage CreateModerationResponseResultsCategoryAppliedInputTypesViolencegraphic = "image"
	CreateModerationResponseResultsCategoryAppliedInputTypesViolencegraphicText  CreateModerationResponseResultsCategoryAppliedInputTypesViolencegraphic = "text"
)

// Defines values for CreateRunRequestModel1.
const (
	CreateRunRequestModel1Gpt35Turbo        CreateRunRequestModel1 = "gpt-3.5-turbo"
	CreateRunRequestModel1Gpt35Turbo0125    CreateRunRequestModel1 = "gpt-3.5-turbo-0125"
	CreateRunRequestModel1Gpt35Turbo0613    CreateRunRequestModel1 = "gpt-3.5-turbo-0613"
	CreateRunRequestModel1Gpt35Turbo1106    CreateRunRequestModel1 = "gpt-3.5-turbo-1106"
	CreateRunRequestModel1Gpt35Turbo16k     CreateRunRequestModel1 = "gpt-3.5-turbo-16k"
	CreateRunRequestModel1Gpt35Turbo16k0613 CreateRunRequestModel1 = "gpt-3.5-turbo-16k-0613"
	CreateRunRequestModel1Gpt4              CreateRunRequestModel1 = "gpt-4"
	CreateRunRequestModel1Gpt40125Preview   CreateRunRequestModel1 = "gpt-4-0125-preview"
	CreateRunRequestModel1Gpt40314          CreateRunRequestModel1 = "gpt-4-0314"
	CreateRunRequestModel1Gpt40613          CreateRunRequestModel1 = "gpt-4-0613"
	CreateRunRequestModel1Gpt41106Preview   CreateRunRequestModel1 = "gpt-4-1106-preview"
	CreateRunRequestModel1Gpt432k           CreateRunRequestModel1 = "gpt-4-32k"
	CreateRunRequestModel1Gpt432k0314       CreateRunRequestModel1 = "gpt-4-32k-0314"
	CreateRunRequestModel1Gpt432k0613       CreateRunRequestModel1 = "gpt-4-32k-0613"
	CreateRunRequestModel1Gpt4Turbo         CreateRunRequestModel1 = "gpt-4-turbo"
	CreateRunRequestModel1Gpt4Turbo20240409 CreateRunRequestModel1 = "gpt-4-turbo-2024-04-09"
	CreateRunRequestModel1Gpt4TurboPreview  CreateRunRequestModel1 = "gpt-4-turbo-preview"
	CreateRunRequestModel1Gpt4VisionPreview CreateRunRequestModel1 = "gpt-4-vision-preview"
	CreateRunRequestModel1Gpt4o             CreateRunRequestModel1 = "gpt-4o"
	CreateRunRequestModel1Gpt4o20240513     CreateRunRequestModel1 = "gpt-4o-2024-05-13"
	CreateRunRequestModel1Gpt4o20240806     CreateRunRequestModel1 = "gpt-4o-2024-08-06"
	CreateRunRequestModel1Gpt4oMini         CreateRunRequestModel1 = "gpt-4o-mini"
	CreateRunRequestModel1Gpt4oMini20240718 CreateRunRequestModel1 = "gpt-4o-mini-2024-07-18"
)

// Defines values for CreateSpeechRequestModel1.
const (
	Tts1   CreateSpeechRequestModel1 = "tts-1"
	Tts1Hd CreateSpeechRequestModel1 = "tts-1-hd"
)

// Defines values for CreateSpeechRequestResponseFormat.
const (
	Aac  CreateSpeechRequestResponseFormat = "aac"
	Flac CreateSpeechRequestResponseFormat = "flac"
	Mp3  CreateSpeechRequestResponseFormat = "mp3"
	Opus CreateSpeechRequestResponseFormat = "opus"
	Pcm  CreateSpeechRequestResponseFormat = "pcm"
	Wav  CreateSpeechRequestResponseFormat = "wav"
)

// Defines values for CreateSpeechRequestVoice.
const (
	CreateSpeechRequestVoiceAlloy   CreateSpeechRequestVoice = "alloy"
	CreateSpeechRequestVoiceEcho    CreateSpeechRequestVoice = "echo"
	CreateSpeechRequestVoiceFable   CreateSpeechRequestVoice = "fable"
	CreateSpeechRequestVoiceNova    CreateSpeechRequestVoice = "nova"
	CreateSpeechRequestVoiceOnyx    CreateSpeechRequestVoice = "onyx"
	CreateSpeechRequestVoiceShimmer CreateSpeechRequestVoice = "shimmer"
)

// Defines values for CreateThreadAndRunRequestModel1.
const (
	CreateThreadAndRunRequestModel1Gpt35Turbo        CreateThreadAndRunRequestModel1 = "gpt-3.5-turbo"
	CreateThreadAndRunRequestModel1Gpt35Turbo0125    CreateThreadAndRunRequestModel1 = "gpt-3.5-turbo-0125"
	CreateThreadAndRunRequestModel1Gpt35Turbo0613    CreateThreadAndRunRequestModel1 = "gpt-3.5-turbo-0613"
	CreateThreadAndRunRequestModel1Gpt35Turbo1106    CreateThreadAndRunRequestModel1 = "gpt-3.5-turbo-1106"
	CreateThreadAndRunRequestModel1Gpt35Turbo16k     CreateThreadAndRunRequestModel1 = "gpt-3.5-turbo-16k"
	CreateThreadAndRunRequestModel1Gpt35Turbo16k0613 CreateThreadAndRunRequestModel1 = "gpt-3.5-turbo-16k-0613"
	CreateThreadAndRunRequestModel1Gpt4              CreateThreadAndRunRequestModel1 = "gpt-4"
	CreateThreadAndRunRequestModel1Gpt40125Preview   CreateThreadAndRunRequestModel1 = "gpt-4-0125-preview"
	CreateThreadAndRunRequestModel1Gpt40314          CreateThreadAndRunRequestModel1 = "gpt-4-0314"
	CreateThreadAndRunRequestModel1Gpt40613          CreateThreadAndRunRequestModel1 = "gpt-4-0613"
	CreateThreadAndRunRequestModel1Gpt41106Preview   CreateThreadAndRunRequestModel1 = "gpt-4-1106-preview"
	CreateThreadAndRunRequestModel1Gpt432k           CreateThreadAndRunRequestModel1 = "gpt-4-32k"
	CreateThreadAndRunRequestModel1Gpt432k0314       CreateThreadAndRunRequestModel1 = "gpt-4-32k-0314"
	CreateThreadAndRunRequestModel1Gpt432k0613       CreateThreadAndRunRequestModel1 = "gpt-4-32k-0613"
	CreateThreadAndRunRequestModel1Gpt4Turbo         CreateThreadAndRunRequestModel1 = "gpt-4-turbo"
	CreateThreadAndRunRequestModel1Gpt4Turbo20240409 CreateThreadAndRunRequestModel1 = "gpt-4-turbo-2024-04-09"
	CreateThreadAndRunRequestModel1Gpt4TurboPreview  CreateThreadAndRunRequestModel1 = "gpt-4-turbo-preview"
	CreateThreadAndRunRequestModel1Gpt4VisionPreview CreateThreadAndRunRequestModel1 = "gpt-4-vision-preview"
	CreateThreadAndRunRequestModel1Gpt4o             CreateThreadAndRunRequestModel1 = "gpt-4o"
	CreateThreadAndRunRequestModel1Gpt4o20240513     CreateThreadAndRunRequestModel1 = "gpt-4o-2024-05-13"
	CreateThreadAndRunRequestModel1Gpt4o20240806     CreateThreadAndRunRequestModel1 = "gpt-4o-2024-08-06"
	CreateThreadAndRunRequestModel1Gpt4oMini         CreateThreadAndRunRequestModel1 = "gpt-4o-mini"
	CreateThreadAndRunRequestModel1Gpt4oMini20240718 CreateThreadAndRunRequestModel1 = "gpt-4o-mini-2024-07-18"
)

// Defines values for CreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy0Type.
const (
	CreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy0TypeAuto CreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy0Type = "auto"
)

// Defines values for CreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy1Type.
const (
	CreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy1TypeStatic CreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy1Type = "static"
)

// Defines values for CreateTranscriptionRequestModel1.
const (
	CreateTranscriptionRequestModel1Whisper1 CreateTranscriptionRequestModel1 = "whisper-1"
)

// Defines values for CreateTranscriptionRequestTimestampGranularities.
const (
	Segment CreateTranscriptionRequestTimestampGranularities = "segment"
	Word    CreateTranscriptionRequestTimestampGranularities = "word"
)

// Defines values for CreateTranslationRequestModel1.
const (
	CreateTranslationRequestModel1Whisper1 CreateTranslationRequestModel1 = "whisper-1"
)

// Defines values for CreateUploadRequestPurpose.
const (
	CreateUploadRequestPurposeAssistants CreateUploadRequestPurpose = "assistants"
	CreateUploadRequestPurposeBatch      CreateUploadRequestPurpose = "batch"
	CreateUploadRequestPurposeFineTune   CreateUploadRequestPurpose = "fine-tune"
	CreateUploadRequestPurposeVision     CreateUploadRequestPurpose = "vision"
)

// Defines values for DeleteAssistantResponseObject.
const (
	AssistantDeleted DeleteAssistantResponseObject = "assistant.deleted"
)

// Defines values for DeleteFileResponseObject.
const (
	DeleteFileResponseObjectFile DeleteFileResponseObject = "file"
)

// Defines values for DeleteMessageResponseObject.
const (
	ThreadMessageDeleted DeleteMessageResponseObject = "thread.message.deleted"
)

// Defines values for DeleteThreadResponseObject.
const (
	ThreadDeleted DeleteThreadResponseObject = "thread.deleted"
)

// Defines values for DeleteVectorStoreFileResponseObject.
const (
	VectorStoreFileDeleted DeleteVectorStoreFileResponseObject = "vector_store.file.deleted"
)

// Defines values for DeleteVectorStoreResponseObject.
const (
	VectorStoreDeleted DeleteVectorStoreResponseObject = "vector_store.deleted"
)

// Defines values for EmbeddingObject.
const (
	EmbeddingObjectEmbedding EmbeddingObject = "embedding"
)

// Defines values for FileSearchRankingOptionsRanker.
const (
	FileSearchRankingOptionsRankerAuto            FileSearchRankingOptionsRanker = "auto"
	FileSearchRankingOptionsRankerDefault20240821 FileSearchRankingOptionsRanker = "default_2024_08_21"
)

// Defines values for FineTuningIntegrationType.
const (
	FineTuningIntegrationTypeWandb FineTuningIntegrationType = "wandb"
)

// Defines values for FineTuningJobHyperparametersNEpochs0.
const (
	FineTuningJobHyperparametersNEpochs0Auto FineTuningJobHyperparametersNEpochs0 = "auto"
)

// Defines values for FineTuningJobObject.
const (
	FineTuningJobObjectFineTuningJob FineTuningJobObject = "fine_tuning.job"
)

// Defines values for FineTuningJobStatus.
const (
	FineTuningJobStatusCancelled       FineTuningJobStatus = "cancelled"
	FineTuningJobStatusFailed          FineTuningJobStatus = "failed"
	FineTuningJobStatusQueued          FineTuningJobStatus = "queued"
	FineTuningJobStatusRunning         FineTuningJobStatus = "running"
	FineTuningJobStatusSucceeded       FineTuningJobStatus = "succeeded"
	FineTuningJobStatusValidatingFiles FineTuningJobStatus = "validating_files"
)

// Defines values for FineTuningJobCheckpointObject.
const (
	FineTuningJobCheckpointObjectFineTuningJobCheckpoint FineTuningJobCheckpointObject = "fine_tuning.job.checkpoint"
)

// Defines values for FineTuningJobEventLevel.
const (
	FineTuningJobEventLevelError FineTuningJobEventLevel = "error"
	FineTuningJobEventLevelInfo  FineTuningJobEventLevel = "info"
	FineTuningJobEventLevelWarn  FineTuningJobEventLevel = "warn"
)

// Defines values for FineTuningJobEventObject.
const (
	FineTuningJobEventObjectFineTuningJobEvent FineTuningJobEventObject = "fine_tuning.job.event"
)

// Defines values for InviteObject.
const (
	OrganizationInvite InviteObject = "organization.invite"
)

// Defines values for InviteRole.
const (
	InviteRoleOwner  InviteRole = "owner"
	InviteRoleReader InviteRole = "reader"
)

// Defines values for InviteStatus.
const (
	InviteStatusAccepted InviteStatus = "accepted"
	InviteStatusExpired  InviteStatus = "expired"
	InviteStatusPending  InviteStatus = "pending"
)

// Defines values for InviteDeleteResponseObject.
const (
	OrganizationInviteDeleted InviteDeleteResponseObject = "organization.invite.deleted"
)

// Defines values for InviteListResponseObject.
const (
	InviteListResponseObjectList InviteListResponseObject = "list"
)

// Defines values for InviteRequestRole.
const (
	InviteRequestRoleOwner  InviteRequestRole = "owner"
	InviteRequestRoleReader InviteRequestRole = "reader"
)

// Defines values for ListAuditLogsResponseObject.
const (
	ListAuditLogsResponseObjectList ListAuditLogsResponseObject = "list"
)

// Defines values for ListBatchesResponseObject.
const (
	ListBatchesResponseObjectList ListBatchesResponseObject = "list"
)

// Defines values for ListFineTuningJobCheckpointsResponseObject.
const (
	ListFineTuningJobCheckpointsResponseObjectList ListFineTuningJobCheckpointsResponseObject = "list"
)

// Defines values for ListFineTuningJobEventsResponseObject.
const (
	ListFineTuningJobEventsResponseObjectList ListFineTuningJobEventsResponseObject = "list"
)

// Defines values for ListModelsResponseObject.
const (
	ListModelsResponseObjectList ListModelsResponseObject = "list"
)

// Defines values for ListPaginatedFineTuningJobsResponseObject.
const (
	ListPaginatedFineTuningJobsResponseObjectList ListPaginatedFineTuningJobsResponseObject = "list"
)

// Defines values for MessageContentImageFileObjectImageFileDetail.
const (
	MessageContentImageFileObjectImageFileDetailAuto MessageContentImageFileObjectImageFileDetail = "auto"
	MessageContentImageFileObjectImageFileDetailHigh MessageContentImageFileObjectImageFileDetail = "high"
	MessageContentImageFileObjectImageFileDetailLow  MessageContentImageFileObjectImageFileDetail = "low"
)

// Defines values for MessageContentImageFileObjectType.
const (
	ImageFile MessageContentImageFileObjectType = "image_file"
)

// Defines values for MessageContentImageUrlObjectImageUrlDetail.
const (
	MessageContentImageUrlObjectImageUrlDetailAuto MessageContentImageUrlObjectImageUrlDetail = "auto"
	MessageContentImageUrlObjectImageUrlDetailHigh MessageContentImageUrlObjectImageUrlDetail = "high"
	MessageContentImageUrlObjectImageUrlDetailLow  MessageContentImageUrlObjectImageUrlDetail = "low"
)

// Defines values for MessageContentImageUrlObjectType.
const (
	ImageUrl MessageContentImageUrlObjectType = "image_url"
)

// Defines values for MessageContentRefusalObjectType.
const (
	MessageContentRefusalObjectTypeRefusal MessageContentRefusalObjectType = "refusal"
)

// Defines values for MessageContentTextAnnotationsFileCitationObjectType.
const (
	FileCitation MessageContentTextAnnotationsFileCitationObjectType = "file_citation"
)

// Defines values for MessageContentTextAnnotationsFilePathObjectType.
const (
	FilePath MessageContentTextAnnotationsFilePathObjectType = "file_path"
)

// Defines values for MessageContentTextObjectType.
const (
	MessageContentTextObjectTypeText MessageContentTextObjectType = "text"
)

// Defines values for MessageObjectIncompleteDetailsReason.
const (
	ContentFilter MessageObjectIncompleteDetailsReason = "content_filter"
	MaxTokens     MessageObjectIncompleteDetailsReason = "max_tokens"
	RunCancelled  MessageObjectIncompleteDetailsReason = "run_cancelled"
	RunExpired    MessageObjectIncompleteDetailsReason = "run_expired"
	RunFailed     MessageObjectIncompleteDetailsReason = "run_failed"
)

// Defines values for MessageObjectObject.
const (
	ThreadMessage MessageObjectObject = "thread.message"
)

// Defines values for MessageObjectRole.
const (
	MessageObjectRoleAssistant MessageObjectRole = "assistant"
	MessageObjectRoleUser      MessageObjectRole = "user"
)

// Defines values for MessageObjectStatus.
const (
	MessageObjectStatusCompleted  MessageObjectStatus = "completed"
	MessageObjectStatusInProgress MessageObjectStatus = "in_progress"
	MessageObjectStatusIncomplete MessageObjectStatus = "incomplete"
)

// Defines values for MessageRequestContentTextObjectType.
const (
	MessageRequestContentTextObjectTypeText MessageRequestContentTextObjectType = "text"
)

// Defines values for ModelObject.
const (
	ModelObjectModel ModelObject = "model"
)

// Defines values for OpenAIFileObject.
const (
	OpenAIFileObjectFile OpenAIFileObject = "file"
)

// Defines values for OpenAIFilePurpose.
const (
	OpenAIFilePurposeAssistants       OpenAIFilePurpose = "assistants"
	OpenAIFilePurposeAssistantsOutput OpenAIFilePurpose = "assistants_output"
	OpenAIFilePurposeBatch            OpenAIFilePurpose = "batch"
	OpenAIFilePurposeBatchOutput      OpenAIFilePurpose = "batch_output"
	OpenAIFilePurposeFineTune         OpenAIFilePurpose = "fine-tune"
	OpenAIFilePurposeFineTuneResults  OpenAIFilePurpose = "fine-tune-results"
	OpenAIFilePurposeVision           OpenAIFilePurpose = "vision"
)

// Defines values for OpenAIFileStatus.
const (
	OpenAIFileStatusError     OpenAIFileStatus = "error"
	OpenAIFileStatusProcessed OpenAIFileStatus = "processed"
	OpenAIFileStatusUploaded  OpenAIFileStatus = "uploaded"
)

// Defines values for OtherChunkingStrategyResponseParamType.
const (
	Other OtherChunkingStrategyResponseParamType = "other"
)

// Defines values for PredictionContentType.
const (
	Content PredictionContentType = "content"
)

// Defines values for ProjectObject.
const (
	OrganizationProject ProjectObject = "organization.project"
)

// Defines values for ProjectStatus.
const (
	Active   ProjectStatus = "active"
	Archived ProjectStatus = "archived"
)

// Defines values for ProjectApiKeyObject.
const (
	OrganizationProjectApiKey ProjectApiKeyObject = "organization.project.api_key"
)

// Defines values for ProjectApiKeyOwnerType.
const (
	ProjectApiKeyOwnerTypeServiceAccount ProjectApiKeyOwnerType = "service_account"
	ProjectApiKeyOwnerTypeUser           ProjectApiKeyOwnerType = "user"
)

// Defines values for ProjectApiKeyDeleteResponseObject.
const (
	OrganizationProjectApiKeyDeleted ProjectApiKeyDeleteResponseObject = "organization.project.api_key.deleted"
)

// Defines values for ProjectApiKeyListResponseObject.
const (
	ProjectApiKeyListResponseObjectList ProjectApiKeyListResponseObject = "list"
)

// Defines values for ProjectListResponseObject.
const (
	ProjectListResponseObjectList ProjectListResponseObject = "list"
)

// Defines values for ProjectRateLimitObject.
const (
	ProjectRateLimitObjectProjectRateLimit ProjectRateLimitObject = "project.rate_limit"
)

// Defines values for ProjectRateLimitListResponseObject.
const (
	ProjectRateLimitListResponseObjectList ProjectRateLimitListResponseObject = "list"
)

// Defines values for ProjectServiceAccountObject.
const (
	ProjectServiceAccountObjectOrganizationProjectServiceAccount ProjectServiceAccountObject = "organization.project.service_account"
)

// Defines values for ProjectServiceAccountRole.
const (
	ProjectServiceAccountRoleMember ProjectServiceAccountRole = "member"
	ProjectServiceAccountRoleOwner  ProjectServiceAccountRole = "owner"
)

// Defines values for ProjectServiceAccountApiKeyObject.
const (
	OrganizationProjectServiceAccountApiKey ProjectServiceAccountApiKeyObject = "organization.project.service_account.api_key"
)

// Defines values for ProjectServiceAccountCreateResponseObject.
const (
	ProjectServiceAccountCreateResponseObjectOrganizationProjectServiceAccount ProjectServiceAccountCreateResponseObject = "organization.project.service_account"
)

// Defines values for ProjectServiceAccountCreateResponseRole.
const (
	ProjectServiceAccountCreateResponseRoleMember ProjectServiceAccountCreateResponseRole = "member"
)

// Defines values for ProjectServiceAccountDeleteResponseObject.
const (
	OrganizationProjectServiceAccountDeleted ProjectServiceAccountDeleteResponseObject = "organization.project.service_account.deleted"
)

// Defines values for ProjectServiceAccountListResponseObject.
const (
	ProjectServiceAccountListResponseObjectList ProjectServiceAccountListResponseObject = "list"
)

// Defines values for ProjectUserObject.
const (
	OrganizationProjectUser ProjectUserObject = "organization.project.user"
)

// Defines values for ProjectUserRole.
const (
	ProjectUserRoleMember ProjectUserRole = "member"
	ProjectUserRoleOwner  ProjectUserRole = "owner"
)

// Defines values for ProjectUserCreateRequestRole.
const (
	ProjectUserCreateRequestRoleMember ProjectUserCreateRequestRole = "member"
	ProjectUserCreateRequestRoleOwner  ProjectUserCreateRequestRole = "owner"
)

// Defines values for ProjectUserDeleteResponseObject.
const (
	OrganizationProjectUserDeleted ProjectUserDeleteResponseObject = "organization.project.user.deleted"
)

// Defines values for ProjectUserUpdateRequestRole.
const (
	ProjectUserUpdateRequestRoleMember ProjectUserUpdateRequestRole = "member"
	ProjectUserUpdateRequestRoleOwner  ProjectUserUpdateRequestRole = "owner"
)

// Defines values for ResponseFormatJsonObjectType.
const (
	JsonObject ResponseFormatJsonObjectType = "json_object"
)

// Defines values for ResponseFormatJsonSchemaType.
const (
	JsonSchema ResponseFormatJsonSchemaType = "json_schema"
)

// Defines values for ResponseFormatTextType.
const (
	ResponseFormatTextTypeText ResponseFormatTextType = "text"
)

// Defines values for RunObjectIncompleteDetailsReason.
const (
	MaxCompletionTokens RunObjectIncompleteDetailsReason = "max_completion_tokens"
	MaxPromptTokens     RunObjectIncompleteDetailsReason = "max_prompt_tokens"
)

// Defines values for RunObjectLastErrorCode.
const (
	RunObjectLastErrorCodeInvalidPrompt     RunObjectLastErrorCode = "invalid_prompt"
	RunObjectLastErrorCodeRateLimitExceeded RunObjectLastErrorCode = "rate_limit_exceeded"
	RunObjectLastErrorCodeServerError       RunObjectLastErrorCode = "server_error"
)

// Defines values for RunObjectObject.
const (
	ThreadRun RunObjectObject = "thread.run"
)

// Defines values for RunObjectRequiredActionType.
const (
	SubmitToolOutputs RunObjectRequiredActionType = "submit_tool_outputs"
)

// Defines values for RunObjectStatus.
const (
	RunObjectStatusCancelled      RunObjectStatus = "cancelled"
	RunObjectStatusCancelling     RunObjectStatus = "cancelling"
	RunObjectStatusCompleted      RunObjectStatus = "completed"
	RunObjectStatusExpired        RunObjectStatus = "expired"
	RunObjectStatusFailed         RunObjectStatus = "failed"
	RunObjectStatusInProgress     RunObjectStatus = "in_progress"
	RunObjectStatusIncomplete     RunObjectStatus = "incomplete"
	RunObjectStatusQueued         RunObjectStatus = "queued"
	RunObjectStatusRequiresAction RunObjectStatus = "requires_action"
)

// Defines values for RunStepDetailsMessageCreationObjectType.
const (
	RunStepDetailsMessageCreationObjectTypeMessageCreation RunStepDetailsMessageCreationObjectType = "message_creation"
)

// Defines values for RunStepDetailsToolCallsCodeObjectType.
const (
	CodeInterpreter RunStepDetailsToolCallsCodeObjectType = "code_interpreter"
)

// Defines values for RunStepDetailsToolCallsCodeOutputImageObjectType.
const (
	RunStepDetailsToolCallsCodeOutputImageObjectTypeImage RunStepDetailsToolCallsCodeOutputImageObjectType = "image"
)

// Defines values for RunStepDetailsToolCallsCodeOutputLogsObjectType.
const (
	Logs RunStepDetailsToolCallsCodeOutputLogsObjectType = "logs"
)

// Defines values for RunStepDetailsToolCallsFileSearchObjectType.
const (
	FileSearch RunStepDetailsToolCallsFileSearchObjectType = "file_search"
)

// Defines values for RunStepDetailsToolCallsFileSearchRankingOptionsObjectRanker.
const (
	Default20240821 RunStepDetailsToolCallsFileSearchRankingOptionsObjectRanker = "default_2024_08_21"
)

// Defines values for RunStepDetailsToolCallsFileSearchResultObjectContentType.
const (
	RunStepDetailsToolCallsFileSearchResultObjectContentTypeText RunStepDetailsToolCallsFileSearchResultObjectContentType = "text"
)

// Defines values for RunStepDetailsToolCallsFunctionObjectType.
const (
	RunStepDetailsToolCallsFunctionObjectTypeFunction RunStepDetailsToolCallsFunctionObjectType = "function"
)

// Defines values for RunStepDetailsToolCallsObjectType.
const (
	ToolCalls RunStepDetailsToolCallsObjectType = "tool_calls"
)

// Defines values for RunStepObjectLastErrorCode.
const (
	RunStepObjectLastErrorCodeRateLimitExceeded RunStepObjectLastErrorCode = "rate_limit_exceeded"
	RunStepObjectLastErrorCodeServerError       RunStepObjectLastErrorCode = "server_error"
)

// Defines values for RunStepObjectObject.
const (
	ThreadRunStep RunStepObjectObject = "thread.run.step"
)

// Defines values for RunStepObjectStatus.
const (
	RunStepObjectStatusCancelled  RunStepObjectStatus = "cancelled"
	RunStepObjectStatusCompleted  RunStepObjectStatus = "completed"
	RunStepObjectStatusExpired    RunStepObjectStatus = "expired"
	RunStepObjectStatusFailed     RunStepObjectStatus = "failed"
	RunStepObjectStatusInProgress RunStepObjectStatus = "in_progress"
)

// Defines values for RunStepObjectType.
const (
	RunStepObjectTypeMessageCreation RunStepObjectType = "message_creation"
	RunStepObjectTypeToolCalls       RunStepObjectType = "tool_calls"
)

// Defines values for RunToolCallObjectType.
const (
	Function RunToolCallObjectType = "function"
)

// Defines values for StaticChunkingStrategyRequestParamType.
const (
	StaticChunkingStrategyRequestParamTypeStatic StaticChunkingStrategyRequestParamType = "static"
)

// Defines values for StaticChunkingStrategyResponseParamType.
const (
	StaticChunkingStrategyResponseParamTypeStatic StaticChunkingStrategyResponseParamType = "static"
)

// Defines values for ThreadObjectObject.
const (
	Thread ThreadObjectObject = "thread"
)

// Defines values for TruncationObjectType.
const (
	Auto         TruncationObjectType = "auto"
	LastMessages TruncationObjectType = "last_messages"
)

// Defines values for UploadObject.
const (
	UploadObjectUpload UploadObject = "upload"
)

// Defines values for UploadStatus.
const (
	UploadStatusCancelled UploadStatus = "cancelled"
	UploadStatusCompleted UploadStatus = "completed"
	UploadStatusExpired   UploadStatus = "expired"
	UploadStatusPending   UploadStatus = "pending"
)

// Defines values for UploadPartObject.
const (
	UploadPartObjectUploadPart UploadPartObject = "upload.part"
)

// Defines values for UserObject.
const (
	OrganizationUser UserObject = "organization.user"
)

// Defines values for UserRole.
const (
	UserRoleOwner  UserRole = "owner"
	UserRoleReader UserRole = "reader"
)

// Defines values for UserDeleteResponseObject.
const (
	OrganizationUserDeleted UserDeleteResponseObject = "organization.user.deleted"
)

// Defines values for UserListResponseObject.
const (
	List UserListResponseObject = "list"
)

// Defines values for UserRoleUpdateRequestRole.
const (
	Owner  UserRoleUpdateRequestRole = "owner"
	Reader UserRoleUpdateRequestRole = "reader"
)

// Defines values for VectorStoreExpirationAfterAnchor.
const (
	LastActiveAt VectorStoreExpirationAfterAnchor = "last_active_at"
)

// Defines values for VectorStoreFileBatchObjectObject.
const (
	VectorStoreFilesBatch VectorStoreFileBatchObjectObject = "vector_store.files_batch"
)

// Defines values for VectorStoreFileBatchObjectStatus.
const (
	VectorStoreFileBatchObjectStatusCancelled  VectorStoreFileBatchObjectStatus = "cancelled"
	VectorStoreFileBatchObjectStatusCompleted  VectorStoreFileBatchObjectStatus = "completed"
	VectorStoreFileBatchObjectStatusFailed     VectorStoreFileBatchObjectStatus = "failed"
	VectorStoreFileBatchObjectStatusInProgress VectorStoreFileBatchObjectStatus = "in_progress"
)

// Defines values for VectorStoreFileObjectLastErrorCode.
const (
	InvalidFile     VectorStoreFileObjectLastErrorCode = "invalid_file"
	ServerError     VectorStoreFileObjectLastErrorCode = "server_error"
	UnsupportedFile VectorStoreFileObjectLastErrorCode = "unsupported_file"
)

// Defines values for VectorStoreFileObjectObject.
const (
	VectorStoreFile VectorStoreFileObjectObject = "vector_store.file"
)

// Defines values for VectorStoreFileObjectStatus.
const (
	VectorStoreFileObjectStatusCancelled  VectorStoreFileObjectStatus = "cancelled"
	VectorStoreFileObjectStatusCompleted  VectorStoreFileObjectStatus = "completed"
	VectorStoreFileObjectStatusFailed     VectorStoreFileObjectStatus = "failed"
	VectorStoreFileObjectStatusInProgress VectorStoreFileObjectStatus = "in_progress"
)

// Defines values for VectorStoreObjectObject.
const (
	VectorStore VectorStoreObjectObject = "vector_store"
)

// Defines values for VectorStoreObjectStatus.
const (
	VectorStoreObjectStatusCompleted  VectorStoreObjectStatus = "completed"
	VectorStoreObjectStatusExpired    VectorStoreObjectStatus = "expired"
	VectorStoreObjectStatusInProgress VectorStoreObjectStatus = "in_progress"
)

// Defines values for ListAssistantsParamsOrder.
const (
	ListAssistantsParamsOrderAsc  ListAssistantsParamsOrder = "asc"
	ListAssistantsParamsOrderDesc ListAssistantsParamsOrder = "desc"
)

// Defines values for CreateBatchJSONBodyCompletionWindow.
const (
	N24h CreateBatchJSONBodyCompletionWindow = "24h"
)

// Defines values for CreateBatchJSONBodyEndpoint.
const (
	V1chatcompletions CreateBatchJSONBodyEndpoint = "/v1/chat/completions"
	V1completions     CreateBatchJSONBodyEndpoint = "/v1/completions"
	V1embeddings      CreateBatchJSONBodyEndpoint = "/v1/embeddings"
)

// Defines values for ListFilesParamsOrder.
const (
	ListFilesParamsOrderAsc  ListFilesParamsOrder = "asc"
	ListFilesParamsOrderDesc ListFilesParamsOrder = "desc"
)

// Defines values for ListMessagesParamsOrder.
const (
	ListMessagesParamsOrderAsc  ListMessagesParamsOrder = "asc"
	ListMessagesParamsOrderDesc ListMessagesParamsOrder = "desc"
)

// Defines values for ListRunsParamsOrder.
const (
	ListRunsParamsOrderAsc  ListRunsParamsOrder = "asc"
	ListRunsParamsOrderDesc ListRunsParamsOrder = "desc"
)

// Defines values for CreateRunParamsInclude.
const (
	CreateRunParamsIncludeStepDetailsToolCallsFileSearchResultsContent CreateRunParamsInclude = "step_details.tool_calls[*].file_search.results[*].content"
)

// Defines values for ListRunStepsParamsOrder.
const (
	ListRunStepsParamsOrderAsc  ListRunStepsParamsOrder = "asc"
	ListRunStepsParamsOrderDesc ListRunStepsParamsOrder = "desc"
)

// Defines values for ListRunStepsParamsInclude.
const (
	ListRunStepsParamsIncludeStepDetailsToolCallsFileSearchResultsContent ListRunStepsParamsInclude = "step_details.tool_calls[*].file_search.results[*].content"
)

// Defines values for GetRunStepParamsInclude.
const (
	StepDetailsToolCallsFileSearchResultsContent GetRunStepParamsInclude = "step_details.tool_calls[*].file_search.results[*].content"
)

// Defines values for ListVectorStoresParamsOrder.
const (
	ListVectorStoresParamsOrderAsc  ListVectorStoresParamsOrder = "asc"
	ListVectorStoresParamsOrderDesc ListVectorStoresParamsOrder = "desc"
)

// Defines values for ListFilesInVectorStoreBatchParamsOrder.
const (
	ListFilesInVectorStoreBatchParamsOrderAsc  ListFilesInVectorStoreBatchParamsOrder = "asc"
	ListFilesInVectorStoreBatchParamsOrderDesc ListFilesInVectorStoreBatchParamsOrder = "desc"
)

// Defines values for ListFilesInVectorStoreBatchParamsFilter.
const (
	ListFilesInVectorStoreBatchParamsFilterCancelled  ListFilesInVectorStoreBatchParamsFilter = "cancelled"
	ListFilesInVectorStoreBatchParamsFilterCompleted  ListFilesInVectorStoreBatchParamsFilter = "completed"
	ListFilesInVectorStoreBatchParamsFilterFailed     ListFilesInVectorStoreBatchParamsFilter = "failed"
	ListFilesInVectorStoreBatchParamsFilterInProgress ListFilesInVectorStoreBatchParamsFilter = "in_progress"
)

// Defines values for ListVectorStoreFilesParamsOrder.
const (
	ListVectorStoreFilesParamsOrderAsc  ListVectorStoreFilesParamsOrder = "asc"
	ListVectorStoreFilesParamsOrderDesc ListVectorStoreFilesParamsOrder = "desc"
)

// Defines values for ListVectorStoreFilesParamsFilter.
const (
	ListVectorStoreFilesParamsFilterCancelled  ListVectorStoreFilesParamsFilter = "cancelled"
	ListVectorStoreFilesParamsFilterCompleted  ListVectorStoreFilesParamsFilter = "completed"
	ListVectorStoreFilesParamsFilterFailed     ListVectorStoreFilesParamsFilter = "failed"
	ListVectorStoreFilesParamsFilterInProgress ListVectorStoreFilesParamsFilter = "in_progress"
)

// AddUploadPartRequest defines model for AddUploadPartRequest.
type AddUploadPartRequest struct {
	// Data The chunk of bytes for this Part.
	Data openapi_types.File `json:"data"`
}

// AssistantObject Represents an `assistant` that can call the model and use tools.
type AssistantObject struct {
	// CreatedAt The Unix timestamp (in seconds) for when the assistant was created.
	CreatedAt int `json:"created_at"`

	// Description The description of the assistant. The maximum length is 512 characters.
	Description *string `json:"description"`

	// Id The identifier, which can be referenced in API endpoints.
	Id string `json:"id"`

	// Instructions The system instructions that the assistant uses. The maximum length is 256,000 characters.
	Instructions *string `json:"instructions"`

	// Metadata Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
	Metadata *map[string]interface{} `json:"metadata"`

	// Model ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them.
	Model string `json:"model"`

	// Name The name of the assistant. The maximum length is 256 characters.
	Name *string `json:"name"`

	// Object The object type, which is always `assistant`.
	Object AssistantObjectObject `json:"object"`

	// ResponseFormat Specifies the format that the model must output. Compatible with [GPT-4o](/docs/models#gpt-4o), [GPT-4 Turbo](/docs/models#gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.
	//
	// Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema. Learn more in the [Structured Outputs guide](/docs/guides/structured-outputs).
	//
	// Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates is valid JSON.
	//
	// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
	ResponseFormat *AssistantsApiResponseFormatOption `json:"response_format,omitempty"`

	// Temperature What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
	Temperature *float32 `json:"temperature"`

	// ToolResources A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
	ToolResources *struct {
		CodeInterpreter *struct {
			// FileIds A list of [file](/docs/api-reference/files) IDs made available to the `code_interpreter`` tool. There can be a maximum of 20 files associated with the tool.
			FileIds *[]string `json:"file_ids,omitempty"`
		} `json:"code_interpreter,omitempty"`
		FileSearch *struct {
			// VectorStoreIds The ID of the [vector store](/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant.
			VectorStoreIds *[]string `json:"vector_store_ids,omitempty"`
		} `json:"file_search,omitempty"`
	} `json:"tool_resources"`

	// Tools A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`.
	Tools []AssistantObject_Tools_Item `json:"tools"`

	// TopP An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
	//
	// We generally recommend altering this or temperature but not both.
	TopP *float32 `json:"top_p"`
}

// AssistantObjectObject The object type, which is always `assistant`.
type AssistantObjectObject string

// AssistantObject_Tools_Item defines model for AssistantObject.tools.Item.
type AssistantObject_Tools_Item struct {
	union json.RawMessage
}

// AssistantToolsCode defines model for AssistantToolsCode.
type AssistantToolsCode struct {
	// Type The type of tool being defined: `code_interpreter`
	Type AssistantToolsCodeType `json:"type"`
}

// AssistantToolsCodeType The type of tool being defined: `code_interpreter`
type AssistantToolsCodeType string

// AssistantToolsFileSearch defines model for AssistantToolsFileSearch.
type AssistantToolsFileSearch struct {
	// FileSearch Overrides for the file search tool.
	FileSearch *struct {
		// MaxNumResults The maximum number of results the file search tool should output. The default is 20 for `gpt-4*` models and 5 for `gpt-3.5-turbo`. This number should be between 1 and 50 inclusive.
		//
		// Note that the file search tool may output fewer than `max_num_results` results. See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information.
		MaxNumResults *int `json:"max_num_results,omitempty"`

		// RankingOptions The ranking options for the file search. If not specified, the file search tool will use the `auto` ranker and a score_threshold of 0.
		//
		// See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information.
		RankingOptions *FileSearchRankingOptions `json:"ranking_options,omitempty"`
	} `json:"file_search,omitempty"`

	// Type The type of tool being defined: `file_search`
	Type AssistantToolsFileSearchType `json:"type"`
}

// AssistantToolsFileSearchType The type of tool being defined: `file_search`
type AssistantToolsFileSearchType string

// AssistantToolsFileSearchTypeOnly defines model for AssistantToolsFileSearchTypeOnly.
type AssistantToolsFileSearchTypeOnly struct {
	// Type The type of tool being defined: `file_search`
	Type AssistantToolsFileSearchTypeOnlyType `json:"type"`
}

// AssistantToolsFileSearchTypeOnlyType The type of tool being defined: `file_search`
type AssistantToolsFileSearchTypeOnlyType string

// AssistantToolsFunction defines model for AssistantToolsFunction.
type AssistantToolsFunction struct {
	Function FunctionObject `json:"function"`

	// Type The type of tool being defined: `function`
	Type AssistantToolsFunctionType `json:"type"`
}

// AssistantToolsFunctionType The type of tool being defined: `function`
type AssistantToolsFunctionType string

// AssistantsApiResponseFormatOption Specifies the format that the model must output. Compatible with [GPT-4o](/docs/models#gpt-4o), [GPT-4 Turbo](/docs/models#gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.
//
// Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema. Learn more in the [Structured Outputs guide](/docs/guides/structured-outputs).
//
// Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates is valid JSON.
//
// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
type AssistantsApiResponseFormatOption struct {
	union json.RawMessage
}

// AssistantsApiResponseFormatOption0 `auto` is the default value
type AssistantsApiResponseFormatOption0 string

// AssistantsApiToolChoiceOption Controls which (if any) tool is called by the model.
// `none` means the model will not call any tools and instead generates a message.
// `auto` is the default value and means the model can pick between generating a message or calling one or more tools.
// `required` means the model must call one or more tools before responding to the user.
// Specifying a particular tool like `{"type": "file_search"}` or `{"type": "function", "function": {"name": "my_function"}}` forces the model to call that tool.
type AssistantsApiToolChoiceOption struct {
	union json.RawMessage
}

// AssistantsApiToolChoiceOption0 `none` means the model will not call any tools and instead generates a message. `auto` means the model can pick between generating a message or calling one or more tools. `required` means the model must call one or more tools before responding to the user.
type AssistantsApiToolChoiceOption0 string

// AssistantsNamedToolChoice Specifies a tool the model should use. Use to force the model to call a specific tool.
type AssistantsNamedToolChoice struct {
	Function *struct {
		// Name The name of the function to call.
		Name string `json:"name"`
	} `json:"function,omitempty"`

	// Type The type of the tool. If type is `function`, the function name must be set
	Type AssistantsNamedToolChoiceType `json:"type"`
}

// AssistantsNamedToolChoiceType The type of the tool. If type is `function`, the function name must be set
type AssistantsNamedToolChoiceType string

// AudioResponseFormat The format of the output, in one of these options: `json`, `text`, `srt`, `verbose_json`, or `vtt`.
type AudioResponseFormat string

// AuditLog A log of a user action or configuration change within this organization.
type AuditLog struct {
	// Actor The actor who performed the audit logged action.
	Actor AuditLogActor `json:"actor"`

	// ApiKeyCreated The details for events with this `type`.
	ApiKeyCreated *struct {
		// Data The payload used to create the API key.
		Data *struct {
			// Scopes A list of scopes allowed for the API key, e.g. `["api.model.request"]`
			Scopes *[]string `json:"scopes,omitempty"`
		} `json:"data,omitempty"`

		// Id The tracking ID of the API key.
		Id *string `json:"id,omitempty"`
	} `json:"api_key.created,omitempty"`

	// ApiKeyDeleted The details for events with this `type`.
	ApiKeyDeleted *struct {
		// Id The tracking ID of the API key.
		Id *string `json:"id,omitempty"`
	} `json:"api_key.deleted,omitempty"`

	// ApiKeyUpdated The details for events with this `type`.
	ApiKeyUpdated *struct {
		// ChangesRequested The payload used to update the API key.
		ChangesRequested *struct {
			// Scopes A list of scopes allowed for the API key, e.g. `["api.model.request"]`
			Scopes *[]string `json:"scopes,omitempty"`
		} `json:"changes_requested,omitempty"`

		// Id The tracking ID of the API key.
		Id *string `json:"id,omitempty"`
	} `json:"api_key.updated,omitempty"`

	// EffectiveAt The Unix timestamp (in seconds) of the event.
	EffectiveAt int `json:"effective_at"`

	// Id The ID of this log.
	Id string `json:"id"`

	// InviteAccepted The details for events with this `type`.
	InviteAccepted *struct {
		// Id The ID of the invite.
		Id *string `json:"id,omitempty"`
	} `json:"invite.accepted,omitempty"`

	// InviteDeleted The details for events with this `type`.
	InviteDeleted *struct {
		// Id The ID of the invite.
		Id *string `json:"id,omitempty"`
	} `json:"invite.deleted,omitempty"`

	// InviteSent The details for events with this `type`.
	InviteSent *struct {
		// Data The payload used to create the invite.
		Data *struct {
			// Email The email invited to the organization.
			Email *string `json:"email,omitempty"`

			// Role The role the email was invited to be. Is either `owner` or `member`.
			Role *string `json:"role,omitempty"`
		} `json:"data,omitempty"`

		// Id The ID of the invite.
		Id *string `json:"id,omitempty"`
	} `json:"invite.sent,omitempty"`

	// LoginFailed The details for events with this `type`.
	LoginFailed *struct {
		// ErrorCode The error code of the failure.
		ErrorCode *string `json:"error_code,omitempty"`

		// ErrorMessage The error message of the failure.
		ErrorMessage *string `json:"error_message,omitempty"`
	} `json:"login.failed,omitempty"`

	// LogoutFailed The details for events with this `type`.
	LogoutFailed *struct {
		// ErrorCode The error code of the failure.
		ErrorCode *string `json:"error_code,omitempty"`

		// ErrorMessage The error message of the failure.
		ErrorMessage *string `json:"error_message,omitempty"`
	} `json:"logout.failed,omitempty"`

	// OrganizationUpdated The details for events with this `type`.
	OrganizationUpdated *struct {
		// ChangesRequested The payload used to update the organization settings.
		ChangesRequested *struct {
			// Description The organization description.
			Description *string `json:"description,omitempty"`

			// Name The organization name.
			Name     *string `json:"name,omitempty"`
			Settings *struct {
				// ThreadsUiVisibility Visibility of the threads page which shows messages created with the Assistants API and Playground. One of `ANY_ROLE`, `OWNERS`, or `NONE`.
				ThreadsUiVisibility *string `json:"threads_ui_visibility,omitempty"`

				// UsageDashboardVisibility Visibility of the usage dashboard which shows activity and costs for your organization. One of `ANY_ROLE` or `OWNERS`.
				UsageDashboardVisibility *string `json:"usage_dashboard_visibility,omitempty"`
			} `json:"settings,omitempty"`

			// Title The organization title.
			Title *string `json:"title,omitempty"`
		} `json:"changes_requested,omitempty"`

		// Id The organization ID.
		Id *string `json:"id,omitempty"`
	} `json:"organization.updated,omitempty"`

	// Project The project that the action was scoped to. Absent for actions not scoped to projects.
	Project *struct {
		// Id The project ID.
		Id *string `json:"id,omitempty"`

		// Name The project title.
		Name *string `json:"name,omitempty"`
	} `json:"project,omitempty"`

	// ProjectArchived The details for events with this `type`.
	ProjectArchived *struct {
		// Id The project ID.
		Id *string `json:"id,omitempty"`
	} `json:"project.archived,omitempty"`

	// ProjectCreated The details for events with this `type`.
	ProjectCreated *struct {
		// Data The payload used to create the project.
		Data *struct {
			// Name The project name.
			Name *string `json:"name,omitempty"`

			// Title The title of the project as seen on the dashboard.
			Title *string `json:"title,omitempty"`
		} `json:"data,omitempty"`

		// Id The project ID.
		Id *string `json:"id,omitempty"`
	} `json:"project.created,omitempty"`

	// ProjectUpdated The details for events with this `type`.
	ProjectUpdated *struct {
		// ChangesRequested The payload used to update the project.
		ChangesRequested *struct {
			// Title The title of the project as seen on the dashboard.
			Title *string `json:"title,omitempty"`
		} `json:"changes_requested,omitempty"`

		// Id The project ID.
		Id *string `json:"id,omitempty"`
	} `json:"project.updated,omitempty"`

	// RateLimitDeleted The details for events with this `type`.
	RateLimitDeleted *struct {
		// Id The rate limit ID
		Id *string `json:"id,omitempty"`
	} `json:"rate_limit.deleted,omitempty"`

	// RateLimitUpdated The details for events with this `type`.
	RateLimitUpdated *struct {
		// ChangesRequested The payload used to update the rate limits.
		ChangesRequested *struct {
			// Batch1DayMaxInputTokens The maximum batch input tokens per day. Only relevant for certain models.
			Batch1DayMaxInputTokens *int `json:"batch_1_day_max_input_tokens,omitempty"`

			// MaxAudioMegabytesPer1Minute The maximum audio megabytes per minute. Only relevant for certain models.
			MaxAudioMegabytesPer1Minute *int `json:"max_audio_megabytes_per_1_minute,omitempty"`

			// MaxImagesPer1Minute The maximum images per minute. Only relevant for certain models.
			MaxImagesPer1Minute *int `json:"max_images_per_1_minute,omitempty"`

			// MaxRequestsPer1Day The maximum requests per day. Only relevant for certain models.
			MaxRequestsPer1Day *int `json:"max_requests_per_1_day,omitempty"`

			// MaxRequestsPer1Minute The maximum requests per minute.
			MaxRequestsPer1Minute *int `json:"max_requests_per_1_minute,omitempty"`

			// MaxTokensPer1Minute The maximum tokens per minute.
			MaxTokensPer1Minute *int `json:"max_tokens_per_1_minute,omitempty"`
		} `json:"changes_requested,omitempty"`

		// Id The rate limit ID
		Id *string `json:"id,omitempty"`
	} `json:"rate_limit.updated,omitempty"`

	// ServiceAccountCreated The details for events with this `type`.
	ServiceAccountCreated *struct {
		// Data The payload used to create the service account.
		Data *struct {
			// Role The role of the service account. Is either `owner` or `member`.
			Role *string `json:"role,omitempty"`
		} `json:"data,omitempty"`

		// Id The service account ID.
		Id *string `json:"id,omitempty"`
	} `json:"service_account.created,omitempty"`

	// ServiceAccountDeleted The details for events with this `type`.
	ServiceAccountDeleted *struct {
		// Id The service account ID.
		Id *string `json:"id,omitempty"`
	} `json:"service_account.deleted,omitempty"`

	// ServiceAccountUpdated The details for events with this `type`.
	ServiceAccountUpdated *struct {
		// ChangesRequested The payload used to updated the service account.
		ChangesRequested *struct {
			// Role The role of the service account. Is either `owner` or `member`.
			Role *string `json:"role,omitempty"`
		} `json:"changes_requested,omitempty"`

		// Id The service account ID.
		Id *string `json:"id,omitempty"`
	} `json:"service_account.updated,omitempty"`

	// Type The event type.
	Type AuditLogEventType `json:"type"`

	// UserAdded The details for events with this `type`.
	UserAdded *struct {
		// Data The payload used to add the user to the project.
		Data *struct {
			// Role The role of the user. Is either `owner` or `member`.
			Role *string `json:"role,omitempty"`
		} `json:"data,omitempty"`

		// Id The user ID.
		Id *string `json:"id,omitempty"`
	} `json:"user.added,omitempty"`

	// UserDeleted The details for events with this `type`.
	UserDeleted *struct {
		// Id The user ID.
		Id *string `json:"id,omitempty"`
	} `json:"user.deleted,omitempty"`

	// UserUpdated The details for events with this `type`.
	UserUpdated *struct {
		// ChangesRequested The payload used to update the user.
		ChangesRequested *struct {
			// Role The role of the user. Is either `owner` or `member`.
			Role *string `json:"role,omitempty"`
		} `json:"changes_requested,omitempty"`

		// Id The project ID.
		Id *string `json:"id,omitempty"`
	} `json:"user.updated,omitempty"`
}

// AuditLogActor The actor who performed the audit logged action.
type AuditLogActor struct {
	// ApiKey The API Key used to perform the audit logged action.
	ApiKey *AuditLogActorApiKey `json:"api_key,omitempty"`

	// Session The session in which the audit logged action was performed.
	Session *AuditLogActorSession `json:"session,omitempty"`

	// Type The type of actor. Is either `session` or `api_key`.
	Type *AuditLogActorType `json:"type,omitempty"`
}

// AuditLogActorType The type of actor. Is either `session` or `api_key`.
type AuditLogActorType string

// AuditLogActorApiKey The API Key used to perform the audit logged action.
type AuditLogActorApiKey struct {
	// Id The tracking id of the API key.
	Id *string `json:"id,omitempty"`

	// ServiceAccount The service account that performed the audit logged action.
	ServiceAccount *AuditLogActorServiceAccount `json:"service_account,omitempty"`

	// Type The type of API key. Can be either `user` or `service_account`.
	Type *AuditLogActorApiKeyType `json:"type,omitempty"`

	// User The user who performed the audit logged action.
	User *AuditLogActorUser `json:"user,omitempty"`
}

// AuditLogActorApiKeyType The type of API key. Can be either `user` or `service_account`.
type AuditLogActorApiKeyType string

// AuditLogActorServiceAccount The service account that performed the audit logged action.
type AuditLogActorServiceAccount struct {
	// Id The service account id.
	Id *string `json:"id,omitempty"`
}

// AuditLogActorSession The session in which the audit logged action was performed.
type AuditLogActorSession struct {
	// IpAddress The IP address from which the action was performed.
	IpAddress *string `json:"ip_address,omitempty"`

	// User The user who performed the audit logged action.
	User *AuditLogActorUser `json:"user,omitempty"`
}

// AuditLogActorUser The user who performed the audit logged action.
type AuditLogActorUser struct {
	// Email The user email.
	Email *string `json:"email,omitempty"`

	// Id The user id.
	Id *string `json:"id,omitempty"`
}

// AuditLogEventType The event type.
type AuditLogEventType string

// AutoChunkingStrategyRequestParam The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`.
type AutoChunkingStrategyRequestParam struct {
	// Type Always `auto`.
	Type AutoChunkingStrategyRequestParamType `json:"type"`
}

// AutoChunkingStrategyRequestParamType Always `auto`.
type AutoChunkingStrategyRequestParamType string

// Batch defines model for Batch.
type Batch struct {
	// CancelledAt The Unix timestamp (in seconds) for when the batch was cancelled.
	CancelledAt *int `json:"cancelled_at,omitempty"`

	// CancellingAt The Unix timestamp (in seconds) for when the batch started cancelling.
	CancellingAt *int `json:"cancelling_at,omitempty"`

	// CompletedAt The Unix timestamp (in seconds) for when the batch was completed.
	CompletedAt *int `json:"completed_at,omitempty"`

	// CompletionWindow The time frame within which the batch should be processed.
	CompletionWindow string `json:"completion_window"`

	// CreatedAt The Unix timestamp (in seconds) for when the batch was created.
	CreatedAt int `json:"created_at"`

	// Endpoint The OpenAI API endpoint used by the batch.
	Endpoint string `json:"endpoint"`

	// ErrorFileId The ID of the file containing the outputs of requests with errors.
	ErrorFileId *string `json:"error_file_id,omitempty"`
	Errors      *struct {
		Data *[]struct {
			// Code An error code identifying the error type.
			Code *string `json:"code,omitempty"`

			// Line The line number of the input file where the error occurred, if applicable.
			Line *int `json:"line"`

			// Message A human-readable message providing more details about the error.
			Message *string `json:"message,omitempty"`

			// Param The name of the parameter that caused the error, if applicable.
			Param *string `json:"param"`
		} `json:"data,omitempty"`

		// Object The object type, which is always `list`.
		Object *string `json:"object,omitempty"`
	} `json:"errors,omitempty"`

	// ExpiredAt The Unix timestamp (in seconds) for when the batch expired.
	ExpiredAt *int `json:"expired_at,omitempty"`

	// ExpiresAt The Unix timestamp (in seconds) for when the batch will expire.
	ExpiresAt *int `json:"expires_at,omitempty"`

	// FailedAt The Unix timestamp (in seconds) for when the batch failed.
	FailedAt *int `json:"failed_at,omitempty"`

	// FinalizingAt The Unix timestamp (in seconds) for when the batch started finalizing.
	FinalizingAt *int   `json:"finalizing_at,omitempty"`
	Id           string `json:"id"`

	// InProgressAt The Unix timestamp (in seconds) for when the batch started processing.
	InProgressAt *int `json:"in_progress_at,omitempty"`

	// InputFileId The ID of the input file for the batch.
	InputFileId string `json:"input_file_id"`

	// Metadata Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
	Metadata *map[string]interface{} `json:"metadata"`

	// Object The object type, which is always `batch`.
	Object BatchObject `json:"object"`

	// OutputFileId The ID of the file containing the outputs of successfully executed requests.
	OutputFileId *string `json:"output_file_id,omitempty"`

	// RequestCounts The request counts for different statuses within the batch.
	RequestCounts *struct {
		// Completed Number of requests that have been completed successfully.
		Completed int `json:"completed"`

		// Failed Number of requests that have failed.
		Failed int `json:"failed"`

		// Total Total number of requests in the batch.
		Total int `json:"total"`
	} `json:"request_counts,omitempty"`

	// Status The current status of the batch.
	Status BatchStatus `json:"status"`
}

// BatchObject The object type, which is always `batch`.
type BatchObject string

// BatchStatus The current status of the batch.
type BatchStatus string

// ChatCompletionFunctionCallOption Specifying a particular function via `{"name": "my_function"}` forces the model to call that function.
type ChatCompletionFunctionCallOption struct {
	// Name The name of the function to call.
	Name string `json:"name"`
}

// ChatCompletionFunctions defines model for ChatCompletionFunctions.
type ChatCompletionFunctions struct {
	// Description A description of what the function does, used by the model to choose when and how to call the function.
	Description *string `json:"description,omitempty"`

	// Name The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
	Name string `json:"name"`

	// Parameters The parameters the functions accepts, described as a JSON Schema object. See the [guide](/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
	//
	// Omitting `parameters` defines a function with an empty parameter list.
	Parameters *FunctionParameters `json:"parameters,omitempty"`
}

// ChatCompletionMessageToolCall defines model for ChatCompletionMessageToolCall.
type ChatCompletionMessageToolCall struct {
	// Function The function that the model called.
	Function struct {
		// Arguments The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
		Arguments string `json:"arguments"`

		// Name The name of the function to call.
		Name string `json:"name"`
	} `json:"function"`

	// Id The ID of the tool call.
	Id string `json:"id"`

	// Type The type of the tool. Currently, only `function` is supported.
	Type ChatCompletionMessageToolCallType `json:"type"`
}

// ChatCompletionMessageToolCallType The type of the tool. Currently, only `function` is supported.
type ChatCompletionMessageToolCallType string

// ChatCompletionMessageToolCalls The tool calls generated by the model, such as function calls.
type ChatCompletionMessageToolCalls = []ChatCompletionMessageToolCall

// ChatCompletionModalities Output types that you would like the model to generate for this request.
// Most models are capable of generating text, which is the default:
//
// `["text"]`
//
// The `gpt-4o-audio-preview` model can also be used to [generate audio](/docs/guides/audio). To
// request that this model generate both text and audio responses, you can
// use:
//
// `["text", "audio"]`
type ChatCompletionModalities = []string

// ChatCompletionNamedToolChoice Specifies a tool the model should use. Use to force the model to call a specific function.
type ChatCompletionNamedToolChoice struct {
	Function struct {
		// Name The name of the function to call.
		Name string `json:"name"`
	} `json:"function"`

	// Type The type of the tool. Currently, only `function` is supported.
	Type ChatCompletionNamedToolChoiceType `json:"type"`
}

// ChatCompletionNamedToolChoiceType The type of the tool. Currently, only `function` is supported.
type ChatCompletionNamedToolChoiceType string

// ChatCompletionRequestAssistantMessage defines model for ChatCompletionRequestAssistantMessage.
type ChatCompletionRequestAssistantMessage struct {
	// Audio Data about a previous audio response from the model.
	// [Learn more](/docs/guides/audio).
	Audio *struct {
		// Id Unique identifier for a previous audio response from the model.
		Id string `json:"id"`
	} `json:"audio"`

	// Content The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
	Content *ChatCompletionRequestAssistantMessage_Content `json:"content"`

	// FunctionCall Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model.
	// Deprecated:
	FunctionCall *struct {
		// Arguments The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
		Arguments string `json:"arguments"`

		// Name The name of the function to call.
		Name string `json:"name"`
	} `json:"function_call"`

	// Name An optional name for the participant. Provides the model information to differentiate between participants of the same role.
	Name *string `json:"name,omitempty"`

	// Refusal The refusal message by the assistant.
	Refusal *string `json:"refusal"`

	// Role The role of the messages author, in this case `assistant`.
	Role ChatCompletionRequestAssistantMessageRole `json:"role"`

	// ToolCalls The tool calls generated by the model, such as function calls.
	ToolCalls *ChatCompletionMessageToolCalls `json:"tool_calls,omitempty"`
}

// ChatCompletionRequestAssistantMessageContent0 The contents of the assistant message.
type ChatCompletionRequestAssistantMessageContent0 = string

// ChatCompletionRequestAssistantMessageContent1 An array of content parts with a defined type. Can be one or more of type `text`, or exactly one of type `refusal`.
type ChatCompletionRequestAssistantMessageContent1 = []ChatCompletionRequestAssistantMessageContentPart

// ChatCompletionRequestAssistantMessage_Content The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
type ChatCompletionRequestAssistantMessage_Content struct {
	union json.RawMessage
}

// ChatCompletionRequestAssistantMessageRole The role of the messages author, in this case `assistant`.
type ChatCompletionRequestAssistantMessageRole string

// ChatCompletionRequestAssistantMessageContentPart defines model for ChatCompletionRequestAssistantMessageContentPart.
type ChatCompletionRequestAssistantMessageContentPart struct {
	union json.RawMessage
}

// ChatCompletionRequestFunctionMessage defines model for ChatCompletionRequestFunctionMessage.
type ChatCompletionRequestFunctionMessage struct {
	// Content The contents of the function message.
	Content *string `json:"content"`

	// Name The name of the function to call.
	Name string `json:"name"`

	// Role The role of the messages author, in this case `function`.
	Role ChatCompletionRequestFunctionMessageRole `json:"role"`
}

// ChatCompletionRequestFunctionMessageRole The role of the messages author, in this case `function`.
type ChatCompletionRequestFunctionMessageRole string

// ChatCompletionRequestMessage defines model for ChatCompletionRequestMessage.
type ChatCompletionRequestMessage struct {
	union json.RawMessage
}

// ChatCompletionRequestMessageContentPartAudio Learn about [audio inputs](/docs/guides/audio).
type ChatCompletionRequestMessageContentPartAudio struct {
	InputAudio struct {
		// Data Base64 encoded audio data.
		Data string `json:"data"`

		// Format The format of the encoded audio data. Currently supports "wav" and "mp3".
		Format ChatCompletionRequestMessageContentPartAudioInputAudioFormat `json:"format"`
	} `json:"input_audio"`

	// Type The type of the content part. Always `input_audio`.
	Type ChatCompletionRequestMessageContentPartAudioType `json:"type"`
}

// ChatCompletionRequestMessageContentPartAudioInputAudioFormat The format of the encoded audio data. Currently supports "wav" and "mp3".
type ChatCompletionRequestMessageContentPartAudioInputAudioFormat string

// ChatCompletionRequestMessageContentPartAudioType The type of the content part. Always `input_audio`.
type ChatCompletionRequestMessageContentPartAudioType string

// ChatCompletionRequestMessageContentPartImage Learn about [image inputs](/docs/guides/vision).
type ChatCompletionRequestMessageContentPartImage struct {
	ImageUrl struct {
		// Detail Specifies the detail level of the image. Learn more in the [Vision guide](/docs/guides/vision#low-or-high-fidelity-image-understanding).
		Detail *ChatCompletionRequestMessageContentPartImageImageUrlDetail `json:"detail,omitempty"`

		// Url Either a URL of the image or the base64 encoded image data.
		Url string `json:"url"`
	} `json:"image_url"`

	// Type The type of the content part.
	Type ChatCompletionRequestMessageContentPartImageType `json:"type"`
}

// ChatCompletionRequestMessageContentPartImageImageUrlDetail Specifies the detail level of the image. Learn more in the [Vision guide](/docs/guides/vision#low-or-high-fidelity-image-understanding).
type ChatCompletionRequestMessageContentPartImageImageUrlDetail string

// ChatCompletionRequestMessageContentPartImageType The type of the content part.
type ChatCompletionRequestMessageContentPartImageType string

// ChatCompletionRequestMessageContentPartRefusal defines model for ChatCompletionRequestMessageContentPartRefusal.
type ChatCompletionRequestMessageContentPartRefusal struct {
	// Refusal The refusal message generated by the model.
	Refusal string `json:"refusal"`

	// Type The type of the content part.
	Type ChatCompletionRequestMessageContentPartRefusalType `json:"type"`
}

// ChatCompletionRequestMessageContentPartRefusalType The type of the content part.
type ChatCompletionRequestMessageContentPartRefusalType string

// ChatCompletionRequestMessageContentPartText Learn about [text inputs](/docs/guides/text-generation).
type ChatCompletionRequestMessageContentPartText struct {
	// Text The text content.
	Text string `json:"text"`

	// Type The type of the content part.
	Type ChatCompletionRequestMessageContentPartTextType `json:"type"`
}

// ChatCompletionRequestMessageContentPartTextType The type of the content part.
type ChatCompletionRequestMessageContentPartTextType string

// ChatCompletionRequestSystemMessage defines model for ChatCompletionRequestSystemMessage.
type ChatCompletionRequestSystemMessage struct {
	// Content The contents of the system message.
	Content ChatCompletionRequestSystemMessage_Content `json:"content"`

	// Name An optional name for the participant. Provides the model information to differentiate between participants of the same role.
	Name *string `json:"name,omitempty"`

	// Role The role of the messages author, in this case `system`.
	Role ChatCompletionRequestSystemMessageRole `json:"role"`
}

// ChatCompletionRequestSystemMessageContent0 The contents of the system message.
type ChatCompletionRequestSystemMessageContent0 = string

// ChatCompletionRequestSystemMessageContent1 An array of content parts with a defined type. For system messages, only type `text` is supported.
type ChatCompletionRequestSystemMessageContent1 = []ChatCompletionRequestSystemMessageContentPart

// ChatCompletionRequestSystemMessage_Content The contents of the system message.
type ChatCompletionRequestSystemMessage_Content struct {
	union json.RawMessage
}

// ChatCompletionRequestSystemMessageRole The role of the messages author, in this case `system`.
type ChatCompletionRequestSystemMessageRole string

// ChatCompletionRequestSystemMessageContentPart defines model for ChatCompletionRequestSystemMessageContentPart.
type ChatCompletionRequestSystemMessageContentPart struct {
	union json.RawMessage
}

// ChatCompletionRequestToolMessage defines model for ChatCompletionRequestToolMessage.
type ChatCompletionRequestToolMessage struct {
	// Content The contents of the tool message.
	Content ChatCompletionRequestToolMessage_Content `json:"content"`

	// Role The role of the messages author, in this case `tool`.
	Role ChatCompletionRequestToolMessageRole `json:"role"`

	// ToolCallId Tool call that this message is responding to.
	ToolCallId string `json:"tool_call_id"`
}

// ChatCompletionRequestToolMessageContent0 The contents of the tool message.
type ChatCompletionRequestToolMessageContent0 = string

// ChatCompletionRequestToolMessageContent1 An array of content parts with a defined type. For tool messages, only type `text` is supported.
type ChatCompletionRequestToolMessageContent1 = []ChatCompletionRequestToolMessageContentPart

// ChatCompletionRequestToolMessage_Content The contents of the tool message.
type ChatCompletionRequestToolMessage_Content struct {
	union json.RawMessage
}

// ChatCompletionRequestToolMessageRole The role of the messages author, in this case `tool`.
type ChatCompletionRequestToolMessageRole string

// ChatCompletionRequestToolMessageContentPart defines model for ChatCompletionRequestToolMessageContentPart.
type ChatCompletionRequestToolMessageContentPart struct {
	union json.RawMessage
}

// ChatCompletionRequestUserMessage defines model for ChatCompletionRequestUserMessage.
type ChatCompletionRequestUserMessage struct {
	// Content The contents of the user message.
	Content ChatCompletionRequestUserMessage_Content `json:"content"`

	// Name An optional name for the participant. Provides the model information to differentiate between participants of the same role.
	Name *string `json:"name,omitempty"`

	// Role The role of the messages author, in this case `user`.
	Role ChatCompletionRequestUserMessageRole `json:"role"`
}

// ChatCompletionRequestUserMessageContent0 The text contents of the message.
type ChatCompletionRequestUserMessageContent0 = string

// ChatCompletionRequestUserMessageContent1 An array of content parts with a defined type. Supported options differ based on the [model](/docs/models) being used to generate the response. Can contain text, image, or audio inputs.
type ChatCompletionRequestUserMessageContent1 = []ChatCompletionRequestUserMessageContentPart

// ChatCompletionRequestUserMessage_Content The contents of the user message.
type ChatCompletionRequestUserMessage_Content struct {
	union json.RawMessage
}

// ChatCompletionRequestUserMessageRole The role of the messages author, in this case `user`.
type ChatCompletionRequestUserMessageRole string

// ChatCompletionRequestUserMessageContentPart defines model for ChatCompletionRequestUserMessageContentPart.
type ChatCompletionRequestUserMessageContentPart struct {
	union json.RawMessage
}

// ChatCompletionResponseMessage A chat completion message generated by the model.
type ChatCompletionResponseMessage struct {
	// Audio If the audio output modality is requested, this object contains data
	// about the audio response from the model. [Learn more](/docs/guides/audio).
	Audio *struct {
		// Data Base64 encoded audio bytes generated by the model, in the format
		// specified in the request.
		Data string `json:"data"`

		// ExpiresAt The Unix timestamp (in seconds) for when this audio response will
		// no longer be accessible on the server for use in multi-turn
		// conversations.
		ExpiresAt int `json:"expires_at"`

		// Id Unique identifier for this audio response.
		Id string `json:"id"`

		// Transcript Transcript of the audio generated by the model.
		Transcript string `json:"transcript"`
	} `json:"audio"`

	// Content The contents of the message.
	Content *string `json:"content"`

	// FunctionCall Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model.
	// Deprecated:
	FunctionCall *struct {
		// Arguments The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
		Arguments string `json:"arguments"`

		// Name The name of the function to call.
		Name string `json:"name"`
	} `json:"function_call,omitempty"`

	// Refusal The refusal message generated by the model.
	Refusal *string `json:"refusal"`

	// Role The role of the author of this message.
	Role ChatCompletionResponseMessageRole `json:"role"`

	// ToolCalls The tool calls generated by the model, such as function calls.
	ToolCalls *ChatCompletionMessageToolCalls `json:"tool_calls,omitempty"`
}

// ChatCompletionResponseMessageRole The role of the author of this message.
type ChatCompletionResponseMessageRole string

// ChatCompletionStreamOptions Options for streaming response. Only set this when you set `stream: true`.
type ChatCompletionStreamOptions struct {
	// IncludeUsage If set, an additional chunk will be streamed before the `data: [DONE]` message. The `usage` field on this chunk shows the token usage statistics for the entire request, and the `choices` field will always be an empty array. All other chunks will also include a `usage` field, but with a null value.
	IncludeUsage *bool `json:"include_usage,omitempty"`
}

// ChatCompletionTokenLogprob defines model for ChatCompletionTokenLogprob.
type ChatCompletionTokenLogprob struct {
	// Bytes A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
	Bytes *[]int `json:"bytes"`

	// Logprob The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely.
	Logprob float32 `json:"logprob"`

	// Token The token.
	Token string `json:"token"`

	// TopLogprobs List of the most likely tokens and their log probability, at this token position. In rare cases, there may be fewer than the number of requested `top_logprobs` returned.
	TopLogprobs []struct {
		// Bytes A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
		Bytes *[]int `json:"bytes"`

		// Logprob The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely.
		Logprob float32 `json:"logprob"`

		// Token The token.
		Token string `json:"token"`
	} `json:"top_logprobs"`
}

// ChatCompletionTool defines model for ChatCompletionTool.
type ChatCompletionTool struct {
	Function FunctionObject `json:"function"`

	// Type The type of the tool. Currently, only `function` is supported.
	Type ChatCompletionToolType `json:"type"`
}

// ChatCompletionToolType The type of the tool. Currently, only `function` is supported.
type ChatCompletionToolType string

// ChatCompletionToolChoiceOption Controls which (if any) tool is called by the model.
// `none` means the model will not call any tool and instead generates a message.
// `auto` means the model can pick between generating a message or calling one or more tools.
// `required` means the model must call one or more tools.
// Specifying a particular tool via `{"type": "function", "function": {"name": "my_function"}}` forces the model to call that tool.
//
// `none` is the default when no tools are present. `auto` is the default if tools are present.
type ChatCompletionToolChoiceOption struct {
	union json.RawMessage
}

// ChatCompletionToolChoiceOption0 `none` means the model will not call any tool and instead generates a message. `auto` means the model can pick between generating a message or calling one or more tools. `required` means the model must call one or more tools.
type ChatCompletionToolChoiceOption0 string

// ChunkingStrategyRequestParam The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy.
type ChunkingStrategyRequestParam struct {
	union json.RawMessage
}

// CompleteUploadRequest defines model for CompleteUploadRequest.
type CompleteUploadRequest struct {
	// Md5 The optional md5 checksum for the file contents to verify if the bytes uploaded matches what you expect.
	Md5 *string `json:"md5,omitempty"`

	// PartIds The ordered list of Part IDs.
	PartIds []string `json:"part_ids"`
}

// CompletionUsage Usage statistics for the completion request.
type CompletionUsage struct {
	// CompletionTokens Number of tokens in the generated completion.
	CompletionTokens int `json:"completion_tokens"`

	// CompletionTokensDetails Breakdown of tokens used in a completion.
	CompletionTokensDetails *struct {
		// AcceptedPredictionTokens When using Predicted Outputs, the number of tokens in the
		// prediction that appeared in the completion.
		AcceptedPredictionTokens *int `json:"accepted_prediction_tokens,omitempty"`

		// AudioTokens Audio input tokens generated by the model.
		AudioTokens *int `json:"audio_tokens,omitempty"`

		// ReasoningTokens Tokens generated by the model for reasoning.
		ReasoningTokens *int `json:"reasoning_tokens,omitempty"`

		// RejectedPredictionTokens When using Predicted Outputs, the number of tokens in the
		// prediction that did not appear in the completion. However, like
		// reasoning tokens, these tokens are still counted in the total
		// completion tokens for purposes of billing, output, and context window
		// limits.
		RejectedPredictionTokens *int `json:"rejected_prediction_tokens,omitempty"`
	} `json:"completion_tokens_details,omitempty"`

	// PromptTokens Number of tokens in the prompt.
	PromptTokens int `json:"prompt_tokens"`

	// PromptTokensDetails Breakdown of tokens used in the prompt.
	PromptTokensDetails *struct {
		// AudioTokens Audio input tokens present in the prompt.
		AudioTokens *int `json:"audio_tokens,omitempty"`

		// CachedTokens Cached tokens present in the prompt.
		CachedTokens *int `json:"cached_tokens,omitempty"`
	} `json:"prompt_tokens_details,omitempty"`

	// TotalTokens Total number of tokens used in the request (prompt + completion).
	TotalTokens int `json:"total_tokens"`
}

// CreateAssistantRequest defines model for CreateAssistantRequest.
type CreateAssistantRequest struct {
	// Description The description of the assistant. The maximum length is 512 characters.
	Description *string `json:"description"`

	// Instructions The system instructions that the assistant uses. The maximum length is 256,000 characters.
	Instructions *string `json:"instructions"`

	// Metadata Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
	Metadata *map[string]interface{} `json:"metadata"`

	// Model ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them.
	Model CreateAssistantRequest_Model `json:"model"`

	// Name The name of the assistant. The maximum length is 256 characters.
	Name *string `json:"name"`

	// ResponseFormat Specifies the format that the model must output. Compatible with [GPT-4o](/docs/models#gpt-4o), [GPT-4 Turbo](/docs/models#gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.
	//
	// Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema. Learn more in the [Structured Outputs guide](/docs/guides/structured-outputs).
	//
	// Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates is valid JSON.
	//
	// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
	ResponseFormat *AssistantsApiResponseFormatOption `json:"response_format,omitempty"`

	// Temperature What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
	Temperature *float32 `json:"temperature"`

	// ToolResources A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
	ToolResources *struct {
		CodeInterpreter *struct {
			// FileIds A list of [file](/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.
			FileIds *[]string `json:"file_ids,omitempty"`
		} `json:"code_interpreter,omitempty"`
		FileSearch *CreateAssistantRequest_ToolResources_FileSearch `json:"file_search,omitempty"`
	} `json:"tool_resources"`

	// Tools A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`.
	Tools *[]CreateAssistantRequest_Tools_Item `json:"tools,omitempty"`

	// TopP An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
	//
	// We generally recommend altering this or temperature but not both.
	TopP *float32 `json:"top_p"`
}

// CreateAssistantRequestModel0 defines model for .
type CreateAssistantRequestModel0 = string

// CreateAssistantRequestModel1 defines model for CreateAssistantRequest.Model.1.
type CreateAssistantRequestModel1 string

// CreateAssistantRequest_Model ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them.
type CreateAssistantRequest_Model struct {
	union json.RawMessage
}

// CreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy0 The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`.
type CreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy0 struct {
	// Type Always `auto`.
	Type CreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy0Type `json:"type"`
}

// CreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy0Type Always `auto`.
type CreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy0Type string

// CreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy1 defines model for .
type CreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy1 struct {
	Static struct {
		// ChunkOverlapTokens The number of tokens that overlap between chunks. The default value is `400`.
		//
		// Note that the overlap must not exceed half of `max_chunk_size_tokens`.
		ChunkOverlapTokens int `json:"chunk_overlap_tokens"`

		// MaxChunkSizeTokens The maximum number of tokens in each chunk. The default value is `800`. The minimum value is `100` and the maximum value is `4096`.
		MaxChunkSizeTokens int `json:"max_chunk_size_tokens"`
	} `json:"static"`

	// Type Always `static`.
	Type CreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy1Type `json:"type"`
}

// CreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy1Type Always `static`.
type CreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy1Type string

// CreateAssistantRequest_ToolResources_FileSearch_VectorStores_ChunkingStrategy The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy.
type CreateAssistantRequest_ToolResources_FileSearch_VectorStores_ChunkingStrategy struct {
	union json.RawMessage
}

// CreateAssistantRequestToolResourcesFileSearch0 defines model for .
type CreateAssistantRequestToolResourcesFileSearch0 = interface{}

// CreateAssistantRequestToolResourcesFileSearch1 defines model for .
type CreateAssistantRequestToolResourcesFileSearch1 = interface{}

// CreateAssistantRequest_ToolResources_FileSearch defines model for CreateAssistantRequest.ToolResources.FileSearch.
type CreateAssistantRequest_ToolResources_FileSearch struct {
	// VectorStoreIds The [vector store](/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant.
	VectorStoreIds *[]string `json:"vector_store_ids,omitempty"`

	// VectorStores A helper to create a [vector store](/docs/api-reference/vector-stores/object) with file_ids and attach it to this assistant. There can be a maximum of 1 vector store attached to the assistant.
	VectorStores *[]struct {
		// ChunkingStrategy The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy.
		ChunkingStrategy *CreateAssistantRequest_ToolResources_FileSearch_VectorStores_ChunkingStrategy `json:"chunking_strategy,omitempty"`

		// FileIds A list of [file](/docs/api-reference/files) IDs to add to the vector store. There can be a maximum of 10000 files in a vector store.
		FileIds *[]string `json:"file_ids,omitempty"`

		// Metadata Set of 16 key-value pairs that can be attached to a vector store. This can be useful for storing additional information about the vector store in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
		Metadata *map[string]interface{} `json:"metadata,omitempty"`
	} `json:"vector_stores,omitempty"`
	union json.RawMessage
}

// CreateAssistantRequest_Tools_Item defines model for CreateAssistantRequest.tools.Item.
type CreateAssistantRequest_Tools_Item struct {
	union json.RawMessage
}

// CreateChatCompletionRequest defines model for CreateChatCompletionRequest.
type CreateChatCompletionRequest struct {
	// Audio Parameters for audio output. Required when audio output is requested with
	// `modalities: ["audio"]`. [Learn more](/docs/guides/audio).
	Audio *struct {
		// Format Specifies the output audio format. Must be one of `wav`, `mp3`, `flac`,
		// `opus`, or `pcm16`.
		Format CreateChatCompletionRequestAudioFormat `json:"format"`

		// Voice The voice the model uses to respond. Supported voices are `alloy`,
		// `ash`, `ballad`, `coral`, `echo`, `sage`, `shimmer`, and `verse`.
		Voice CreateChatCompletionRequestAudioVoice `json:"voice"`
	} `json:"audio"`

	// False How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep `n` as `1` to minimize costs.
	False *int `json:"false"`

	// FrequencyPenalty Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
	//
	// [See more information about frequency and presence penalties.](/docs/guides/text-generation)
	FrequencyPenalty *float32 `json:"frequency_penalty"`

	// FunctionCall Deprecated in favor of `tool_choice`.
	//
	// Controls which (if any) function is called by the model.
	// `none` means the model will not call a function and instead generates a message.
	// `auto` means the model can pick between generating a message or calling a function.
	// Specifying a particular function via `{"name": "my_function"}` forces the model to call that function.
	//
	// `none` is the default when no functions are present. `auto` is the default if functions are present.
	// Deprecated:
	FunctionCall *CreateChatCompletionRequest_FunctionCall `json:"function_call,omitempty"`

	// Functions Deprecated in favor of `tools`.
	//
	// A list of functions the model may generate JSON inputs for.
	// Deprecated:
	Functions *[]ChatCompletionFunctions `json:"functions,omitempty"`

	// LogitBias Modify the likelihood of specified tokens appearing in the completion.
	//
	// Accepts a JSON object that maps tokens (specified by their token ID in the tokenizer) to an associated bias value from -100 to 100. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
	LogitBias *map[string]int `json:"logit_bias"`

	// Logprobs Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the `content` of `message`.
	Logprobs *bool `json:"logprobs"`

	// MaxCompletionTokens An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and [reasoning tokens](/docs/guides/reasoning).
	MaxCompletionTokens *int `json:"max_completion_tokens"`

	// MaxTokens The maximum number of [tokens](/tokenizer) that can be generated in the chat completion. This value can be used to control [costs](https://openai.com/api/pricing/) for text generated via API.
	//
	// This value is now deprecated in favor of `max_completion_tokens`, and is not compatible with [o1 series models](/docs/guides/reasoning).
	// Deprecated:
	MaxTokens *int `json:"max_tokens"`

	// Messages A list of messages comprising the conversation so far. Depending on the
	// [model](/docs/models) you use, different message types (modalities) are
	// supported, like [text](/docs/guides/text-generation),
	// [images](/docs/guides/vision), and [audio](/docs/guides/audio).
	Messages []ChatCompletionRequestMessage `json:"messages"`

	// Metadata Developer-defined tags and values used for filtering completions
	// in the [dashboard](https://platform.openai.com/chat-completions).
	Metadata *map[string]string `json:"metadata"`

	// Modalities Output types that you would like the model to generate for this request.
	// Most models are capable of generating text, which is the default:
	//
	// `["text"]`
	//
	// The `gpt-4o-audio-preview` model can also be used to [generate audio](/docs/guides/audio). To
	// request that this model generate both text and audio responses, you can
	// use:
	//
	// `["text", "audio"]`
	Modalities *ChatCompletionModalities `json:"modalities"`

	// Model ID of the model to use. See the [model endpoint compatibility](/docs/models#model-endpoint-compatibility) table for details on which models work with the Chat API.
	Model CreateChatCompletionRequest_Model `json:"model"`

	// ParallelToolCalls Whether to enable [parallel function calling](/docs/guides/function-calling#configuring-parallel-function-calling) during tool use.
	ParallelToolCalls *ParallelToolCalls `json:"parallel_tool_calls,omitempty"`

	// Prediction Configuration for a [Predicted Output](/docs/guides/predicted-outputs),
	// which can greatly improve response times when large parts of the model
	// response are known ahead of time. This is most common when you are
	// regenerating a file with only minor changes to most of the content.
	Prediction *CreateChatCompletionRequest_Prediction `json:"prediction"`

	// PresencePenalty Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
	//
	// [See more information about frequency and presence penalties.](/docs/guides/text-generation)
	PresencePenalty *float32 `json:"presence_penalty"`

	// ResponseFormat An object specifying the format that the model must output. Compatible with [GPT-4o](/docs/models#gpt-4o), [GPT-4o mini](/docs/models#gpt-4o-mini), [GPT-4 Turbo](/docs/models#gpt-4-turbo-and-gpt-4) and all GPT-3.5 Turbo models newer than `gpt-3.5-turbo-1106`.
	//
	// Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema. Learn more in the [Structured Outputs guide](/docs/guides/structured-outputs).
	//
	// Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates is valid JSON.
	//
	// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
	ResponseFormat *CreateChatCompletionRequest_ResponseFormat `json:"response_format,omitempty"`

	// Seed This feature is in Beta.
	// If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.
	// Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend.
	Seed *int `json:"seed"`

	// ServiceTier Specifies the latency tier to use for processing the request. This parameter is relevant for customers subscribed to the scale tier service:
	//   - If set to 'auto', and the Project is Scale tier enabled, the system will utilize scale tier credits until they are exhausted.
	//   - If set to 'auto', and the Project is not Scale tier enabled, the request will be processed using the default service tier with a lower uptime SLA and no latency guarentee.
	//   - If set to 'default', the request will be processed using the default service tier with a lower uptime SLA and no latency guarentee.
	//   - When not set, the default behavior is 'auto'.
	//
	//   When this parameter is set, the response body will include the `service_tier` utilized.
	ServiceTier *CreateChatCompletionRequestServiceTier `json:"service_tier"`

	// Stop Up to 4 sequences where the API will stop generating further tokens.
	Stop *CreateChatCompletionRequest_Stop `json:"stop,omitempty"`

	// Store Whether or not to store the output of this chat completion request
	// for use in our [model distillation](/docs/guides/distillation) or [evals](/docs/guides/evals) products.
	Store *bool `json:"store"`

	// Stream If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).
	Stream *bool `json:"stream"`

	// StreamOptions Options for streaming response. Only set this when you set `stream: true`.
	StreamOptions *ChatCompletionStreamOptions `json:"stream_options"`

	// Temperature What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
	//
	// We generally recommend altering this or `top_p` but not both.
	Temperature *float32 `json:"temperature"`

	// ToolChoice Controls which (if any) tool is called by the model.
	// `none` means the model will not call any tool and instead generates a message.
	// `auto` means the model can pick between generating a message or calling one or more tools.
	// `required` means the model must call one or more tools.
	// Specifying a particular tool via `{"type": "function", "function": {"name": "my_function"}}` forces the model to call that tool.
	//
	// `none` is the default when no tools are present. `auto` is the default if tools are present.
	ToolChoice *ChatCompletionToolChoiceOption `json:"tool_choice,omitempty"`

	// Tools A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for. A max of 128 functions are supported.
	Tools *[]ChatCompletionTool `json:"tools,omitempty"`

	// TopLogprobs An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. `logprobs` must be set to `true` if this parameter is used.
	TopLogprobs *int `json:"top_logprobs"`

	// TopP An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
	//
	// We generally recommend altering this or `temperature` but not both.
	TopP *float32 `json:"top_p"`

	// User A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids).
	User *string `json:"user,omitempty"`
}

// CreateChatCompletionRequestAudioFormat Specifies the output audio format. Must be one of `wav`, `mp3`, `flac`,
// `opus`, or `pcm16`.
type CreateChatCompletionRequestAudioFormat string

// CreateChatCompletionRequestAudioVoice The voice the model uses to respond. Supported voices are `alloy`,
// `ash`, `ballad`, `coral`, `echo`, `sage`, `shimmer`, and `verse`.
type CreateChatCompletionRequestAudioVoice string

// CreateChatCompletionRequestFunctionCall0 `none` means the model will not call a function and instead generates a message. `auto` means the model can pick between generating a message or calling a function.
type CreateChatCompletionRequestFunctionCall0 string

// CreateChatCompletionRequest_FunctionCall Deprecated in favor of `tool_choice`.
//
// Controls which (if any) function is called by the model.
// `none` means the model will not call a function and instead generates a message.
// `auto` means the model can pick between generating a message or calling a function.
// Specifying a particular function via `{"name": "my_function"}` forces the model to call that function.
//
// `none` is the default when no functions are present. `auto` is the default if functions are present.
type CreateChatCompletionRequest_FunctionCall struct {
	union json.RawMessage
}

// CreateChatCompletionRequestModel0 defines model for .
type CreateChatCompletionRequestModel0 = string

// CreateChatCompletionRequestModel1 defines model for CreateChatCompletionRequest.Model.1.
type CreateChatCompletionRequestModel1 string

// CreateChatCompletionRequest_Model ID of the model to use. See the [model endpoint compatibility](/docs/models#model-endpoint-compatibility) table for details on which models work with the Chat API.
type CreateChatCompletionRequest_Model struct {
	union json.RawMessage
}

// CreateChatCompletionRequest_Prediction Configuration for a [Predicted Output](/docs/guides/predicted-outputs),
// which can greatly improve response times when large parts of the model
// response are known ahead of time. This is most common when you are
// regenerating a file with only minor changes to most of the content.
type CreateChatCompletionRequest_Prediction struct {
	union json.RawMessage
}

// CreateChatCompletionRequest_ResponseFormat An object specifying the format that the model must output. Compatible with [GPT-4o](/docs/models#gpt-4o), [GPT-4o mini](/docs/models#gpt-4o-mini), [GPT-4 Turbo](/docs/models#gpt-4-turbo-and-gpt-4) and all GPT-3.5 Turbo models newer than `gpt-3.5-turbo-1106`.
//
// Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema. Learn more in the [Structured Outputs guide](/docs/guides/structured-outputs).
//
// Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates is valid JSON.
//
// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
type CreateChatCompletionRequest_ResponseFormat struct {
	union json.RawMessage
}

// CreateChatCompletionRequestServiceTier Specifies the latency tier to use for processing the request. This parameter is relevant for customers subscribed to the scale tier service:
//
//   - If set to 'auto', and the Project is Scale tier enabled, the system will utilize scale tier credits until they are exhausted.
//
//   - If set to 'auto', and the Project is not Scale tier enabled, the request will be processed using the default service tier with a lower uptime SLA and no latency guarentee.
//
//   - If set to 'default', the request will be processed using the default service tier with a lower uptime SLA and no latency guarentee.
//
//   - When not set, the default behavior is 'auto'.
//
//     When this parameter is set, the response body will include the `service_tier` utilized.
type CreateChatCompletionRequestServiceTier string

// CreateChatCompletionRequestStop0 defines model for .
type CreateChatCompletionRequestStop0 = string

// CreateChatCompletionRequestStop1 defines model for .
type CreateChatCompletionRequestStop1 = []string

// CreateChatCompletionRequest_Stop Up to 4 sequences where the API will stop generating further tokens.
type CreateChatCompletionRequest_Stop struct {
	union json.RawMessage
}

// CreateChatCompletionResponse Represents a chat completion response returned by model, based on the provided input.
type CreateChatCompletionResponse struct {
	// Choices A list of chat completion choices. Can be more than one if `n` is greater than 1.
	Choices []struct {
		// FinishReason The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
		// `length` if the maximum number of tokens specified in the request was reached,
		// `content_filter` if content was omitted due to a flag from our content filters,
		// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
		FinishReason CreateChatCompletionResponseChoicesFinishReason `json:"finish_reason"`

		// Index The index of the choice in the list of choices.
		Index int `json:"index"`

		// Logprobs Log probability information for the choice.
		Logprobs *struct {
			// Content A list of message content tokens with log probability information.
			Content *[]ChatCompletionTokenLogprob `json:"content"`

			// Refusal A list of message refusal tokens with log probability information.
			Refusal *[]ChatCompletionTokenLogprob `json:"refusal"`
		} `json:"logprobs"`

		// Message A chat completion message generated by the model.
		Message ChatCompletionResponseMessage `json:"message"`
	} `json:"choices"`

	// Created The Unix timestamp (in seconds) of when the chat completion was created.
	Created int `json:"created"`

	// Id A unique identifier for the chat completion.
	Id string `json:"id"`

	// Model The model used for the chat completion.
	Model string `json:"model"`

	// Object The object type, which is always `chat.completion`.
	Object CreateChatCompletionResponseObject `json:"object"`

	// ServiceTier The service tier used for processing the request. This field is only included if the `service_tier` parameter is specified in the request.
	ServiceTier *CreateChatCompletionResponseServiceTier `json:"service_tier"`

	// SystemFingerprint This fingerprint represents the backend configuration that the model runs with.
	//
	// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.
	SystemFingerprint *string `json:"system_fingerprint,omitempty"`

	// Usage Usage statistics for the completion request.
	Usage *CompletionUsage `json:"usage,omitempty"`
}

// CreateChatCompletionResponseChoicesFinishReason The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
// `length` if the maximum number of tokens specified in the request was reached,
// `content_filter` if content was omitted due to a flag from our content filters,
// `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
type CreateChatCompletionResponseChoicesFinishReason string

// CreateChatCompletionResponseObject The object type, which is always `chat.completion`.
type CreateChatCompletionResponseObject string

// CreateChatCompletionResponseServiceTier The service tier used for processing the request. This field is only included if the `service_tier` parameter is specified in the request.
type CreateChatCompletionResponseServiceTier string

// CreateCompletionRequest defines model for CreateCompletionRequest.
type CreateCompletionRequest struct {
	// BestOf Generates `best_of` completions server-side and returns the "best" (the one with the highest log probability per token). Results cannot be streamed.
	//
	// When used with `n`, `best_of` controls the number of candidate completions and `n` specifies how many to return  `best_of` must be greater than `n`.
	//
	// **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.
	BestOf *int `json:"best_of"`

	// Echo Echo back the prompt in addition to the completion
	Echo *bool `json:"echo"`

	// False How many completions to generate for each prompt.
	//
	// **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.
	False *int `json:"false"`

	// FrequencyPenalty Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
	//
	// [See more information about frequency and presence penalties.](/docs/guides/text-generation)
	FrequencyPenalty *float32 `json:"frequency_penalty"`

	// LogitBias Modify the likelihood of specified tokens appearing in the completion.
	//
	// Accepts a JSON object that maps tokens (specified by their token ID in the GPT tokenizer) to an associated bias value from -100 to 100. You can use this [tokenizer tool](/tokenizer?view=bpe) to convert text to token IDs. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.
	//
	// As an example, you can pass `{"50256": -100}` to prevent the <|endoftext|> token from being generated.
	LogitBias *map[string]int `json:"logit_bias"`

	// Logprobs Include the log probabilities on the `logprobs` most likely output tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.
	//
	// The maximum value for `logprobs` is 5.
	Logprobs *int `json:"logprobs"`

	// MaxTokens The maximum number of [tokens](/tokenizer) that can be generated in the completion.
	//
	// The token count of your prompt plus `max_tokens` cannot exceed the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
	MaxTokens *int `json:"max_tokens"`

	// Model ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them.
	Model CreateCompletionRequest_Model `json:"model"`

	// PresencePenalty Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
	//
	// [See more information about frequency and presence penalties.](/docs/guides/text-generation)
	PresencePenalty *float32 `json:"presence_penalty"`

	// Prompt The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.
	//
	// Note that <|endoftext|> is the document separator that the model sees during training, so if a prompt is not specified the model will generate as if from the beginning of a new document.
	Prompt *CreateCompletionRequest_Prompt `json:"prompt"`

	// Seed If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.
	//
	// Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend.
	Seed *int `json:"seed"`

	// Stop Up to 4 sequences where the API will stop generating further tokens. The returned text will not contain the stop sequence.
	Stop *CreateCompletionRequest_Stop `json:"stop"`

	// Stream Whether to stream back partial progress. If set, tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).
	Stream *bool `json:"stream"`

	// StreamOptions Options for streaming response. Only set this when you set `stream: true`.
	StreamOptions *ChatCompletionStreamOptions `json:"stream_options"`

	// Suffix The suffix that comes after a completion of inserted text.
	//
	// This parameter is only supported for `gpt-3.5-turbo-instruct`.
	Suffix *string `json:"suffix"`

	// Temperature What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
	//
	// We generally recommend altering this or `top_p` but not both.
	Temperature *float32 `json:"temperature"`

	// TopP An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
	//
	// We generally recommend altering this or `temperature` but not both.
	TopP *float32 `json:"top_p"`

	// User A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids).
	User *string `json:"user,omitempty"`
}

// CreateCompletionRequestModel0 defines model for .
type CreateCompletionRequestModel0 = string

// CreateCompletionRequestModel1 defines model for CreateCompletionRequest.Model.1.
type CreateCompletionRequestModel1 string

// CreateCompletionRequest_Model ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them.
type CreateCompletionRequest_Model struct {
	union json.RawMessage
}

// CreateCompletionRequestPrompt0 defines model for .
type CreateCompletionRequestPrompt0 = string

// CreateCompletionRequestPrompt1 defines model for .
type CreateCompletionRequestPrompt1 = []string

// CreateCompletionRequestPrompt2 defines model for .
type CreateCompletionRequestPrompt2 = []int

// CreateCompletionRequestPrompt3 defines model for .
type CreateCompletionRequestPrompt3 = [][]int

// CreateCompletionRequest_Prompt The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.
//
// Note that <|endoftext|> is the document separator that the model sees during training, so if a prompt is not specified the model will generate as if from the beginning of a new document.
type CreateCompletionRequest_Prompt struct {
	union json.RawMessage
}

// CreateCompletionRequestStop0 defines model for .
type CreateCompletionRequestStop0 = string

// CreateCompletionRequestStop1 defines model for .
type CreateCompletionRequestStop1 = []string

// CreateCompletionRequest_Stop Up to 4 sequences where the API will stop generating further tokens. The returned text will not contain the stop sequence.
type CreateCompletionRequest_Stop struct {
	union json.RawMessage
}

// CreateCompletionResponse Represents a completion response from the API. Note: both the streamed and non-streamed response objects share the same shape (unlike the chat endpoint).
type CreateCompletionResponse struct {
	// Choices The list of completion choices the model generated for the input prompt.
	Choices []struct {
		// FinishReason The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
		// `length` if the maximum number of tokens specified in the request was reached,
		// or `content_filter` if content was omitted due to a flag from our content filters.
		FinishReason CreateCompletionResponseChoicesFinishReason `json:"finish_reason"`
		Index        int                                         `json:"index"`
		Logprobs     *struct {
			TextOffset    *[]int                `json:"text_offset,omitempty"`
			TokenLogprobs *[]float32            `json:"token_logprobs,omitempty"`
			Tokens        *[]string             `json:"tokens,omitempty"`
			TopLogprobs   *[]map[string]float32 `json:"top_logprobs,omitempty"`
		} `json:"logprobs"`
		Text string `json:"text"`
	} `json:"choices"`

	// Created The Unix timestamp (in seconds) of when the completion was created.
	Created int `json:"created"`

	// Id A unique identifier for the completion.
	Id string `json:"id"`

	// Model The model used for completion.
	Model string `json:"model"`

	// Object The object type, which is always "text_completion"
	Object CreateCompletionResponseObject `json:"object"`

	// SystemFingerprint This fingerprint represents the backend configuration that the model runs with.
	//
	// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.
	SystemFingerprint *string `json:"system_fingerprint,omitempty"`

	// Usage Usage statistics for the completion request.
	Usage *CompletionUsage `json:"usage,omitempty"`
}

// CreateCompletionResponseChoicesFinishReason The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
// `length` if the maximum number of tokens specified in the request was reached,
// or `content_filter` if content was omitted due to a flag from our content filters.
type CreateCompletionResponseChoicesFinishReason string

// CreateCompletionResponseObject The object type, which is always "text_completion"
type CreateCompletionResponseObject string

// CreateEmbeddingRequest defines model for CreateEmbeddingRequest.
type CreateEmbeddingRequest struct {
	// Dimensions The number of dimensions the resulting output embeddings should have. Only supported in `text-embedding-3` and later models.
	Dimensions *int `json:"dimensions,omitempty"`

	// EncodingFormat The format to return the embeddings in. Can be either `float` or [`base64`](https://pypi.org/project/pybase64/).
	EncodingFormat *CreateEmbeddingRequestEncodingFormat `json:"encoding_format,omitempty"`

	// Input Input text to embed, encoded as a string or array of tokens. To embed multiple inputs in a single request, pass an array of strings or array of token arrays. The input must not exceed the max input tokens for the model (8192 tokens for `text-embedding-ada-002`), cannot be an empty string, and any array must be 2048 dimensions or less. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
	Input CreateEmbeddingRequest_Input `json:"input"`

	// Model ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them.
	Model CreateEmbeddingRequest_Model `json:"model"`

	// User A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids).
	User *string `json:"user,omitempty"`
}

// CreateEmbeddingRequestEncodingFormat The format to return the embeddings in. Can be either `float` or [`base64`](https://pypi.org/project/pybase64/).
type CreateEmbeddingRequestEncodingFormat string

// CreateEmbeddingRequestInput0 The string that will be turned into an embedding.
type CreateEmbeddingRequestInput0 = string

// CreateEmbeddingRequestInput1 The array of strings that will be turned into an embedding.
type CreateEmbeddingRequestInput1 = []string

// CreateEmbeddingRequestInput2 The array of integers that will be turned into an embedding.
type CreateEmbeddingRequestInput2 = []int

// CreateEmbeddingRequestInput3 The array of arrays containing integers that will be turned into an embedding.
type CreateEmbeddingRequestInput3 = [][]int

// CreateEmbeddingRequest_Input Input text to embed, encoded as a string or array of tokens. To embed multiple inputs in a single request, pass an array of strings or array of token arrays. The input must not exceed the max input tokens for the model (8192 tokens for `text-embedding-ada-002`), cannot be an empty string, and any array must be 2048 dimensions or less. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.
type CreateEmbeddingRequest_Input struct {
	union json.RawMessage
}

// CreateEmbeddingRequestModel0 defines model for .
type CreateEmbeddingRequestModel0 = string

// CreateEmbeddingRequestModel1 defines model for CreateEmbeddingRequest.Model.1.
type CreateEmbeddingRequestModel1 string

// CreateEmbeddingRequest_Model ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them.
type CreateEmbeddingRequest_Model struct {
	union json.RawMessage
}

// CreateEmbeddingResponse defines model for CreateEmbeddingResponse.
type CreateEmbeddingResponse struct {
	// Data The list of embeddings generated by the model.
	Data []Embedding `json:"data"`

	// Model The name of the model used to generate the embedding.
	Model string `json:"model"`

	// Object The object type, which is always "list".
	Object CreateEmbeddingResponseObject `json:"object"`

	// Usage The usage information for the request.
	Usage struct {
		// PromptTokens The number of tokens used by the prompt.
		PromptTokens int `json:"prompt_tokens"`

		// TotalTokens The total number of tokens used by the request.
		TotalTokens int `json:"total_tokens"`
	} `json:"usage"`
}

// CreateEmbeddingResponseObject The object type, which is always "list".
type CreateEmbeddingResponseObject string

// CreateFileRequest defines model for CreateFileRequest.
type CreateFileRequest struct {
	// File The File object (not file name) to be uploaded.
	File openapi_types.File `json:"file"`

	// Purpose The intended purpose of the uploaded file.
	//
	// Use "assistants" for [Assistants](/docs/api-reference/assistants) and [Message](/docs/api-reference/messages) files, "vision" for Assistants image file inputs, "batch" for [Batch API](/docs/guides/batch), and "fine-tune" for [Fine-tuning](/docs/api-reference/fine-tuning).
	Purpose CreateFileRequestPurpose `json:"purpose"`
}

// CreateFileRequestPurpose The intended purpose of the uploaded file.
//
// Use "assistants" for [Assistants](/docs/api-reference/assistants) and [Message](/docs/api-reference/messages) files, "vision" for Assistants image file inputs, "batch" for [Batch API](/docs/guides/batch), and "fine-tune" for [Fine-tuning](/docs/api-reference/fine-tuning).
type CreateFileRequestPurpose string

// CreateFineTuningJobRequest defines model for CreateFineTuningJobRequest.
type CreateFineTuningJobRequest struct {
	// Hyperparameters The hyperparameters used for the fine-tuning job.
	Hyperparameters *struct {
		// BatchSize Number of examples in each batch. A larger batch size means that model parameters
		// are updated less frequently, but with lower variance.
		BatchSize *CreateFineTuningJobRequest_Hyperparameters_BatchSize `json:"batch_size,omitempty"`

		// LearningRateMultiplier Scaling factor for the learning rate. A smaller learning rate may be useful to avoid
		// overfitting.
		LearningRateMultiplier *CreateFineTuningJobRequest_Hyperparameters_LearningRateMultiplier `json:"learning_rate_multiplier,omitempty"`

		// NEpochs The number of epochs to train the model for. An epoch refers to one full cycle
		// through the training dataset.
		NEpochs *CreateFineTuningJobRequest_Hyperparameters_NEpochs `json:"n_epochs,omitempty"`
	} `json:"hyperparameters,omitempty"`

	// Integrations A list of integrations to enable for your fine-tuning job.
	Integrations *[]struct {
		// Type The type of integration to enable. Currently, only "wandb" (Weights and Biases) is supported.
		Type CreateFineTuningJobRequest_Integrations_Type `json:"type"`

		// Wandb The settings for your integration with Weights and Biases. This payload specifies the project that
		// metrics will be sent to. Optionally, you can set an explicit display name for your run, add tags
		// to your run, and set a default entity (team, username, etc) to be associated with your run.
		Wandb struct {
			// Entity The entity to use for the run. This allows you to set the team or username of the WandB user that you would
			// like associated with the run. If not set, the default entity for the registered WandB API key is used.
			Entity *string `json:"entity"`

			// Name A display name to set for the run. If not set, we will use the Job ID as the name.
			Name *string `json:"name"`

			// Project The name of the project that the new run will be created under.
			Project string `json:"project"`

			// Tags A list of tags to be attached to the newly created run. These tags are passed through directly to WandB. Some
			// default tags are generated by OpenAI: "openai/finetune", "openai/{base-model}", "openai/{ftjob-abcdef}".
			Tags *[]string `json:"tags,omitempty"`
		} `json:"wandb"`
	} `json:"integrations"`

	// Model The name of the model to fine-tune. You can select one of the
	// [supported models](/docs/guides/fine-tuning#which-models-can-be-fine-tuned).
	Model CreateFineTuningJobRequest_Model `json:"model"`

	// Seed The seed controls the reproducibility of the job. Passing in the same seed and job parameters should produce the same results, but may differ in rare cases.
	// If a seed is not specified, one will be generated for you.
	Seed *int `json:"seed"`

	// Suffix A string of up to 64 characters that will be added to your fine-tuned model name.
	//
	// For example, a `suffix` of "custom-model-name" would produce a model name like `ft:gpt-4o-mini:openai:custom-model-name:7p4lURel`.
	Suffix *string `json:"suffix"`

	// TrainingFile The ID of an uploaded file that contains training data.
	//
	// See [upload file](/docs/api-reference/files/create) for how to upload a file.
	//
	// Your dataset must be formatted as a JSONL file. Additionally, you must upload your file with the purpose `fine-tune`.
	//
	// The contents of the file should differ depending on if the model uses the [chat](/docs/api-reference/fine-tuning/chat-input) or [completions](/docs/api-reference/fine-tuning/completions-input) format.
	//
	// See the [fine-tuning guide](/docs/guides/fine-tuning) for more details.
	TrainingFile string `json:"training_file"`

	// ValidationFile The ID of an uploaded file that contains validation data.
	//
	// If you provide this file, the data is used to generate validation
	// metrics periodically during fine-tuning. These metrics can be viewed in
	// the fine-tuning results file.
	// The same data should not be present in both train and validation files.
	//
	// Your dataset must be formatted as a JSONL file. You must upload your file with the purpose `fine-tune`.
	//
	// See the [fine-tuning guide](/docs/guides/fine-tuning) for more details.
	ValidationFile *string `json:"validation_file"`
}

// CreateFineTuningJobRequestHyperparametersBatchSize0 defines model for CreateFineTuningJobRequest.Hyperparameters.BatchSize.0.
type CreateFineTuningJobRequestHyperparametersBatchSize0 string

// CreateFineTuningJobRequestHyperparametersBatchSize1 defines model for .
type CreateFineTuningJobRequestHyperparametersBatchSize1 = int

// CreateFineTuningJobRequest_Hyperparameters_BatchSize Number of examples in each batch. A larger batch size means that model parameters
// are updated less frequently, but with lower variance.
type CreateFineTuningJobRequest_Hyperparameters_BatchSize struct {
	union json.RawMessage
}

// CreateFineTuningJobRequestHyperparametersLearningRateMultiplier0 defines model for CreateFineTuningJobRequest.Hyperparameters.LearningRateMultiplier.0.
type CreateFineTuningJobRequestHyperparametersLearningRateMultiplier0 string

// CreateFineTuningJobRequestHyperparametersLearningRateMultiplier1 defines model for .
type CreateFineTuningJobRequestHyperparametersLearningRateMultiplier1 = float32

// CreateFineTuningJobRequest_Hyperparameters_LearningRateMultiplier Scaling factor for the learning rate. A smaller learning rate may be useful to avoid
// overfitting.
type CreateFineTuningJobRequest_Hyperparameters_LearningRateMultiplier struct {
	union json.RawMessage
}

// CreateFineTuningJobRequestHyperparametersNEpochs0 defines model for CreateFineTuningJobRequest.Hyperparameters.NEpochs.0.
type CreateFineTuningJobRequestHyperparametersNEpochs0 string

// CreateFineTuningJobRequestHyperparametersNEpochs1 defines model for .
type CreateFineTuningJobRequestHyperparametersNEpochs1 = int

// CreateFineTuningJobRequest_Hyperparameters_NEpochs The number of epochs to train the model for. An epoch refers to one full cycle
// through the training dataset.
type CreateFineTuningJobRequest_Hyperparameters_NEpochs struct {
	union json.RawMessage
}

// CreateFineTuningJobRequestIntegrationsType0 defines model for CreateFineTuningJobRequest.Integrations.Type.0.
type CreateFineTuningJobRequestIntegrationsType0 string

// CreateFineTuningJobRequest_Integrations_Type The type of integration to enable. Currently, only "wandb" (Weights and Biases) is supported.
type CreateFineTuningJobRequest_Integrations_Type struct {
	union json.RawMessage
}

// CreateFineTuningJobRequestModel0 defines model for .
type CreateFineTuningJobRequestModel0 = string

// CreateFineTuningJobRequestModel1 defines model for CreateFineTuningJobRequest.Model.1.
type CreateFineTuningJobRequestModel1 string

// CreateFineTuningJobRequest_Model The name of the model to fine-tune. You can select one of the
// [supported models](/docs/guides/fine-tuning#which-models-can-be-fine-tuned).
type CreateFineTuningJobRequest_Model struct {
	union json.RawMessage
}

// CreateImageEditRequest defines model for CreateImageEditRequest.
type CreateImageEditRequest struct {
	// False The number of images to generate. Must be between 1 and 10.
	False *int `json:"false"`

	// Image The image to edit. Must be a valid PNG file, less than 4MB, and square. If mask is not provided, image must have transparency, which will be used as the mask.
	Image openapi_types.File `json:"image"`

	// Mask An additional image whose fully transparent areas (e.g. where alpha is zero) indicate where `image` should be edited. Must be a valid PNG file, less than 4MB, and have the same dimensions as `image`.
	Mask *openapi_types.File `json:"mask,omitempty"`

	// Model The model to use for image generation. Only `dall-e-2` is supported at this time.
	Model *CreateImageEditRequest_Model `json:"model"`

	// Prompt A text description of the desired image(s). The maximum length is 1000 characters.
	Prompt string `json:"prompt"`

	// ResponseFormat The format in which the generated images are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated.
	ResponseFormat *CreateImageEditRequestResponseFormat `json:"response_format"`

	// Size The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024`.
	Size *CreateImageEditRequestSize `json:"size"`

	// User A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids).
	User *string `json:"user,omitempty"`
}

// CreateImageEditRequestModel0 defines model for .
type CreateImageEditRequestModel0 = string

// CreateImageEditRequestModel1 defines model for CreateImageEditRequest.Model.1.
type CreateImageEditRequestModel1 string

// CreateImageEditRequest_Model The model to use for image generation. Only `dall-e-2` is supported at this time.
type CreateImageEditRequest_Model struct {
	union json.RawMessage
}

// CreateImageEditRequestResponseFormat The format in which the generated images are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated.
type CreateImageEditRequestResponseFormat string

// CreateImageEditRequestSize The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024`.
type CreateImageEditRequestSize string

// CreateImageRequest defines model for CreateImageRequest.
type CreateImageRequest struct {
	// False The number of images to generate. Must be between 1 and 10. For `dall-e-3`, only `n=1` is supported.
	False *int `json:"false"`

	// Model The model to use for image generation.
	Model *CreateImageRequest_Model `json:"model"`

	// Prompt A text description of the desired image(s). The maximum length is 1000 characters for `dall-e-2` and 4000 characters for `dall-e-3`.
	Prompt string `json:"prompt"`

	// Quality The quality of the image that will be generated. `hd` creates images with finer details and greater consistency across the image. This param is only supported for `dall-e-3`.
	Quality *CreateImageRequestQuality `json:"quality,omitempty"`

	// ResponseFormat The format in which the generated images are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated.
	ResponseFormat *CreateImageRequestResponseFormat `json:"response_format"`

	// Size The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024` for `dall-e-2`. Must be one of `1024x1024`, `1792x1024`, or `1024x1792` for `dall-e-3` models.
	Size *CreateImageRequestSize `json:"size"`

	// Style The style of the generated images. Must be one of `vivid` or `natural`. Vivid causes the model to lean towards generating hyper-real and dramatic images. Natural causes the model to produce more natural, less hyper-real looking images. This param is only supported for `dall-e-3`.
	Style *CreateImageRequestStyle `json:"style"`

	// User A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids).
	User *string `json:"user,omitempty"`
}

// CreateImageRequestModel0 defines model for .
type CreateImageRequestModel0 = string

// CreateImageRequestModel1 defines model for CreateImageRequest.Model.1.
type CreateImageRequestModel1 string

// CreateImageRequest_Model The model to use for image generation.
type CreateImageRequest_Model struct {
	union json.RawMessage
}

// CreateImageRequestQuality The quality of the image that will be generated. `hd` creates images with finer details and greater consistency across the image. This param is only supported for `dall-e-3`.
type CreateImageRequestQuality string

// CreateImageRequestResponseFormat The format in which the generated images are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated.
type CreateImageRequestResponseFormat string

// CreateImageRequestSize The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024` for `dall-e-2`. Must be one of `1024x1024`, `1792x1024`, or `1024x1792` for `dall-e-3` models.
type CreateImageRequestSize string

// CreateImageRequestStyle The style of the generated images. Must be one of `vivid` or `natural`. Vivid causes the model to lean towards generating hyper-real and dramatic images. Natural causes the model to produce more natural, less hyper-real looking images. This param is only supported for `dall-e-3`.
type CreateImageRequestStyle string

// CreateImageVariationRequest defines model for CreateImageVariationRequest.
type CreateImageVariationRequest struct {
	// False The number of images to generate. Must be between 1 and 10. For `dall-e-3`, only `n=1` is supported.
	False *int `json:"false"`

	// Image The image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square.
	Image openapi_types.File `json:"image"`

	// Model The model to use for image generation. Only `dall-e-2` is supported at this time.
	Model *CreateImageVariationRequest_Model `json:"model"`

	// ResponseFormat The format in which the generated images are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated.
	ResponseFormat *CreateImageVariationRequestResponseFormat `json:"response_format"`

	// Size The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024`.
	Size *CreateImageVariationRequestSize `json:"size"`

	// User A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids).
	User *string `json:"user,omitempty"`
}

// CreateImageVariationRequestModel0 defines model for .
type CreateImageVariationRequestModel0 = string

// CreateImageVariationRequestModel1 defines model for CreateImageVariationRequest.Model.1.
type CreateImageVariationRequestModel1 string

// CreateImageVariationRequest_Model The model to use for image generation. Only `dall-e-2` is supported at this time.
type CreateImageVariationRequest_Model struct {
	union json.RawMessage
}

// CreateImageVariationRequestResponseFormat The format in which the generated images are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated.
type CreateImageVariationRequestResponseFormat string

// CreateImageVariationRequestSize The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024`.
type CreateImageVariationRequestSize string

// CreateMessageRequest defines model for CreateMessageRequest.
type CreateMessageRequest struct {
	// Attachments A list of files attached to the message, and the tools they should be added to.
	Attachments *[]struct {
		// FileId The ID of the file to attach to the message.
		FileId *string `json:"file_id,omitempty"`

		// Tools The tools to add this file to.
		Tools *[]CreateMessageRequest_Attachments_Tools_Item `json:"tools,omitempty"`
	} `json:"attachments"`
	Content CreateMessageRequest_Content `json:"content"`

	// Metadata Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
	Metadata *map[string]interface{} `json:"metadata"`

	// Role The role of the entity that is creating the message. Allowed values include:
	// - `user`: Indicates the message is sent by an actual user and should be used in most cases to represent user-generated messages.
	// - `assistant`: Indicates the message is generated by the assistant. Use this value to insert messages from the assistant into the conversation.
	Role CreateMessageRequestRole `json:"role"`
}

// CreateMessageRequest_Attachments_Tools_Item defines model for CreateMessageRequest.Attachments.Tools.Item.
type CreateMessageRequest_Attachments_Tools_Item struct {
	union json.RawMessage
}

// CreateMessageRequestContent0 The text contents of the message.
type CreateMessageRequestContent0 = string

// CreateMessageRequestContent1 An array of content parts with a defined type, each can be of type `text` or images can be passed with `image_url` or `image_file`. Image types are only supported on [Vision-compatible models](/docs/models).
type CreateMessageRequestContent1 = []CreateMessageRequest_Content_1_Item

// CreateMessageRequest_Content_1_Item defines model for CreateMessageRequest.Content.1.Item.
type CreateMessageRequest_Content_1_Item struct {
	union json.RawMessage
}

// CreateMessageRequest_Content defines model for CreateMessageRequest.Content.
type CreateMessageRequest_Content struct {
	union json.RawMessage
}

// CreateMessageRequestRole The role of the entity that is creating the message. Allowed values include:
// - `user`: Indicates the message is sent by an actual user and should be used in most cases to represent user-generated messages.
// - `assistant`: Indicates the message is generated by the assistant. Use this value to insert messages from the assistant into the conversation.
type CreateMessageRequestRole string

// CreateModerationRequest defines model for CreateModerationRequest.
type CreateModerationRequest struct {
	// Input Input (or inputs) to classify. Can be a single string, an array of strings, or
	// an array of multi-modal input objects similar to other models.
	Input CreateModerationRequest_Input `json:"input"`

	// Model The content moderation model you would like to use. Learn more in
	// [the moderation guide](/docs/guides/moderation), and learn about
	// available models [here](/docs/models#moderation).
	Model *CreateModerationRequest_Model `json:"model,omitempty"`
}

// CreateModerationRequestInput0 A string of text to classify for moderation.
type CreateModerationRequestInput0 = string

// CreateModerationRequestInput1 An array of strings to classify for moderation.
type CreateModerationRequestInput1 = []string

// CreateModerationRequestInput2 An array of multi-modal inputs to the moderation model.
type CreateModerationRequestInput2 = []CreateModerationRequest_Input_2_Item

// CreateModerationRequestInput20 An object describing an image to classify.
type CreateModerationRequestInput20 struct {
	// ImageUrl Contains either an image URL or a data URL for a base64 encoded image.
	ImageUrl struct {
		// Url Either a URL of the image or the base64 encoded image data.
		Url string `json:"url"`
	} `json:"image_url"`

	// Type Always `image_url`.
	Type CreateModerationRequestInput20Type `json:"type"`
}

// CreateModerationRequestInput20Type Always `image_url`.
type CreateModerationRequestInput20Type string

// CreateModerationRequestInput21 An object describing text to classify.
type CreateModerationRequestInput21 struct {
	// Text A string of text to classify.
	Text string `json:"text"`

	// Type Always `text`.
	Type CreateModerationRequestInput21Type `json:"type"`
}

// CreateModerationRequestInput21Type Always `text`.
type CreateModerationRequestInput21Type string

// CreateModerationRequest_Input_2_Item defines model for CreateModerationRequest.Input.2.Item.
type CreateModerationRequest_Input_2_Item struct {
	union json.RawMessage
}

// CreateModerationRequest_Input Input (or inputs) to classify. Can be a single string, an array of strings, or
// an array of multi-modal input objects similar to other models.
type CreateModerationRequest_Input struct {
	union json.RawMessage
}

// CreateModerationRequestModel0 defines model for .
type CreateModerationRequestModel0 = string

// CreateModerationRequestModel1 defines model for CreateModerationRequest.Model.1.
type CreateModerationRequestModel1 string

// CreateModerationRequest_Model The content moderation model you would like to use. Learn more in
// [the moderation guide](/docs/guides/moderation), and learn about
// available models [here](/docs/models#moderation).
type CreateModerationRequest_Model struct {
	union json.RawMessage
}

// CreateModerationResponse Represents if a given text input is potentially harmful.
type CreateModerationResponse struct {
	// Id The unique identifier for the moderation request.
	Id string `json:"id"`

	// Model The model used to generate the moderation results.
	Model string `json:"model"`

	// Results A list of moderation objects.
	Results []struct {
		// Categories A list of the categories, and whether they are flagged or not.
		Categories struct {
			// Harassment Content that expresses, incites, or promotes harassing language towards any target.
			Harassment bool `json:"harassment"`

			// Harassmentthreatening Harassment content that also includes violence or serious harm towards any target.
			Harassmentthreatening bool `json:"harassment/threatening"`

			// Hate Content that expresses, incites, or promotes hate based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste. Hateful content aimed at non-protected groups (e.g., chess players) is harassment.
			Hate bool `json:"hate"`

			// Hatethreatening Hateful content that also includes violence or serious harm towards the targeted group based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste.
			Hatethreatening bool `json:"hate/threatening"`

			// Illicit Content that includes instructions or advice that facilitate the planning or execution of wrongdoing, or that gives advice or instruction on how to commit illicit acts. For example, "how to shoplift" would fit this category.
			Illicit bool `json:"illicit"`

			// Illicitviolent Content that includes instructions or advice that facilitate the planning or execution of wrongdoing that also includes violence, or that gives advice or instruction on the procurement of any weapon.
			Illicitviolent bool `json:"illicit/violent"`

			// SelfHarm Content that promotes, encourages, or depicts acts of self-harm, such as suicide, cutting, and eating disorders.
			SelfHarm bool `json:"self-harm"`

			// SelfHarminstructions Content that encourages performing acts of self-harm, such as suicide, cutting, and eating disorders, or that gives instructions or advice on how to commit such acts.
			SelfHarminstructions bool `json:"self-harm/instructions"`

			// SelfHarmintent Content where the speaker expresses that they are engaging or intend to engage in acts of self-harm, such as suicide, cutting, and eating disorders.
			SelfHarmintent bool `json:"self-harm/intent"`

			// Sexual Content meant to arouse sexual excitement, such as the description of sexual activity, or that promotes sexual services (excluding sex education and wellness).
			Sexual bool `json:"sexual"`

			// Sexualminors Sexual content that includes an individual who is under 18 years old.
			Sexualminors bool `json:"sexual/minors"`

			// Violence Content that depicts death, violence, or physical injury.
			Violence bool `json:"violence"`

			// Violencegraphic Content that depicts death, violence, or physical injury in graphic detail.
			Violencegraphic bool `json:"violence/graphic"`
		} `json:"categories"`

		// CategoryAppliedInputTypes A list of the categories along with the input type(s) that the score applies to.
		CategoryAppliedInputTypes struct {
			// Harassment The applied input type(s) for the category 'harassment'.
			Harassment []CreateModerationResponseResultsCategoryAppliedInputTypesHarassment `json:"harassment"`

			// Harassmentthreatening The applied input type(s) for the category 'harassment/threatening'.
			Harassmentthreatening []CreateModerationResponseResultsCategoryAppliedInputTypesHarassmentthreatening `json:"harassment/threatening"`

			// Hate The applied input type(s) for the category 'hate'.
			Hate []CreateModerationResponseResultsCategoryAppliedInputTypesHate `json:"hate"`

			// Hatethreatening The applied input type(s) for the category 'hate/threatening'.
			Hatethreatening []CreateModerationResponseResultsCategoryAppliedInputTypesHatethreatening `json:"hate/threatening"`

			// Illicit The applied input type(s) for the category 'illicit'.
			Illicit []CreateModerationResponseResultsCategoryAppliedInputTypesIllicit `json:"illicit"`

			// Illicitviolent The applied input type(s) for the category 'illicit/violent'.
			Illicitviolent []CreateModerationResponseResultsCategoryAppliedInputTypesIllicitviolent `json:"illicit/violent"`

			// SelfHarm The applied input type(s) for the category 'self-harm'.
			SelfHarm []CreateModerationResponseResultsCategoryAppliedInputTypesSelfHarm `json:"self-harm"`

			// SelfHarminstructions The applied input type(s) for the category 'self-harm/instructions'.
			SelfHarminstructions []CreateModerationResponseResultsCategoryAppliedInputTypesSelfHarminstructions `json:"self-harm/instructions"`

			// SelfHarmintent The applied input type(s) for the category 'self-harm/intent'.
			SelfHarmintent []CreateModerationResponseResultsCategoryAppliedInputTypesSelfHarmintent `json:"self-harm/intent"`

			// Sexual The applied input type(s) for the category 'sexual'.
			Sexual []CreateModerationResponseResultsCategoryAppliedInputTypesSexual `json:"sexual"`

			// Sexualminors The applied input type(s) for the category 'sexual/minors'.
			Sexualminors []CreateModerationResponseResultsCategoryAppliedInputTypesSexualminors `json:"sexual/minors"`

			// Violence The applied input type(s) for the category 'violence'.
			Violence []CreateModerationResponseResultsCategoryAppliedInputTypesViolence `json:"violence"`

			// Violencegraphic The applied input type(s) for the category 'violence/graphic'.
			Violencegraphic []CreateModerationResponseResultsCategoryAppliedInputTypesViolencegraphic `json:"violence/graphic"`
		} `json:"category_applied_input_types"`

		// CategoryScores A list of the categories along with their scores as predicted by model.
		CategoryScores struct {
			// Harassment The score for the category 'harassment'.
			Harassment float32 `json:"harassment"`

			// Harassmentthreatening The score for the category 'harassment/threatening'.
			Harassmentthreatening float32 `json:"harassment/threatening"`

			// Hate The score for the category 'hate'.
			Hate float32 `json:"hate"`

			// Hatethreatening The score for the category 'hate/threatening'.
			Hatethreatening float32 `json:"hate/threatening"`

			// Illicit The score for the category 'illicit'.
			Illicit float32 `json:"illicit"`

			// Illicitviolent The score for the category 'illicit/violent'.
			Illicitviolent float32 `json:"illicit/violent"`

			// SelfHarm The score for the category 'self-harm'.
			SelfHarm float32 `json:"self-harm"`

			// SelfHarminstructions The score for the category 'self-harm/instructions'.
			SelfHarminstructions float32 `json:"self-harm/instructions"`

			// SelfHarmintent The score for the category 'self-harm/intent'.
			SelfHarmintent float32 `json:"self-harm/intent"`

			// Sexual The score for the category 'sexual'.
			Sexual float32 `json:"sexual"`

			// Sexualminors The score for the category 'sexual/minors'.
			Sexualminors float32 `json:"sexual/minors"`

			// Violence The score for the category 'violence'.
			Violence float32 `json:"violence"`

			// Violencegraphic The score for the category 'violence/graphic'.
			Violencegraphic float32 `json:"violence/graphic"`
		} `json:"category_scores"`

		// Flagged Whether any of the below categories are flagged.
		Flagged bool `json:"flagged"`
	} `json:"results"`
}

// CreateModerationResponseResultsCategoryAppliedInputTypesHarassment defines model for CreateModerationResponse.Results.CategoryAppliedInputTypes.Harassment.
type CreateModerationResponseResultsCategoryAppliedInputTypesHarassment string

// CreateModerationResponseResultsCategoryAppliedInputTypesHarassmentthreatening defines model for CreateModerationResponse.Results.CategoryAppliedInputTypes.Harassmentthreatening.
type CreateModerationResponseResultsCategoryAppliedInputTypesHarassmentthreatening string

// CreateModerationResponseResultsCategoryAppliedInputTypesHate defines model for CreateModerationResponse.Results.CategoryAppliedInputTypes.Hate.
type CreateModerationResponseResultsCategoryAppliedInputTypesHate string

// CreateModerationResponseResultsCategoryAppliedInputTypesHatethreatening defines model for CreateModerationResponse.Results.CategoryAppliedInputTypes.Hatethreatening.
type CreateModerationResponseResultsCategoryAppliedInputTypesHatethreatening string

// CreateModerationResponseResultsCategoryAppliedInputTypesIllicit defines model for CreateModerationResponse.Results.CategoryAppliedInputTypes.Illicit.
type CreateModerationResponseResultsCategoryAppliedInputTypesIllicit string

// CreateModerationResponseResultsCategoryAppliedInputTypesIllicitviolent defines model for CreateModerationResponse.Results.CategoryAppliedInputTypes.Illicitviolent.
type CreateModerationResponseResultsCategoryAppliedInputTypesIllicitviolent string

// CreateModerationResponseResultsCategoryAppliedInputTypesSelfHarm defines model for CreateModerationResponse.Results.CategoryAppliedInputTypes.SelfHarm.
type CreateModerationResponseResultsCategoryAppliedInputTypesSelfHarm string

// CreateModerationResponseResultsCategoryAppliedInputTypesSelfHarminstructions defines model for CreateModerationResponse.Results.CategoryAppliedInputTypes.SelfHarminstructions.
type CreateModerationResponseResultsCategoryAppliedInputTypesSelfHarminstructions string

// CreateModerationResponseResultsCategoryAppliedInputTypesSelfHarmintent defines model for CreateModerationResponse.Results.CategoryAppliedInputTypes.SelfHarmintent.
type CreateModerationResponseResultsCategoryAppliedInputTypesSelfHarmintent string

// CreateModerationResponseResultsCategoryAppliedInputTypesSexual defines model for CreateModerationResponse.Results.CategoryAppliedInputTypes.Sexual.
type CreateModerationResponseResultsCategoryAppliedInputTypesSexual string

// CreateModerationResponseResultsCategoryAppliedInputTypesSexualminors defines model for CreateModerationResponse.Results.CategoryAppliedInputTypes.Sexualminors.
type CreateModerationResponseResultsCategoryAppliedInputTypesSexualminors string

// CreateModerationResponseResultsCategoryAppliedInputTypesViolence defines model for CreateModerationResponse.Results.CategoryAppliedInputTypes.Violence.
type CreateModerationResponseResultsCategoryAppliedInputTypesViolence string

// CreateModerationResponseResultsCategoryAppliedInputTypesViolencegraphic defines model for CreateModerationResponse.Results.CategoryAppliedInputTypes.Violencegraphic.
type CreateModerationResponseResultsCategoryAppliedInputTypesViolencegraphic string

// CreateRunRequest defines model for CreateRunRequest.
type CreateRunRequest struct {
	// AdditionalInstructions Appends additional instructions at the end of the instructions for the run. This is useful for modifying the behavior on a per-run basis without overriding other instructions.
	AdditionalInstructions *string `json:"additional_instructions"`

	// AdditionalMessages Adds additional messages to the thread before creating the run.
	AdditionalMessages *[]CreateMessageRequest `json:"additional_messages"`

	// AssistantId The ID of the [assistant](/docs/api-reference/assistants) to use to execute this run.
	AssistantId string `json:"assistant_id"`

	// Instructions Overrides the [instructions](/docs/api-reference/assistants/createAssistant) of the assistant. This is useful for modifying the behavior on a per-run basis.
	Instructions *string `json:"instructions"`

	// MaxCompletionTokens The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.
	MaxCompletionTokens *int `json:"max_completion_tokens"`

	// MaxPromptTokens The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.
	MaxPromptTokens *int `json:"max_prompt_tokens"`

	// Metadata Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
	Metadata *map[string]interface{} `json:"metadata"`

	// Model The ID of the [Model](/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used.
	Model *CreateRunRequest_Model `json:"model"`

	// ParallelToolCalls Whether to enable [parallel function calling](/docs/guides/function-calling#configuring-parallel-function-calling) during tool use.
	ParallelToolCalls *ParallelToolCalls `json:"parallel_tool_calls,omitempty"`

	// ResponseFormat Specifies the format that the model must output. Compatible with [GPT-4o](/docs/models#gpt-4o), [GPT-4 Turbo](/docs/models#gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.
	//
	// Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema. Learn more in the [Structured Outputs guide](/docs/guides/structured-outputs).
	//
	// Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates is valid JSON.
	//
	// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
	ResponseFormat *AssistantsApiResponseFormatOption `json:"response_format,omitempty"`

	// Stream If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message.
	Stream *bool `json:"stream"`

	// Temperature What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
	Temperature *float32 `json:"temperature"`

	// ToolChoice Controls which (if any) tool is called by the model.
	// `none` means the model will not call any tools and instead generates a message.
	// `auto` is the default value and means the model can pick between generating a message or calling one or more tools.
	// `required` means the model must call one or more tools before responding to the user.
	// Specifying a particular tool like `{"type": "file_search"}` or `{"type": "function", "function": {"name": "my_function"}}` forces the model to call that tool.
	ToolChoice *AssistantsApiToolChoiceOption `json:"tool_choice,omitempty"`

	// Tools Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.
	Tools *[]CreateRunRequest_Tools_Item `json:"tools"`

	// TopP An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
	//
	// We generally recommend altering this or temperature but not both.
	TopP *float32 `json:"top_p"`

	// TruncationStrategy Controls for how a thread will be truncated prior to the run. Use this to control the intial context window of the run.
	TruncationStrategy *TruncationObject `json:"truncation_strategy,omitempty"`
}

// CreateRunRequestModel0 defines model for .
type CreateRunRequestModel0 = string

// CreateRunRequestModel1 defines model for CreateRunRequest.Model.1.
type CreateRunRequestModel1 string

// CreateRunRequest_Model The ID of the [Model](/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used.
type CreateRunRequest_Model struct {
	union json.RawMessage
}

// CreateRunRequest_Tools_Item defines model for CreateRunRequest.tools.Item.
type CreateRunRequest_Tools_Item struct {
	union json.RawMessage
}

// CreateSpeechRequest defines model for CreateSpeechRequest.
type CreateSpeechRequest struct {
	// Input The text to generate audio for. The maximum length is 4096 characters.
	Input string `json:"input"`

	// Model One of the available [TTS models](/docs/models#tts): `tts-1` or `tts-1-hd`
	Model CreateSpeechRequest_Model `json:"model"`

	// ResponseFormat The format to audio in. Supported formats are `mp3`, `opus`, `aac`, `flac`, `wav`, and `pcm`.
	ResponseFormat *CreateSpeechRequestResponseFormat `json:"response_format,omitempty"`

	// Speed The speed of the generated audio. Select a value from `0.25` to `4.0`. `1.0` is the default.
	Speed *float32 `json:"speed,omitempty"`

	// Voice The voice to use when generating the audio. Supported voices are `alloy`, `echo`, `fable`, `onyx`, `nova`, and `shimmer`. Previews of the voices are available in the [Text to speech guide](/docs/guides/text-to-speech#voice-options).
	Voice CreateSpeechRequestVoice `json:"voice"`
}

// CreateSpeechRequestModel0 defines model for .
type CreateSpeechRequestModel0 = string

// CreateSpeechRequestModel1 defines model for CreateSpeechRequest.Model.1.
type CreateSpeechRequestModel1 string

// CreateSpeechRequest_Model One of the available [TTS models](/docs/models#tts): `tts-1` or `tts-1-hd`
type CreateSpeechRequest_Model struct {
	union json.RawMessage
}

// CreateSpeechRequestResponseFormat The format to audio in. Supported formats are `mp3`, `opus`, `aac`, `flac`, `wav`, and `pcm`.
type CreateSpeechRequestResponseFormat string

// CreateSpeechRequestVoice The voice to use when generating the audio. Supported voices are `alloy`, `echo`, `fable`, `onyx`, `nova`, and `shimmer`. Previews of the voices are available in the [Text to speech guide](/docs/guides/text-to-speech#voice-options).
type CreateSpeechRequestVoice string

// CreateThreadAndRunRequest defines model for CreateThreadAndRunRequest.
type CreateThreadAndRunRequest struct {
	// AssistantId The ID of the [assistant](/docs/api-reference/assistants) to use to execute this run.
	AssistantId string `json:"assistant_id"`

	// Instructions Override the default system message of the assistant. This is useful for modifying the behavior on a per-run basis.
	Instructions *string `json:"instructions"`

	// MaxCompletionTokens The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.
	MaxCompletionTokens *int `json:"max_completion_tokens"`

	// MaxPromptTokens The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.
	MaxPromptTokens *int `json:"max_prompt_tokens"`

	// Metadata Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
	Metadata *map[string]interface{} `json:"metadata"`

	// Model The ID of the [Model](/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used.
	Model *CreateThreadAndRunRequest_Model `json:"model"`

	// ParallelToolCalls Whether to enable [parallel function calling](/docs/guides/function-calling#configuring-parallel-function-calling) during tool use.
	ParallelToolCalls *ParallelToolCalls `json:"parallel_tool_calls,omitempty"`

	// ResponseFormat Specifies the format that the model must output. Compatible with [GPT-4o](/docs/models#gpt-4o), [GPT-4 Turbo](/docs/models#gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.
	//
	// Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema. Learn more in the [Structured Outputs guide](/docs/guides/structured-outputs).
	//
	// Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates is valid JSON.
	//
	// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
	ResponseFormat *AssistantsApiResponseFormatOption `json:"response_format,omitempty"`

	// Stream If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message.
	Stream *bool `json:"stream"`

	// Temperature What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
	Temperature *float32             `json:"temperature"`
	Thread      *CreateThreadRequest `json:"thread,omitempty"`

	// ToolChoice Controls which (if any) tool is called by the model.
	// `none` means the model will not call any tools and instead generates a message.
	// `auto` is the default value and means the model can pick between generating a message or calling one or more tools.
	// `required` means the model must call one or more tools before responding to the user.
	// Specifying a particular tool like `{"type": "file_search"}` or `{"type": "function", "function": {"name": "my_function"}}` forces the model to call that tool.
	ToolChoice *AssistantsApiToolChoiceOption `json:"tool_choice,omitempty"`

	// ToolResources A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
	ToolResources *struct {
		CodeInterpreter *struct {
			// FileIds A list of [file](/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.
			FileIds *[]string `json:"file_ids,omitempty"`
		} `json:"code_interpreter,omitempty"`
		FileSearch *struct {
			// VectorStoreIds The ID of the [vector store](/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant.
			VectorStoreIds *[]string `json:"vector_store_ids,omitempty"`
		} `json:"file_search,omitempty"`
	} `json:"tool_resources"`

	// Tools Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.
	Tools *[]CreateThreadAndRunRequest_Tools_Item `json:"tools"`

	// TopP An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
	//
	// We generally recommend altering this or temperature but not both.
	TopP *float32 `json:"top_p"`

	// TruncationStrategy Controls for how a thread will be truncated prior to the run. Use this to control the intial context window of the run.
	TruncationStrategy *TruncationObject `json:"truncation_strategy,omitempty"`
}

// CreateThreadAndRunRequestModel0 defines model for .
type CreateThreadAndRunRequestModel0 = string

// CreateThreadAndRunRequestModel1 defines model for CreateThreadAndRunRequest.Model.1.
type CreateThreadAndRunRequestModel1 string

// CreateThreadAndRunRequest_Model The ID of the [Model](/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used.
type CreateThreadAndRunRequest_Model struct {
	union json.RawMessage
}

// CreateThreadAndRunRequest_Tools_Item defines model for CreateThreadAndRunRequest.tools.Item.
type CreateThreadAndRunRequest_Tools_Item struct {
	union json.RawMessage
}

// CreateThreadRequest defines model for CreateThreadRequest.
type CreateThreadRequest struct {
	// Messages A list of [messages](/docs/api-reference/messages) to start the thread with.
	Messages *[]CreateMessageRequest `json:"messages,omitempty"`

	// Metadata Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
	Metadata *map[string]interface{} `json:"metadata"`

	// ToolResources A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
	ToolResources *struct {
		CodeInterpreter *struct {
			// FileIds A list of [file](/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.
			FileIds *[]string `json:"file_ids,omitempty"`
		} `json:"code_interpreter,omitempty"`
		FileSearch *CreateThreadRequest_ToolResources_FileSearch `json:"file_search,omitempty"`
	} `json:"tool_resources"`
}

// CreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy0 The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`.
type CreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy0 struct {
	// Type Always `auto`.
	Type CreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy0Type `json:"type"`
}

// CreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy0Type Always `auto`.
type CreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy0Type string

// CreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy1 defines model for .
type CreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy1 struct {
	Static struct {
		// ChunkOverlapTokens The number of tokens that overlap between chunks. The default value is `400`.
		//
		// Note that the overlap must not exceed half of `max_chunk_size_tokens`.
		ChunkOverlapTokens int `json:"chunk_overlap_tokens"`

		// MaxChunkSizeTokens The maximum number of tokens in each chunk. The default value is `800`. The minimum value is `100` and the maximum value is `4096`.
		MaxChunkSizeTokens int `json:"max_chunk_size_tokens"`
	} `json:"static"`

	// Type Always `static`.
	Type CreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy1Type `json:"type"`
}

// CreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy1Type Always `static`.
type CreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy1Type string

// CreateThreadRequest_ToolResources_FileSearch_VectorStores_ChunkingStrategy The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy.
type CreateThreadRequest_ToolResources_FileSearch_VectorStores_ChunkingStrategy struct {
	union json.RawMessage
}

// CreateThreadRequestToolResourcesFileSearch0 defines model for .
type CreateThreadRequestToolResourcesFileSearch0 = interface{}

// CreateThreadRequestToolResourcesFileSearch1 defines model for .
type CreateThreadRequestToolResourcesFileSearch1 = interface{}

// CreateThreadRequest_ToolResources_FileSearch defines model for CreateThreadRequest.ToolResources.FileSearch.
type CreateThreadRequest_ToolResources_FileSearch struct {
	// VectorStoreIds The [vector store](/docs/api-reference/vector-stores/object) attached to this thread. There can be a maximum of 1 vector store attached to the thread.
	VectorStoreIds *[]string `json:"vector_store_ids,omitempty"`

	// VectorStores A helper to create a [vector store](/docs/api-reference/vector-stores/object) with file_ids and attach it to this thread. There can be a maximum of 1 vector store attached to the thread.
	VectorStores *[]struct {
		// ChunkingStrategy The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy.
		ChunkingStrategy *CreateThreadRequest_ToolResources_FileSearch_VectorStores_ChunkingStrategy `json:"chunking_strategy,omitempty"`

		// FileIds A list of [file](/docs/api-reference/files) IDs to add to the vector store. There can be a maximum of 10000 files in a vector store.
		FileIds *[]string `json:"file_ids,omitempty"`

		// Metadata Set of 16 key-value pairs that can be attached to a vector store. This can be useful for storing additional information about the vector store in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
		Metadata *map[string]interface{} `json:"metadata,omitempty"`
	} `json:"vector_stores,omitempty"`
	union json.RawMessage
}

// CreateTranscriptionRequest defines model for CreateTranscriptionRequest.
type CreateTranscriptionRequest struct {
	// File The audio file object (not file name) to transcribe, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.
	File openapi_types.File `json:"file"`

	// Language The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will improve accuracy and latency.
	Language *string `json:"language,omitempty"`

	// Model ID of the model to use. Only `whisper-1` (which is powered by our open source Whisper V2 model) is currently available.
	Model CreateTranscriptionRequest_Model `json:"model"`

	// Prompt An optional text to guide the model's style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text#prompting) should match the audio language.
	Prompt *string `json:"prompt,omitempty"`

	// ResponseFormat The format of the output, in one of these options: `json`, `text`, `srt`, `verbose_json`, or `vtt`.
	ResponseFormat *AudioResponseFormat `json:"response_format,omitempty"`

	// Temperature The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.
	Temperature *float32 `json:"temperature,omitempty"`

	// TimestampGranularities The timestamp granularities to populate for this transcription. `response_format` must be set `verbose_json` to use timestamp granularities. Either or both of these options are supported: `word`, or `segment`. Note: There is no additional latency for segment timestamps, but generating word timestamps incurs additional latency.
	TimestampGranularities *[]CreateTranscriptionRequestTimestampGranularities `json:"timestamp_granularities[],omitempty"`
}

// CreateTranscriptionRequestModel0 defines model for .
type CreateTranscriptionRequestModel0 = string

// CreateTranscriptionRequestModel1 defines model for CreateTranscriptionRequest.Model.1.
type CreateTranscriptionRequestModel1 string

// CreateTranscriptionRequest_Model ID of the model to use. Only `whisper-1` (which is powered by our open source Whisper V2 model) is currently available.
type CreateTranscriptionRequest_Model struct {
	union json.RawMessage
}

// CreateTranscriptionRequestTimestampGranularities defines model for CreateTranscriptionRequest.TimestampGranularities.
type CreateTranscriptionRequestTimestampGranularities string

// CreateTranscriptionResponseJson Represents a transcription response returned by model, based on the provided input.
type CreateTranscriptionResponseJson struct {
	// Text The transcribed text.
	Text string `json:"text"`
}

// CreateTranscriptionResponseVerboseJson Represents a verbose json transcription response returned by model, based on the provided input.
type CreateTranscriptionResponseVerboseJson struct {
	// Duration The duration of the input audio.
	Duration string `json:"duration"`

	// Language The language of the input audio.
	Language string `json:"language"`

	// Segments Segments of the transcribed text and their corresponding details.
	Segments *[]TranscriptionSegment `json:"segments,omitempty"`

	// Text The transcribed text.
	Text string `json:"text"`

	// Words Extracted words and their corresponding timestamps.
	Words *[]TranscriptionWord `json:"words,omitempty"`
}

// CreateTranslationRequest defines model for CreateTranslationRequest.
type CreateTranslationRequest struct {
	// File The audio file object (not file name) translate, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.
	File openapi_types.File `json:"file"`

	// Model ID of the model to use. Only `whisper-1` (which is powered by our open source Whisper V2 model) is currently available.
	Model CreateTranslationRequest_Model `json:"model"`

	// Prompt An optional text to guide the model's style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text#prompting) should be in English.
	Prompt *string `json:"prompt,omitempty"`

	// ResponseFormat The format of the output, in one of these options: `json`, `text`, `srt`, `verbose_json`, or `vtt`.
	ResponseFormat *AudioResponseFormat `json:"response_format,omitempty"`

	// Temperature The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.
	Temperature *float32 `json:"temperature,omitempty"`
}

// CreateTranslationRequestModel0 defines model for .
type CreateTranslationRequestModel0 = string

// CreateTranslationRequestModel1 defines model for CreateTranslationRequest.Model.1.
type CreateTranslationRequestModel1 string

// CreateTranslationRequest_Model ID of the model to use. Only `whisper-1` (which is powered by our open source Whisper V2 model) is currently available.
type CreateTranslationRequest_Model struct {
	union json.RawMessage
}

// CreateTranslationResponseJson defines model for CreateTranslationResponseJson.
type CreateTranslationResponseJson struct {
	Text string `json:"text"`
}

// CreateTranslationResponseVerboseJson defines model for CreateTranslationResponseVerboseJson.
type CreateTranslationResponseVerboseJson struct {
	// Duration The duration of the input audio.
	Duration string `json:"duration"`

	// Language The language of the output translation (always `english`).
	Language string `json:"language"`

	// Segments Segments of the translated text and their corresponding details.
	Segments *[]TranscriptionSegment `json:"segments,omitempty"`

	// Text The translated text.
	Text string `json:"text"`
}

// CreateUploadRequest defines model for CreateUploadRequest.
type CreateUploadRequest struct {
	// Bytes The number of bytes in the file you are uploading.
	Bytes int `json:"bytes"`

	// Filename The name of the file to upload.
	Filename string `json:"filename"`

	// MimeType The MIME type of the file.
	//
	// This must fall within the supported MIME types for your file purpose. See the supported MIME types for assistants and vision.
	MimeType string `json:"mime_type"`

	// Purpose The intended purpose of the uploaded file.
	//
	// See the [documentation on File purposes](/docs/api-reference/files/create#files-create-purpose).
	Purpose CreateUploadRequestPurpose `json:"purpose"`
}

// CreateUploadRequestPurpose The intended purpose of the uploaded file.
//
// See the [documentation on File purposes](/docs/api-reference/files/create#files-create-purpose).
type CreateUploadRequestPurpose string

// CreateVectorStoreFileBatchRequest defines model for CreateVectorStoreFileBatchRequest.
type CreateVectorStoreFileBatchRequest struct {
	// ChunkingStrategy The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy.
	ChunkingStrategy *ChunkingStrategyRequestParam `json:"chunking_strategy,omitempty"`

	// FileIds A list of [File](/docs/api-reference/files) IDs that the vector store should use. Useful for tools like `file_search` that can access files.
	FileIds []string `json:"file_ids"`
}

// CreateVectorStoreFileRequest defines model for CreateVectorStoreFileRequest.
type CreateVectorStoreFileRequest struct {
	// ChunkingStrategy The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy.
	ChunkingStrategy *ChunkingStrategyRequestParam `json:"chunking_strategy,omitempty"`

	// FileId A [File](/docs/api-reference/files) ID that the vector store should use. Useful for tools like `file_search` that can access files.
	FileId string `json:"file_id"`
}

// CreateVectorStoreRequest defines model for CreateVectorStoreRequest.
type CreateVectorStoreRequest struct {
	// ChunkingStrategy The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy. Only applicable if `file_ids` is non-empty.
	ChunkingStrategy *CreateVectorStoreRequest_ChunkingStrategy `json:"chunking_strategy,omitempty"`

	// ExpiresAfter The expiration policy for a vector store.
	ExpiresAfter *VectorStoreExpirationAfter `json:"expires_after,omitempty"`

	// FileIds A list of [File](/docs/api-reference/files) IDs that the vector store should use. Useful for tools like `file_search` that can access files.
	FileIds *[]string `json:"file_ids,omitempty"`

	// Metadata Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
	Metadata *map[string]interface{} `json:"metadata"`

	// Name The name of the vector store.
	Name *string `json:"name,omitempty"`
}

// CreateVectorStoreRequest_ChunkingStrategy The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy. Only applicable if `file_ids` is non-empty.
type CreateVectorStoreRequest_ChunkingStrategy struct {
	union json.RawMessage
}

// DeleteAssistantResponse defines model for DeleteAssistantResponse.
type DeleteAssistantResponse struct {
	Deleted bool                          `json:"deleted"`
	Id      string                        `json:"id"`
	Object  DeleteAssistantResponseObject `json:"object"`
}

// DeleteAssistantResponseObject defines model for DeleteAssistantResponse.Object.
type DeleteAssistantResponseObject string

// DeleteFileResponse defines model for DeleteFileResponse.
type DeleteFileResponse struct {
	Deleted bool                     `json:"deleted"`
	Id      string                   `json:"id"`
	Object  DeleteFileResponseObject `json:"object"`
}

// DeleteFileResponseObject defines model for DeleteFileResponse.Object.
type DeleteFileResponseObject string

// DeleteMessageResponse defines model for DeleteMessageResponse.
type DeleteMessageResponse struct {
	Deleted bool                        `json:"deleted"`
	Id      string                      `json:"id"`
	Object  DeleteMessageResponseObject `json:"object"`
}

// DeleteMessageResponseObject defines model for DeleteMessageResponse.Object.
type DeleteMessageResponseObject string

// DeleteModelResponse defines model for DeleteModelResponse.
type DeleteModelResponse struct {
	Deleted bool   `json:"deleted"`
	Id      string `json:"id"`
	Object  string `json:"object"`
}

// DeleteThreadResponse defines model for DeleteThreadResponse.
type DeleteThreadResponse struct {
	Deleted bool                       `json:"deleted"`
	Id      string                     `json:"id"`
	Object  DeleteThreadResponseObject `json:"object"`
}

// DeleteThreadResponseObject defines model for DeleteThreadResponse.Object.
type DeleteThreadResponseObject string

// DeleteVectorStoreFileResponse defines model for DeleteVectorStoreFileResponse.
type DeleteVectorStoreFileResponse struct {
	Deleted bool                                `json:"deleted"`
	Id      string                              `json:"id"`
	Object  DeleteVectorStoreFileResponseObject `json:"object"`
}

// DeleteVectorStoreFileResponseObject defines model for DeleteVectorStoreFileResponse.Object.
type DeleteVectorStoreFileResponseObject string

// DeleteVectorStoreResponse defines model for DeleteVectorStoreResponse.
type DeleteVectorStoreResponse struct {
	Deleted bool                            `json:"deleted"`
	Id      string                          `json:"id"`
	Object  DeleteVectorStoreResponseObject `json:"object"`
}

// DeleteVectorStoreResponseObject defines model for DeleteVectorStoreResponse.Object.
type DeleteVectorStoreResponseObject string

// Embedding Represents an embedding vector returned by embedding endpoint.
type Embedding struct {
	// Embedding The embedding vector, which is a list of floats. The length of vector depends on the model as listed in the [embedding guide](/docs/guides/embeddings).
	Embedding []float32 `json:"embedding"`

	// Index The index of the embedding in the list of embeddings.
	Index int `json:"index"`

	// Object The object type, which is always "embedding".
	Object EmbeddingObject `json:"object"`
}

// EmbeddingObject The object type, which is always "embedding".
type EmbeddingObject string

// Error defines model for Error.
type Error struct {
	Code    *string `json:"code"`
	Message string  `json:"message"`
	Param   *string `json:"param"`
	Type    string  `json:"type"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Error Error `json:"error"`
}

// FileSearchRankingOptions The ranking options for the file search. If not specified, the file search tool will use the `auto` ranker and a score_threshold of 0.
//
// See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information.
type FileSearchRankingOptions struct {
	// Ranker The ranker to use for the file search. If not specified will use the `auto` ranker.
	Ranker *FileSearchRankingOptionsRanker `json:"ranker,omitempty"`

	// ScoreThreshold The score threshold for the file search. All values must be a floating point number between 0 and 1.
	ScoreThreshold float32 `json:"score_threshold"`
}

// FileSearchRankingOptionsRanker The ranker to use for the file search. If not specified will use the `auto` ranker.
type FileSearchRankingOptionsRanker string

// FineTuningIntegration defines model for FineTuningIntegration.
type FineTuningIntegration struct {
	// Type The type of the integration being enabled for the fine-tuning job
	Type FineTuningIntegrationType `json:"type"`

	// Wandb The settings for your integration with Weights and Biases. This payload specifies the project that
	// metrics will be sent to. Optionally, you can set an explicit display name for your run, add tags
	// to your run, and set a default entity (team, username, etc) to be associated with your run.
	Wandb struct {
		// Entity The entity to use for the run. This allows you to set the team or username of the WandB user that you would
		// like associated with the run. If not set, the default entity for the registered WandB API key is used.
		Entity *string `json:"entity"`

		// Name A display name to set for the run. If not set, we will use the Job ID as the name.
		Name *string `json:"name"`

		// Project The name of the project that the new run will be created under.
		Project string `json:"project"`

		// Tags A list of tags to be attached to the newly created run. These tags are passed through directly to WandB. Some
		// default tags are generated by OpenAI: "openai/finetune", "openai/{base-model}", "openai/{ftjob-abcdef}".
		Tags *[]string `json:"tags,omitempty"`
	} `json:"wandb"`
}

// FineTuningIntegrationType The type of the integration being enabled for the fine-tuning job
type FineTuningIntegrationType string

// FineTuningJob The `fine_tuning.job` object represents a fine-tuning job that has been created through the API.
type FineTuningJob struct {
	// CreatedAt The Unix timestamp (in seconds) for when the fine-tuning job was created.
	CreatedAt int `json:"created_at"`

	// Error For fine-tuning jobs that have `failed`, this will contain more information on the cause of the failure.
	Error *struct {
		// Code A machine-readable error code.
		Code string `json:"code"`

		// Message A human-readable error message.
		Message string `json:"message"`

		// Param The parameter that was invalid, usually `training_file` or `validation_file`. This field will be null if the failure was not parameter-specific.
		Param *string `json:"param"`
	} `json:"error"`

	// EstimatedFinish The Unix timestamp (in seconds) for when the fine-tuning job is estimated to finish. The value will be null if the fine-tuning job is not running.
	EstimatedFinish *int `json:"estimated_finish"`

	// FineTunedModel The name of the fine-tuned model that is being created. The value will be null if the fine-tuning job is still running.
	FineTunedModel *string `json:"fine_tuned_model"`

	// FinishedAt The Unix timestamp (in seconds) for when the fine-tuning job was finished. The value will be null if the fine-tuning job is still running.
	FinishedAt *int `json:"finished_at"`

	// Hyperparameters The hyperparameters used for the fine-tuning job. See the [fine-tuning guide](/docs/guides/fine-tuning) for more details.
	Hyperparameters struct {
		// NEpochs The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset.
		// "auto" decides the optimal number of epochs based on the size of the dataset. If setting the number manually, we support any number between 1 and 50 epochs.
		NEpochs FineTuningJob_Hyperparameters_NEpochs `json:"n_epochs"`
	} `json:"hyperparameters"`

	// Id The object identifier, which can be referenced in the API endpoints.
	Id string `json:"id"`

	// Integrations A list of integrations to enable for this fine-tuning job.
	Integrations *[]FineTuningJob_Integrations_Item `json:"integrations"`

	// Model The base model that is being fine-tuned.
	Model string `json:"model"`

	// Object The object type, which is always "fine_tuning.job".
	Object FineTuningJobObject `json:"object"`

	// OrganizationId The organization that owns the fine-tuning job.
	OrganizationId string `json:"organization_id"`

	// ResultFiles The compiled results file ID(s) for the fine-tuning job. You can retrieve the results with the [Files API](/docs/api-reference/files/retrieve-contents).
	ResultFiles []string `json:"result_files"`

	// Seed The seed used for the fine-tuning job.
	Seed int `json:"seed"`

	// Status The current status of the fine-tuning job, which can be either `validating_files`, `queued`, `running`, `succeeded`, `failed`, or `cancelled`.
	Status FineTuningJobStatus `json:"status"`

	// TrainedTokens The total number of billable tokens processed by this fine-tuning job. The value will be null if the fine-tuning job is still running.
	TrainedTokens *int `json:"trained_tokens"`

	// TrainingFile The file ID used for training. You can retrieve the training data with the [Files API](/docs/api-reference/files/retrieve-contents).
	TrainingFile string `json:"training_file"`

	// ValidationFile The file ID used for validation. You can retrieve the validation results with the [Files API](/docs/api-reference/files/retrieve-contents).
	ValidationFile *string `json:"validation_file"`
}

// FineTuningJobHyperparametersNEpochs0 defines model for FineTuningJob.Hyperparameters.NEpochs.0.
type FineTuningJobHyperparametersNEpochs0 string

// FineTuningJobHyperparametersNEpochs1 defines model for .
type FineTuningJobHyperparametersNEpochs1 = int

// FineTuningJob_Hyperparameters_NEpochs The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset.
// "auto" decides the optimal number of epochs based on the size of the dataset. If setting the number manually, we support any number between 1 and 50 epochs.
type FineTuningJob_Hyperparameters_NEpochs struct {
	union json.RawMessage
}

// FineTuningJob_Integrations_Item defines model for FineTuningJob.integrations.Item.
type FineTuningJob_Integrations_Item struct {
	union json.RawMessage
}

// FineTuningJobObject The object type, which is always "fine_tuning.job".
type FineTuningJobObject string

// FineTuningJobStatus The current status of the fine-tuning job, which can be either `validating_files`, `queued`, `running`, `succeeded`, `failed`, or `cancelled`.
type FineTuningJobStatus string

// FineTuningJobCheckpoint The `fine_tuning.job.checkpoint` object represents a model checkpoint for a fine-tuning job that is ready to use.
type FineTuningJobCheckpoint struct {
	// CreatedAt The Unix timestamp (in seconds) for when the checkpoint was created.
	CreatedAt int `json:"created_at"`

	// FineTunedModelCheckpoint The name of the fine-tuned checkpoint model that is created.
	FineTunedModelCheckpoint string `json:"fine_tuned_model_checkpoint"`

	// FineTuningJobId The name of the fine-tuning job that this checkpoint was created from.
	FineTuningJobId string `json:"fine_tuning_job_id"`

	// Id The checkpoint identifier, which can be referenced in the API endpoints.
	Id string `json:"id"`

	// Metrics Metrics at the step number during the fine-tuning job.
	Metrics struct {
		FullValidLoss              *float32 `json:"full_valid_loss,omitempty"`
		FullValidMeanTokenAccuracy *float32 `json:"full_valid_mean_token_accuracy,omitempty"`
		Step                       *float32 `json:"step,omitempty"`
		TrainLoss                  *float32 `json:"train_loss,omitempty"`
		TrainMeanTokenAccuracy     *float32 `json:"train_mean_token_accuracy,omitempty"`
		ValidLoss                  *float32 `json:"valid_loss,omitempty"`
		ValidMeanTokenAccuracy     *float32 `json:"valid_mean_token_accuracy,omitempty"`
	} `json:"metrics"`

	// Object The object type, which is always "fine_tuning.job.checkpoint".
	Object FineTuningJobCheckpointObject `json:"object"`

	// StepNumber The step number that the checkpoint was created at.
	StepNumber int `json:"step_number"`
}

// FineTuningJobCheckpointObject The object type, which is always "fine_tuning.job.checkpoint".
type FineTuningJobCheckpointObject string

// FineTuningJobEvent Fine-tuning job event object
type FineTuningJobEvent struct {
	CreatedAt int                      `json:"created_at"`
	Id        string                   `json:"id"`
	Level     FineTuningJobEventLevel  `json:"level"`
	Message   string                   `json:"message"`
	Object    FineTuningJobEventObject `json:"object"`
}

// FineTuningJobEventLevel defines model for FineTuningJobEvent.Level.
type FineTuningJobEventLevel string

// FineTuningJobEventObject defines model for FineTuningJobEvent.Object.
type FineTuningJobEventObject string

// FunctionObject defines model for FunctionObject.
type FunctionObject struct {
	// Description A description of what the function does, used by the model to choose when and how to call the function.
	Description *string `json:"description,omitempty"`

	// Name The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
	Name string `json:"name"`

	// Parameters The parameters the functions accepts, described as a JSON Schema object. See the [guide](/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
	//
	// Omitting `parameters` defines a function with an empty parameter list.
	Parameters *FunctionParameters `json:"parameters,omitempty"`

	// Strict Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Learn more about Structured Outputs in the [function calling guide](docs/guides/function-calling).
	Strict *bool `json:"strict"`
}

// FunctionParameters The parameters the functions accepts, described as a JSON Schema object. See the [guide](/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
//
// Omitting `parameters` defines a function with an empty parameter list.
type FunctionParameters map[string]interface{}

// Image Represents the url or the content of an image generated by the OpenAI API.
type Image struct {
	// B64Json The base64-encoded JSON of the generated image, if `response_format` is `b64_json`.
	B64Json *string `json:"b64_json,omitempty"`

	// RevisedPrompt The prompt that was used to generate the image, if there was any revision to the prompt.
	RevisedPrompt *string `json:"revised_prompt,omitempty"`

	// Url The URL of the generated image, if `response_format` is `url` (default).
	Url *string `json:"url,omitempty"`
}

// ImagesResponse defines model for ImagesResponse.
type ImagesResponse struct {
	Created int     `json:"created"`
	Data    []Image `json:"data"`
}

// Invite Represents an individual `invite` to the organization.
type Invite struct {
	// AcceptedAt The Unix timestamp (in seconds) of when the invite was accepted.
	AcceptedAt *int `json:"accepted_at,omitempty"`

	// Email The email address of the individual to whom the invite was sent
	Email string `json:"email"`

	// ExpiresAt The Unix timestamp (in seconds) of when the invite expires.
	ExpiresAt int `json:"expires_at"`

	// Id The identifier, which can be referenced in API endpoints
	Id string `json:"id"`

	// InvitedAt The Unix timestamp (in seconds) of when the invite was sent.
	InvitedAt int `json:"invited_at"`

	// Object The object type, which is always `organization.invite`
	Object InviteObject `json:"object"`

	// Role `owner` or `reader`
	Role InviteRole `json:"role"`

	// Status `accepted`,`expired`, or `pending`
	Status InviteStatus `json:"status"`
}

// InviteObject The object type, which is always `organization.invite`
type InviteObject string

// InviteRole `owner` or `reader`
type InviteRole string

// InviteStatus `accepted`,`expired`, or `pending`
type InviteStatus string

// InviteDeleteResponse defines model for InviteDeleteResponse.
type InviteDeleteResponse struct {
	Deleted bool   `json:"deleted"`
	Id      string `json:"id"`

	// Object The object type, which is always `organization.invite.deleted`
	Object InviteDeleteResponseObject `json:"object"`
}

// InviteDeleteResponseObject The object type, which is always `organization.invite.deleted`
type InviteDeleteResponseObject string

// InviteListResponse defines model for InviteListResponse.
type InviteListResponse struct {
	Data []Invite `json:"data"`

	// FirstId The first `invite_id` in the retrieved `list`
	FirstId *string `json:"first_id,omitempty"`

	// HasMore The `has_more` property is used for pagination to indicate there are additional results.
	HasMore *bool `json:"has_more,omitempty"`

	// LastId The last `invite_id` in the retrieved `list`
	LastId *string `json:"last_id,omitempty"`

	// Object The object type, which is always `list`
	Object InviteListResponseObject `json:"object"`
}

// InviteListResponseObject The object type, which is always `list`
type InviteListResponseObject string

// InviteRequest defines model for InviteRequest.
type InviteRequest struct {
	// Email Send an email to this address
	Email string `json:"email"`

	// Role `owner` or `reader`
	Role InviteRequestRole `json:"role"`
}

// InviteRequestRole `owner` or `reader`
type InviteRequestRole string

// ListAssistantsResponse defines model for ListAssistantsResponse.
type ListAssistantsResponse struct {
	Data    []AssistantObject `json:"data"`
	FirstId string            `json:"first_id"`
	HasMore bool              `json:"has_more"`
	LastId  string            `json:"last_id"`
	Object  string            `json:"object"`
}

// ListAuditLogsResponse defines model for ListAuditLogsResponse.
type ListAuditLogsResponse struct {
	Data    []AuditLog                  `json:"data"`
	FirstId string                      `json:"first_id"`
	HasMore bool                        `json:"has_more"`
	LastId  string                      `json:"last_id"`
	Object  ListAuditLogsResponseObject `json:"object"`
}

// ListAuditLogsResponseObject defines model for ListAuditLogsResponse.Object.
type ListAuditLogsResponseObject string

// ListBatchesResponse defines model for ListBatchesResponse.
type ListBatchesResponse struct {
	Data    []Batch                   `json:"data"`
	FirstId *string                   `json:"first_id,omitempty"`
	HasMore bool                      `json:"has_more"`
	LastId  *string                   `json:"last_id,omitempty"`
	Object  ListBatchesResponseObject `json:"object"`
}

// ListBatchesResponseObject defines model for ListBatchesResponse.Object.
type ListBatchesResponseObject string

// ListFilesResponse defines model for ListFilesResponse.
type ListFilesResponse struct {
	Data    []OpenAIFile `json:"data"`
	FirstId string       `json:"first_id"`
	HasMore bool         `json:"has_more"`
	LastId  string       `json:"last_id"`
	Object  string       `json:"object"`
}

// ListFineTuningJobCheckpointsResponse defines model for ListFineTuningJobCheckpointsResponse.
type ListFineTuningJobCheckpointsResponse struct {
	Data    []FineTuningJobCheckpoint                  `json:"data"`
	FirstId *string                                    `json:"first_id"`
	HasMore bool                                       `json:"has_more"`
	LastId  *string                                    `json:"last_id"`
	Object  ListFineTuningJobCheckpointsResponseObject `json:"object"`
}

// ListFineTuningJobCheckpointsResponseObject defines model for ListFineTuningJobCheckpointsResponse.Object.
type ListFineTuningJobCheckpointsResponseObject string

// ListFineTuningJobEventsResponse defines model for ListFineTuningJobEventsResponse.
type ListFineTuningJobEventsResponse struct {
	Data   []FineTuningJobEvent                  `json:"data"`
	Object ListFineTuningJobEventsResponseObject `json:"object"`
}

// ListFineTuningJobEventsResponseObject defines model for ListFineTuningJobEventsResponse.Object.
type ListFineTuningJobEventsResponseObject string

// ListMessagesResponse defines model for ListMessagesResponse.
type ListMessagesResponse struct {
	Data    []MessageObject `json:"data"`
	FirstId string          `json:"first_id"`
	HasMore bool            `json:"has_more"`
	LastId  string          `json:"last_id"`
	Object  string          `json:"object"`
}

// ListModelsResponse defines model for ListModelsResponse.
type ListModelsResponse struct {
	Data   []Model                  `json:"data"`
	Object ListModelsResponseObject `json:"object"`
}

// ListModelsResponseObject defines model for ListModelsResponse.Object.
type ListModelsResponseObject string

// ListPaginatedFineTuningJobsResponse defines model for ListPaginatedFineTuningJobsResponse.
type ListPaginatedFineTuningJobsResponse struct {
	Data    []FineTuningJob                           `json:"data"`
	HasMore bool                                      `json:"has_more"`
	Object  ListPaginatedFineTuningJobsResponseObject `json:"object"`
}

// ListPaginatedFineTuningJobsResponseObject defines model for ListPaginatedFineTuningJobsResponse.Object.
type ListPaginatedFineTuningJobsResponseObject string

// ListRunStepsResponse defines model for ListRunStepsResponse.
type ListRunStepsResponse struct {
	Data    []RunStepObject `json:"data"`
	FirstId string          `json:"first_id"`
	HasMore bool            `json:"has_more"`
	LastId  string          `json:"last_id"`
	Object  string          `json:"object"`
}

// ListRunsResponse defines model for ListRunsResponse.
type ListRunsResponse struct {
	Data    []RunObject `json:"data"`
	FirstId string      `json:"first_id"`
	HasMore bool        `json:"has_more"`
	LastId  string      `json:"last_id"`
	Object  string      `json:"object"`
}

// ListVectorStoreFilesResponse defines model for ListVectorStoreFilesResponse.
type ListVectorStoreFilesResponse struct {
	Data    []VectorStoreFileObject `json:"data"`
	FirstId string                  `json:"first_id"`
	HasMore bool                    `json:"has_more"`
	LastId  string                  `json:"last_id"`
	Object  string                  `json:"object"`
}

// ListVectorStoresResponse defines model for ListVectorStoresResponse.
type ListVectorStoresResponse struct {
	Data    []VectorStoreObject `json:"data"`
	FirstId string              `json:"first_id"`
	HasMore bool                `json:"has_more"`
	LastId  string              `json:"last_id"`
	Object  string              `json:"object"`
}

// MessageContentImageFileObject References an image [File](/docs/api-reference/files) in the content of a message.
type MessageContentImageFileObject struct {
	ImageFile struct {
		// Detail Specifies the detail level of the image if specified by the user. `low` uses fewer tokens, you can opt in to high resolution using `high`.
		Detail *MessageContentImageFileObjectImageFileDetail `json:"detail,omitempty"`

		// FileId The [File](/docs/api-reference/files) ID of the image in the message content. Set `purpose="vision"` when uploading the File if you need to later display the file content.
		FileId string `json:"file_id"`
	} `json:"image_file"`

	// Type Always `image_file`.
	Type MessageContentImageFileObjectType `json:"type"`
}

// MessageContentImageFileObjectImageFileDetail Specifies the detail level of the image if specified by the user. `low` uses fewer tokens, you can opt in to high resolution using `high`.
type MessageContentImageFileObjectImageFileDetail string

// MessageContentImageFileObjectType Always `image_file`.
type MessageContentImageFileObjectType string

// MessageContentImageUrlObject References an image URL in the content of a message.
type MessageContentImageUrlObject struct {
	ImageUrl struct {
		// Detail Specifies the detail level of the image. `low` uses fewer tokens, you can opt in to high resolution using `high`. Default value is `auto`
		Detail *MessageContentImageUrlObjectImageUrlDetail `json:"detail,omitempty"`

		// Url The external URL of the image, must be a supported image types: jpeg, jpg, png, gif, webp.
		Url string `json:"url"`
	} `json:"image_url"`

	// Type The type of the content part.
	Type MessageContentImageUrlObjectType `json:"type"`
}

// MessageContentImageUrlObjectImageUrlDetail Specifies the detail level of the image. `low` uses fewer tokens, you can opt in to high resolution using `high`. Default value is `auto`
type MessageContentImageUrlObjectImageUrlDetail string

// MessageContentImageUrlObjectType The type of the content part.
type MessageContentImageUrlObjectType string

// MessageContentRefusalObject The refusal content generated by the assistant.
type MessageContentRefusalObject struct {
	Refusal string `json:"refusal"`

	// Type Always `refusal`.
	Type MessageContentRefusalObjectType `json:"type"`
}

// MessageContentRefusalObjectType Always `refusal`.
type MessageContentRefusalObjectType string

// MessageContentTextAnnotationsFileCitationObject A citation within the message that points to a specific quote from a specific File associated with the assistant or the message. Generated when the assistant uses the "file_search" tool to search files.
type MessageContentTextAnnotationsFileCitationObject struct {
	EndIndex     int `json:"end_index"`
	FileCitation struct {
		// FileId The ID of the specific File the citation is from.
		FileId string `json:"file_id"`
	} `json:"file_citation"`
	StartIndex int `json:"start_index"`

	// Text The text in the message content that needs to be replaced.
	Text string `json:"text"`

	// Type Always `file_citation`.
	Type MessageContentTextAnnotationsFileCitationObjectType `json:"type"`
}

// MessageContentTextAnnotationsFileCitationObjectType Always `file_citation`.
type MessageContentTextAnnotationsFileCitationObjectType string

// MessageContentTextAnnotationsFilePathObject A URL for the file that's generated when the assistant used the `code_interpreter` tool to generate a file.
type MessageContentTextAnnotationsFilePathObject struct {
	EndIndex int `json:"end_index"`
	FilePath struct {
		// FileId The ID of the file that was generated.
		FileId string `json:"file_id"`
	} `json:"file_path"`
	StartIndex int `json:"start_index"`

	// Text The text in the message content that needs to be replaced.
	Text string `json:"text"`

	// Type Always `file_path`.
	Type MessageContentTextAnnotationsFilePathObjectType `json:"type"`
}

// MessageContentTextAnnotationsFilePathObjectType Always `file_path`.
type MessageContentTextAnnotationsFilePathObjectType string

// MessageContentTextObject The text content that is part of a message.
type MessageContentTextObject struct {
	Text struct {
		Annotations []MessageContentTextObject_Text_Annotations_Item `json:"annotations"`

		// Value The data that makes up the text.
		Value string `json:"value"`
	} `json:"text"`

	// Type Always `text`.
	Type MessageContentTextObjectType `json:"type"`
}

// MessageContentTextObject_Text_Annotations_Item defines model for MessageContentTextObject.Text.Annotations.Item.
type MessageContentTextObject_Text_Annotations_Item struct {
	union json.RawMessage
}

// MessageContentTextObjectType Always `text`.
type MessageContentTextObjectType string

// MessageObject Represents a message within a [thread](/docs/api-reference/threads).
type MessageObject struct {
	// AssistantId If applicable, the ID of the [assistant](/docs/api-reference/assistants) that authored this message.
	AssistantId *string `json:"assistant_id"`

	// Attachments A list of files attached to the message, and the tools they were added to.
	Attachments *[]struct {
		// FileId The ID of the file to attach to the message.
		FileId *string `json:"file_id,omitempty"`

		// Tools The tools to add this file to.
		Tools *[]MessageObject_Attachments_Tools_Item `json:"tools,omitempty"`
	} `json:"attachments"`

	// CompletedAt The Unix timestamp (in seconds) for when the message was completed.
	CompletedAt *int `json:"completed_at"`

	// Content The content of the message in array of text and/or images.
	Content []MessageObject_Content_Item `json:"content"`

	// CreatedAt The Unix timestamp (in seconds) for when the message was created.
	CreatedAt int `json:"created_at"`

	// Id The identifier, which can be referenced in API endpoints.
	Id string `json:"id"`

	// IncompleteAt The Unix timestamp (in seconds) for when the message was marked as incomplete.
	IncompleteAt *int `json:"incomplete_at"`

	// IncompleteDetails On an incomplete message, details about why the message is incomplete.
	IncompleteDetails *struct {
		// Reason The reason the message is incomplete.
		Reason MessageObjectIncompleteDetailsReason `json:"reason"`
	} `json:"incomplete_details"`

	// Metadata Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
	Metadata *map[string]interface{} `json:"metadata"`

	// Object The object type, which is always `thread.message`.
	Object MessageObjectObject `json:"object"`

	// Role The entity that produced the message. One of `user` or `assistant`.
	Role MessageObjectRole `json:"role"`

	// RunId The ID of the [run](/docs/api-reference/runs) associated with the creation of this message. Value is `null` when messages are created manually using the create message or create thread endpoints.
	RunId *string `json:"run_id"`

	// Status The status of the message, which can be either `in_progress`, `incomplete`, or `completed`.
	Status MessageObjectStatus `json:"status"`

	// ThreadId The [thread](/docs/api-reference/threads) ID that this message belongs to.
	ThreadId string `json:"thread_id"`
}

// MessageObject_Attachments_Tools_Item defines model for MessageObject.Attachments.Tools.Item.
type MessageObject_Attachments_Tools_Item struct {
	union json.RawMessage
}

// MessageObject_Content_Item defines model for MessageObject.content.Item.
type MessageObject_Content_Item struct {
	union json.RawMessage
}

// MessageObjectIncompleteDetailsReason The reason the message is incomplete.
type MessageObjectIncompleteDetailsReason string

// MessageObjectObject The object type, which is always `thread.message`.
type MessageObjectObject string

// MessageObjectRole The entity that produced the message. One of `user` or `assistant`.
type MessageObjectRole string

// MessageObjectStatus The status of the message, which can be either `in_progress`, `incomplete`, or `completed`.
type MessageObjectStatus string

// MessageRequestContentTextObject The text content that is part of a message.
type MessageRequestContentTextObject struct {
	// Text Text content to be sent to the model
	Text string `json:"text"`

	// Type Always `text`.
	Type MessageRequestContentTextObjectType `json:"type"`
}

// MessageRequestContentTextObjectType Always `text`.
type MessageRequestContentTextObjectType string

// Model Describes an OpenAI model offering that can be used with the API.
type Model struct {
	// Created The Unix timestamp (in seconds) when the model was created.
	Created int `json:"created"`

	// Id The model identifier, which can be referenced in the API endpoints.
	Id string `json:"id"`

	// Object The object type, which is always "model".
	Object ModelObject `json:"object"`

	// OwnedBy The organization that owns the model.
	OwnedBy string `json:"owned_by"`
}

// ModelObject The object type, which is always "model".
type ModelObject string

// ModifyAssistantRequest defines model for ModifyAssistantRequest.
type ModifyAssistantRequest struct {
	// Description The description of the assistant. The maximum length is 512 characters.
	Description *string `json:"description"`

	// Instructions The system instructions that the assistant uses. The maximum length is 256,000 characters.
	Instructions *string `json:"instructions"`

	// Metadata Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
	Metadata *map[string]interface{} `json:"metadata"`

	// Model ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them.
	Model *ModifyAssistantRequest_Model `json:"model,omitempty"`

	// Name The name of the assistant. The maximum length is 256 characters.
	Name *string `json:"name"`

	// ResponseFormat Specifies the format that the model must output. Compatible with [GPT-4o](/docs/models#gpt-4o), [GPT-4 Turbo](/docs/models#gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.
	//
	// Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema. Learn more in the [Structured Outputs guide](/docs/guides/structured-outputs).
	//
	// Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates is valid JSON.
	//
	// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
	ResponseFormat *AssistantsApiResponseFormatOption `json:"response_format,omitempty"`

	// Temperature What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
	Temperature *float32 `json:"temperature"`

	// ToolResources A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
	ToolResources *struct {
		CodeInterpreter *struct {
			// FileIds Overrides the list of [file](/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.
			FileIds *[]string `json:"file_ids,omitempty"`
		} `json:"code_interpreter,omitempty"`
		FileSearch *struct {
			// VectorStoreIds Overrides the [vector store](/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant.
			VectorStoreIds *[]string `json:"vector_store_ids,omitempty"`
		} `json:"file_search,omitempty"`
	} `json:"tool_resources"`

	// Tools A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`.
	Tools *[]ModifyAssistantRequest_Tools_Item `json:"tools,omitempty"`

	// TopP An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
	//
	// We generally recommend altering this or temperature but not both.
	TopP *float32 `json:"top_p"`
}

// ModifyAssistantRequestModel0 defines model for .
type ModifyAssistantRequestModel0 = string

// ModifyAssistantRequest_Model ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them.
type ModifyAssistantRequest_Model struct {
	union json.RawMessage
}

// ModifyAssistantRequest_Tools_Item defines model for ModifyAssistantRequest.tools.Item.
type ModifyAssistantRequest_Tools_Item struct {
	union json.RawMessage
}

// ModifyMessageRequest defines model for ModifyMessageRequest.
type ModifyMessageRequest struct {
	// Metadata Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
	Metadata *map[string]interface{} `json:"metadata"`
}

// ModifyRunRequest defines model for ModifyRunRequest.
type ModifyRunRequest struct {
	// Metadata Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
	Metadata *map[string]interface{} `json:"metadata"`
}

// ModifyThreadRequest defines model for ModifyThreadRequest.
type ModifyThreadRequest struct {
	// Metadata Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
	Metadata *map[string]interface{} `json:"metadata"`

	// ToolResources A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
	ToolResources *struct {
		CodeInterpreter *struct {
			// FileIds A list of [file](/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.
			FileIds *[]string `json:"file_ids,omitempty"`
		} `json:"code_interpreter,omitempty"`
		FileSearch *struct {
			// VectorStoreIds The [vector store](/docs/api-reference/vector-stores/object) attached to this thread. There can be a maximum of 1 vector store attached to the thread.
			VectorStoreIds *[]string `json:"vector_store_ids,omitempty"`
		} `json:"file_search,omitempty"`
	} `json:"tool_resources"`
}

// OpenAIFile The `File` object represents a document that has been uploaded to OpenAI.
type OpenAIFile struct {
	// Bytes The size of the file, in bytes.
	Bytes int `json:"bytes"`

	// CreatedAt The Unix timestamp (in seconds) for when the file was created.
	CreatedAt int `json:"created_at"`

	// Filename The name of the file.
	Filename string `json:"filename"`

	// Id The file identifier, which can be referenced in the API endpoints.
	Id string `json:"id"`

	// Object The object type, which is always `file`.
	Object OpenAIFileObject `json:"object"`

	// Purpose The intended purpose of the file. Supported values are `assistants`, `assistants_output`, `batch`, `batch_output`, `fine-tune`, `fine-tune-results` and `vision`.
	Purpose OpenAIFilePurpose `json:"purpose"`

	// Status Deprecated. The current status of the file, which can be either `uploaded`, `processed`, or `error`.
	// Deprecated:
	Status OpenAIFileStatus `json:"status"`

	// StatusDetails Deprecated. For details on why a fine-tuning training file failed validation, see the `error` field on `fine_tuning.job`.
	// Deprecated:
	StatusDetails *string `json:"status_details,omitempty"`
}

// OpenAIFileObject The object type, which is always `file`.
type OpenAIFileObject string

// OpenAIFilePurpose The intended purpose of the file. Supported values are `assistants`, `assistants_output`, `batch`, `batch_output`, `fine-tune`, `fine-tune-results` and `vision`.
type OpenAIFilePurpose string

// OpenAIFileStatus Deprecated. The current status of the file, which can be either `uploaded`, `processed`, or `error`.
type OpenAIFileStatus string

// OtherChunkingStrategyResponseParam This is returned when the chunking strategy is unknown. Typically, this is because the file was indexed before the `chunking_strategy` concept was introduced in the API.
type OtherChunkingStrategyResponseParam struct {
	// Type Always `other`.
	Type OtherChunkingStrategyResponseParamType `json:"type"`
}

// OtherChunkingStrategyResponseParamType Always `other`.
type OtherChunkingStrategyResponseParamType string

// ParallelToolCalls Whether to enable [parallel function calling](/docs/guides/function-calling#configuring-parallel-function-calling) during tool use.
type ParallelToolCalls = bool

// PredictionContent Static predicted output content, such as the content of a text file that is
// being regenerated.
type PredictionContent struct {
	// Content The content that should be matched when generating a model response.
	// If generated tokens would match this content, the entire model response
	// can be returned much more quickly.
	Content PredictionContent_Content `json:"content"`

	// Type The type of the predicted content you want to provide. This type is
	// currently always `content`.
	Type PredictionContentType `json:"type"`
}

// PredictionContentContent0 The content used for a Predicted Output. This is often the
// text of a file you are regenerating with minor changes.
type PredictionContentContent0 = string

// PredictionContentContent1 An array of content parts with a defined type. Supported options differ based on the [model](/docs/models) being used to generate the response. Can contain text inputs.
type PredictionContentContent1 = []ChatCompletionRequestMessageContentPartText

// PredictionContent_Content The content that should be matched when generating a model response.
// If generated tokens would match this content, the entire model response
// can be returned much more quickly.
type PredictionContent_Content struct {
	union json.RawMessage
}

// PredictionContentType The type of the predicted content you want to provide. This type is
// currently always `content`.
type PredictionContentType string

// Project Represents an individual project.
type Project struct {
	// ArchivedAt The Unix timestamp (in seconds) of when the project was archived or `null`.
	ArchivedAt *int `json:"archived_at"`

	// CreatedAt The Unix timestamp (in seconds) of when the project was created.
	CreatedAt int `json:"created_at"`

	// Id The identifier, which can be referenced in API endpoints
	Id string `json:"id"`

	// Name The name of the project. This appears in reporting.
	Name string `json:"name"`

	// Object The object type, which is always `organization.project`
	Object ProjectObject `json:"object"`

	// Status `active` or `archived`
	Status ProjectStatus `json:"status"`
}

// ProjectObject The object type, which is always `organization.project`
type ProjectObject string

// ProjectStatus `active` or `archived`
type ProjectStatus string

// ProjectApiKey Represents an individual API key in a project.
type ProjectApiKey struct {
	// CreatedAt The Unix timestamp (in seconds) of when the API key was created
	CreatedAt int `json:"created_at"`

	// Id The identifier, which can be referenced in API endpoints
	Id string `json:"id"`

	// Name The name of the API key
	Name string `json:"name"`

	// Object The object type, which is always `organization.project.api_key`
	Object ProjectApiKeyObject `json:"object"`
	Owner  struct {
		// ServiceAccount Represents an individual service account in a project.
		ServiceAccount *ProjectServiceAccount `json:"service_account,omitempty"`

		// Type `user` or `service_account`
		Type *ProjectApiKeyOwnerType `json:"type,omitempty"`

		// User Represents an individual user in a project.
		User *ProjectUser `json:"user,omitempty"`
	} `json:"owner"`

	// RedactedValue The redacted value of the API key
	RedactedValue string `json:"redacted_value"`
}

// ProjectApiKeyObject The object type, which is always `organization.project.api_key`
type ProjectApiKeyObject string

// ProjectApiKeyOwnerType `user` or `service_account`
type ProjectApiKeyOwnerType string

// ProjectApiKeyDeleteResponse defines model for ProjectApiKeyDeleteResponse.
type ProjectApiKeyDeleteResponse struct {
	Deleted bool                              `json:"deleted"`
	Id      string                            `json:"id"`
	Object  ProjectApiKeyDeleteResponseObject `json:"object"`
}

// ProjectApiKeyDeleteResponseObject defines model for ProjectApiKeyDeleteResponse.Object.
type ProjectApiKeyDeleteResponseObject string

// ProjectApiKeyListResponse defines model for ProjectApiKeyListResponse.
type ProjectApiKeyListResponse struct {
	Data    []ProjectApiKey                 `json:"data"`
	FirstId string                          `json:"first_id"`
	HasMore bool                            `json:"has_more"`
	LastId  string                          `json:"last_id"`
	Object  ProjectApiKeyListResponseObject `json:"object"`
}

// ProjectApiKeyListResponseObject defines model for ProjectApiKeyListResponse.Object.
type ProjectApiKeyListResponseObject string

// ProjectCreateRequest defines model for ProjectCreateRequest.
type ProjectCreateRequest struct {
	// Name The friendly name of the project, this name appears in reports.
	Name string `json:"name"`
}

// ProjectListResponse defines model for ProjectListResponse.
type ProjectListResponse struct {
	Data    []Project                 `json:"data"`
	FirstId string                    `json:"first_id"`
	HasMore bool                      `json:"has_more"`
	LastId  string                    `json:"last_id"`
	Object  ProjectListResponseObject `json:"object"`
}

// ProjectListResponseObject defines model for ProjectListResponse.Object.
type ProjectListResponseObject string

// ProjectRateLimit Represents a project rate limit config.
type ProjectRateLimit struct {
	// Batch1DayMaxInputTokens The maximum batch input tokens per day. Only present for relevant models.
	Batch1DayMaxInputTokens *int `json:"batch_1_day_max_input_tokens,omitempty"`

	// Id The identifier, which can be referenced in API endpoints.
	Id string `json:"id"`

	// MaxAudioMegabytesPer1Minute The maximum audio megabytes per minute. Only present for relevant models.
	MaxAudioMegabytesPer1Minute *int `json:"max_audio_megabytes_per_1_minute,omitempty"`

	// MaxImagesPer1Minute The maximum images per minute. Only present for relevant models.
	MaxImagesPer1Minute *int `json:"max_images_per_1_minute,omitempty"`

	// MaxRequestsPer1Day The maximum requests per day. Only present for relevant models.
	MaxRequestsPer1Day *int `json:"max_requests_per_1_day,omitempty"`

	// MaxRequestsPer1Minute The maximum requests per minute.
	MaxRequestsPer1Minute int `json:"max_requests_per_1_minute"`

	// MaxTokensPer1Minute The maximum tokens per minute.
	MaxTokensPer1Minute int `json:"max_tokens_per_1_minute"`

	// Model The model this rate limit applies to.
	Model string `json:"model"`

	// Object The object type, which is always `project.rate_limit`
	Object ProjectRateLimitObject `json:"object"`
}

// ProjectRateLimitObject The object type, which is always `project.rate_limit`
type ProjectRateLimitObject string

// ProjectRateLimitListResponse defines model for ProjectRateLimitListResponse.
type ProjectRateLimitListResponse struct {
	Data    []ProjectRateLimit                 `json:"data"`
	FirstId string                             `json:"first_id"`
	HasMore bool                               `json:"has_more"`
	LastId  string                             `json:"last_id"`
	Object  ProjectRateLimitListResponseObject `json:"object"`
}

// ProjectRateLimitListResponseObject defines model for ProjectRateLimitListResponse.Object.
type ProjectRateLimitListResponseObject string

// ProjectRateLimitUpdateRequest defines model for ProjectRateLimitUpdateRequest.
type ProjectRateLimitUpdateRequest struct {
	// Batch1DayMaxInputTokens The maximum batch input tokens per day. Only relevant for certain models.
	Batch1DayMaxInputTokens *int `json:"batch_1_day_max_input_tokens,omitempty"`

	// MaxAudioMegabytesPer1Minute The maximum audio megabytes per minute. Only relevant for certain models.
	MaxAudioMegabytesPer1Minute *int `json:"max_audio_megabytes_per_1_minute,omitempty"`

	// MaxImagesPer1Minute The maximum images per minute. Only relevant for certain models.
	MaxImagesPer1Minute *int `json:"max_images_per_1_minute,omitempty"`

	// MaxRequestsPer1Day The maximum requests per day. Only relevant for certain models.
	MaxRequestsPer1Day *int `json:"max_requests_per_1_day,omitempty"`

	// MaxRequestsPer1Minute The maximum requests per minute.
	MaxRequestsPer1Minute *int `json:"max_requests_per_1_minute,omitempty"`

	// MaxTokensPer1Minute The maximum tokens per minute.
	MaxTokensPer1Minute *int `json:"max_tokens_per_1_minute,omitempty"`
}

// ProjectServiceAccount Represents an individual service account in a project.
type ProjectServiceAccount struct {
	// CreatedAt The Unix timestamp (in seconds) of when the service account was created
	CreatedAt int `json:"created_at"`

	// Id The identifier, which can be referenced in API endpoints
	Id string `json:"id"`

	// Name The name of the service account
	Name string `json:"name"`

	// Object The object type, which is always `organization.project.service_account`
	Object ProjectServiceAccountObject `json:"object"`

	// Role `owner` or `member`
	Role ProjectServiceAccountRole `json:"role"`
}

// ProjectServiceAccountObject The object type, which is always `organization.project.service_account`
type ProjectServiceAccountObject string

// ProjectServiceAccountRole `owner` or `member`
type ProjectServiceAccountRole string

// ProjectServiceAccountApiKey defines model for ProjectServiceAccountApiKey.
type ProjectServiceAccountApiKey struct {
	CreatedAt int    `json:"created_at"`
	Id        string `json:"id"`
	Name      string `json:"name"`

	// Object The object type, which is always `organization.project.service_account.api_key`
	Object ProjectServiceAccountApiKeyObject `json:"object"`
	Value  string                            `json:"value"`
}

// ProjectServiceAccountApiKeyObject The object type, which is always `organization.project.service_account.api_key`
type ProjectServiceAccountApiKeyObject string

// ProjectServiceAccountCreateRequest defines model for ProjectServiceAccountCreateRequest.
type ProjectServiceAccountCreateRequest struct {
	// Name The name of the service account being created.
	Name string `json:"name"`
}

// ProjectServiceAccountCreateResponse defines model for ProjectServiceAccountCreateResponse.
type ProjectServiceAccountCreateResponse struct {
	ApiKey    ProjectServiceAccountApiKey               `json:"api_key"`
	CreatedAt int                                       `json:"created_at"`
	Id        string                                    `json:"id"`
	Name      string                                    `json:"name"`
	Object    ProjectServiceAccountCreateResponseObject `json:"object"`

	// Role Service accounts can only have one role of type `member`
	Role ProjectServiceAccountCreateResponseRole `json:"role"`
}

// ProjectServiceAccountCreateResponseObject defines model for ProjectServiceAccountCreateResponse.Object.
type ProjectServiceAccountCreateResponseObject string

// ProjectServiceAccountCreateResponseRole Service accounts can only have one role of type `member`
type ProjectServiceAccountCreateResponseRole string

// ProjectServiceAccountDeleteResponse defines model for ProjectServiceAccountDeleteResponse.
type ProjectServiceAccountDeleteResponse struct {
	Deleted bool                                      `json:"deleted"`
	Id      string                                    `json:"id"`
	Object  ProjectServiceAccountDeleteResponseObject `json:"object"`
}

// ProjectServiceAccountDeleteResponseObject defines model for ProjectServiceAccountDeleteResponse.Object.
type ProjectServiceAccountDeleteResponseObject string

// ProjectServiceAccountListResponse defines model for ProjectServiceAccountListResponse.
type ProjectServiceAccountListResponse struct {
	Data    []ProjectServiceAccount                 `json:"data"`
	FirstId string                                  `json:"first_id"`
	HasMore bool                                    `json:"has_more"`
	LastId  string                                  `json:"last_id"`
	Object  ProjectServiceAccountListResponseObject `json:"object"`
}

// ProjectServiceAccountListResponseObject defines model for ProjectServiceAccountListResponse.Object.
type ProjectServiceAccountListResponseObject string

// ProjectUpdateRequest defines model for ProjectUpdateRequest.
type ProjectUpdateRequest struct {
	// Name The updated name of the project, this name appears in reports.
	Name string `json:"name"`
}

// ProjectUser Represents an individual user in a project.
type ProjectUser struct {
	// AddedAt The Unix timestamp (in seconds) of when the project was added.
	AddedAt int `json:"added_at"`

	// Email The email address of the user
	Email string `json:"email"`

	// Id The identifier, which can be referenced in API endpoints
	Id string `json:"id"`

	// Name The name of the user
	Name string `json:"name"`

	// Object The object type, which is always `organization.project.user`
	Object ProjectUserObject `json:"object"`

	// Role `owner` or `member`
	Role ProjectUserRole `json:"role"`
}

// ProjectUserObject The object type, which is always `organization.project.user`
type ProjectUserObject string

// ProjectUserRole `owner` or `member`
type ProjectUserRole string

// ProjectUserCreateRequest defines model for ProjectUserCreateRequest.
type ProjectUserCreateRequest struct {
	// Role `owner` or `member`
	Role ProjectUserCreateRequestRole `json:"role"`

	// UserId The ID of the user.
	UserId string `json:"user_id"`
}

// ProjectUserCreateRequestRole `owner` or `member`
type ProjectUserCreateRequestRole string

// ProjectUserDeleteResponse defines model for ProjectUserDeleteResponse.
type ProjectUserDeleteResponse struct {
	Deleted bool                            `json:"deleted"`
	Id      string                          `json:"id"`
	Object  ProjectUserDeleteResponseObject `json:"object"`
}

// ProjectUserDeleteResponseObject defines model for ProjectUserDeleteResponse.Object.
type ProjectUserDeleteResponseObject string

// ProjectUserListResponse defines model for ProjectUserListResponse.
type ProjectUserListResponse struct {
	Data    []ProjectUser `json:"data"`
	FirstId string        `json:"first_id"`
	HasMore bool          `json:"has_more"`
	LastId  string        `json:"last_id"`
	Object  string        `json:"object"`
}

// ProjectUserUpdateRequest defines model for ProjectUserUpdateRequest.
type ProjectUserUpdateRequest struct {
	// Role `owner` or `member`
	Role ProjectUserUpdateRequestRole `json:"role"`
}

// ProjectUserUpdateRequestRole `owner` or `member`
type ProjectUserUpdateRequestRole string

// ResponseFormatJsonObject defines model for ResponseFormatJsonObject.
type ResponseFormatJsonObject struct {
	// Type The type of response format being defined: `json_object`
	Type ResponseFormatJsonObjectType `json:"type"`
}

// ResponseFormatJsonObjectType The type of response format being defined: `json_object`
type ResponseFormatJsonObjectType string

// ResponseFormatJsonSchema defines model for ResponseFormatJsonSchema.
type ResponseFormatJsonSchema struct {
	JsonSchema struct {
		// Description A description of what the response format is for, used by the model to determine how to respond in the format.
		Description *string `json:"description,omitempty"`

		// Name The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
		Name string `json:"name"`

		// Schema The schema for the response format, described as a JSON Schema object.
		Schema *ResponseFormatJsonSchemaSchema `json:"schema,omitempty"`

		// Strict Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. To learn more, read the [Structured Outputs guide](/docs/guides/structured-outputs).
		Strict *bool `json:"strict"`
	} `json:"json_schema"`

	// Type The type of response format being defined: `json_schema`
	Type ResponseFormatJsonSchemaType `json:"type"`
}

// ResponseFormatJsonSchemaType The type of response format being defined: `json_schema`
type ResponseFormatJsonSchemaType string

// ResponseFormatJsonSchemaSchema The schema for the response format, described as a JSON Schema object.
type ResponseFormatJsonSchemaSchema map[string]interface{}

// ResponseFormatText defines model for ResponseFormatText.
type ResponseFormatText struct {
	// Type The type of response format being defined: `text`
	Type ResponseFormatTextType `json:"type"`
}

// ResponseFormatTextType The type of response format being defined: `text`
type ResponseFormatTextType string

// RunCompletionUsage Usage statistics related to the run. This value will be `null` if the run is not in a terminal state (i.e. `in_progress`, `queued`, etc.).
type RunCompletionUsage struct {
	// CompletionTokens Number of completion tokens used over the course of the run.
	CompletionTokens int `json:"completion_tokens"`

	// PromptTokens Number of prompt tokens used over the course of the run.
	PromptTokens int `json:"prompt_tokens"`

	// TotalTokens Total number of tokens used (prompt + completion).
	TotalTokens int `json:"total_tokens"`
}

// RunObject Represents an execution run on a [thread](/docs/api-reference/threads).
type RunObject struct {
	// AssistantId The ID of the [assistant](/docs/api-reference/assistants) used for execution of this run.
	AssistantId string `json:"assistant_id"`

	// CancelledAt The Unix timestamp (in seconds) for when the run was cancelled.
	CancelledAt *int `json:"cancelled_at"`

	// CompletedAt The Unix timestamp (in seconds) for when the run was completed.
	CompletedAt *int `json:"completed_at"`

	// CreatedAt The Unix timestamp (in seconds) for when the run was created.
	CreatedAt int `json:"created_at"`

	// ExpiresAt The Unix timestamp (in seconds) for when the run will expire.
	ExpiresAt *int `json:"expires_at"`

	// FailedAt The Unix timestamp (in seconds) for when the run failed.
	FailedAt *int `json:"failed_at"`

	// Id The identifier, which can be referenced in API endpoints.
	Id string `json:"id"`

	// IncompleteDetails Details on why the run is incomplete. Will be `null` if the run is not incomplete.
	IncompleteDetails *struct {
		// Reason The reason why the run is incomplete. This will point to which specific token limit was reached over the course of the run.
		Reason *RunObjectIncompleteDetailsReason `json:"reason,omitempty"`
	} `json:"incomplete_details"`

	// Instructions The instructions that the [assistant](/docs/api-reference/assistants) used for this run.
	Instructions string `json:"instructions"`

	// LastError The last error associated with this run. Will be `null` if there are no errors.
	LastError *struct {
		// Code One of `server_error`, `rate_limit_exceeded`, or `invalid_prompt`.
		Code RunObjectLastErrorCode `json:"code"`

		// Message A human-readable description of the error.
		Message string `json:"message"`
	} `json:"last_error"`

	// MaxCompletionTokens The maximum number of completion tokens specified to have been used over the course of the run.
	MaxCompletionTokens *int `json:"max_completion_tokens"`

	// MaxPromptTokens The maximum number of prompt tokens specified to have been used over the course of the run.
	MaxPromptTokens *int `json:"max_prompt_tokens"`

	// Metadata Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
	Metadata *map[string]interface{} `json:"metadata"`

	// Model The model that the [assistant](/docs/api-reference/assistants) used for this run.
	Model string `json:"model"`

	// Object The object type, which is always `thread.run`.
	Object RunObjectObject `json:"object"`

	// ParallelToolCalls Whether to enable [parallel function calling](/docs/guides/function-calling#configuring-parallel-function-calling) during tool use.
	ParallelToolCalls ParallelToolCalls `json:"parallel_tool_calls"`

	// RequiredAction Details on the action required to continue the run. Will be `null` if no action is required.
	RequiredAction *struct {
		// SubmitToolOutputs Details on the tool outputs needed for this run to continue.
		SubmitToolOutputs struct {
			// ToolCalls A list of the relevant tool calls.
			ToolCalls []RunToolCallObject `json:"tool_calls"`
		} `json:"submit_tool_outputs"`

		// Type For now, this is always `submit_tool_outputs`.
		Type RunObjectRequiredActionType `json:"type"`
	} `json:"required_action"`

	// ResponseFormat Specifies the format that the model must output. Compatible with [GPT-4o](/docs/models#gpt-4o), [GPT-4 Turbo](/docs/models#gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.
	//
	// Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema. Learn more in the [Structured Outputs guide](/docs/guides/structured-outputs).
	//
	// Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates is valid JSON.
	//
	// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
	ResponseFormat AssistantsApiResponseFormatOption `json:"response_format"`

	// StartedAt The Unix timestamp (in seconds) for when the run was started.
	StartedAt *int `json:"started_at"`

	// Status The status of the run, which can be either `queued`, `in_progress`, `requires_action`, `cancelling`, `cancelled`, `failed`, `completed`, `incomplete`, or `expired`.
	Status RunObjectStatus `json:"status"`

	// Temperature The sampling temperature used for this run. If not set, defaults to 1.
	Temperature *float32 `json:"temperature"`

	// ThreadId The ID of the [thread](/docs/api-reference/threads) that was executed on as a part of this run.
	ThreadId string `json:"thread_id"`

	// ToolChoice Controls which (if any) tool is called by the model.
	// `none` means the model will not call any tools and instead generates a message.
	// `auto` is the default value and means the model can pick between generating a message or calling one or more tools.
	// `required` means the model must call one or more tools before responding to the user.
	// Specifying a particular tool like `{"type": "file_search"}` or `{"type": "function", "function": {"name": "my_function"}}` forces the model to call that tool.
	ToolChoice AssistantsApiToolChoiceOption `json:"tool_choice"`

	// Tools The list of tools that the [assistant](/docs/api-reference/assistants) used for this run.
	Tools []RunObject_Tools_Item `json:"tools"`

	// TopP The nucleus sampling value used for this run. If not set, defaults to 1.
	TopP *float32 `json:"top_p"`

	// TruncationStrategy Controls for how a thread will be truncated prior to the run. Use this to control the intial context window of the run.
	TruncationStrategy TruncationObject `json:"truncation_strategy"`

	// Usage Usage statistics related to the run. This value will be `null` if the run is not in a terminal state (i.e. `in_progress`, `queued`, etc.).
	Usage *RunCompletionUsage `json:"usage"`
}

// RunObjectIncompleteDetailsReason The reason why the run is incomplete. This will point to which specific token limit was reached over the course of the run.
type RunObjectIncompleteDetailsReason string

// RunObjectLastErrorCode One of `server_error`, `rate_limit_exceeded`, or `invalid_prompt`.
type RunObjectLastErrorCode string

// RunObjectObject The object type, which is always `thread.run`.
type RunObjectObject string

// RunObjectRequiredActionType For now, this is always `submit_tool_outputs`.
type RunObjectRequiredActionType string

// RunObjectStatus The status of the run, which can be either `queued`, `in_progress`, `requires_action`, `cancelling`, `cancelled`, `failed`, `completed`, `incomplete`, or `expired`.
type RunObjectStatus string

// RunObject_Tools_Item defines model for RunObject.tools.Item.
type RunObject_Tools_Item struct {
	union json.RawMessage
}

// RunStepCompletionUsage Usage statistics related to the run step. This value will be `null` while the run step's status is `in_progress`.
type RunStepCompletionUsage struct {
	// CompletionTokens Number of completion tokens used over the course of the run step.
	CompletionTokens int `json:"completion_tokens"`

	// PromptTokens Number of prompt tokens used over the course of the run step.
	PromptTokens int `json:"prompt_tokens"`

	// TotalTokens Total number of tokens used (prompt + completion).
	TotalTokens int `json:"total_tokens"`
}

// RunStepDetailsMessageCreationObject Details of the message creation by the run step.
type RunStepDetailsMessageCreationObject struct {
	MessageCreation struct {
		// MessageId The ID of the message that was created by this run step.
		MessageId string `json:"message_id"`
	} `json:"message_creation"`

	// Type Always `message_creation`.
	Type RunStepDetailsMessageCreationObjectType `json:"type"`
}

// RunStepDetailsMessageCreationObjectType Always `message_creation`.
type RunStepDetailsMessageCreationObjectType string

// RunStepDetailsToolCallsCodeObject Details of the Code Interpreter tool call the run step was involved in.
type RunStepDetailsToolCallsCodeObject struct {
	// CodeInterpreter The Code Interpreter tool call definition.
	CodeInterpreter struct {
		// Input The input to the Code Interpreter tool call.
		Input string `json:"input"`

		// Outputs The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type.
		Outputs []RunStepDetailsToolCallsCodeObject_CodeInterpreter_Outputs_Item `json:"outputs"`
	} `json:"code_interpreter"`

	// Id The ID of the tool call.
	Id string `json:"id"`

	// Type The type of tool call. This is always going to be `code_interpreter` for this type of tool call.
	Type RunStepDetailsToolCallsCodeObjectType `json:"type"`
}

// RunStepDetailsToolCallsCodeObject_CodeInterpreter_Outputs_Item defines model for RunStepDetailsToolCallsCodeObject.CodeInterpreter.Outputs.Item.
type RunStepDetailsToolCallsCodeObject_CodeInterpreter_Outputs_Item struct {
	union json.RawMessage
}

// RunStepDetailsToolCallsCodeObjectType The type of tool call. This is always going to be `code_interpreter` for this type of tool call.
type RunStepDetailsToolCallsCodeObjectType string

// RunStepDetailsToolCallsCodeOutputImageObject defines model for RunStepDetailsToolCallsCodeOutputImageObject.
type RunStepDetailsToolCallsCodeOutputImageObject struct {
	Image struct {
		// FileId The [file](/docs/api-reference/files) ID of the image.
		FileId string `json:"file_id"`
	} `json:"image"`

	// Type Always `image`.
	Type RunStepDetailsToolCallsCodeOutputImageObjectType `json:"type"`
}

// RunStepDetailsToolCallsCodeOutputImageObjectType Always `image`.
type RunStepDetailsToolCallsCodeOutputImageObjectType string

// RunStepDetailsToolCallsCodeOutputLogsObject Text output from the Code Interpreter tool call as part of a run step.
type RunStepDetailsToolCallsCodeOutputLogsObject struct {
	// Logs The text output from the Code Interpreter tool call.
	Logs string `json:"logs"`

	// Type Always `logs`.
	Type RunStepDetailsToolCallsCodeOutputLogsObjectType `json:"type"`
}

// RunStepDetailsToolCallsCodeOutputLogsObjectType Always `logs`.
type RunStepDetailsToolCallsCodeOutputLogsObjectType string

// RunStepDetailsToolCallsFileSearchObject defines model for RunStepDetailsToolCallsFileSearchObject.
type RunStepDetailsToolCallsFileSearchObject struct {
	// FileSearch For now, this is always going to be an empty object.
	FileSearch struct {
		// RankingOptions The ranking options for the file search.
		RankingOptions *RunStepDetailsToolCallsFileSearchRankingOptionsObject `json:"ranking_options,omitempty"`

		// Results The results of the file search.
		Results *[]RunStepDetailsToolCallsFileSearchResultObject `json:"results,omitempty"`
	} `json:"file_search"`

	// Id The ID of the tool call object.
	Id string `json:"id"`

	// Type The type of tool call. This is always going to be `file_search` for this type of tool call.
	Type RunStepDetailsToolCallsFileSearchObjectType `json:"type"`
}

// RunStepDetailsToolCallsFileSearchObjectType The type of tool call. This is always going to be `file_search` for this type of tool call.
type RunStepDetailsToolCallsFileSearchObjectType string

// RunStepDetailsToolCallsFileSearchRankingOptionsObject The ranking options for the file search.
type RunStepDetailsToolCallsFileSearchRankingOptionsObject struct {
	// Ranker The ranker used for the file search.
	Ranker RunStepDetailsToolCallsFileSearchRankingOptionsObjectRanker `json:"ranker"`

	// ScoreThreshold The score threshold for the file search. All values must be a floating point number between 0 and 1.
	ScoreThreshold float32 `json:"score_threshold"`
}

// RunStepDetailsToolCallsFileSearchRankingOptionsObjectRanker The ranker used for the file search.
type RunStepDetailsToolCallsFileSearchRankingOptionsObjectRanker string

// RunStepDetailsToolCallsFileSearchResultObject A result instance of the file search.
type RunStepDetailsToolCallsFileSearchResultObject struct {
	// Content The content of the result that was found. The content is only included if requested via the include query parameter.
	Content *[]struct {
		// Text The text content of the file.
		Text *string `json:"text,omitempty"`

		// Type The type of the content.
		Type *RunStepDetailsToolCallsFileSearchResultObjectContentType `json:"type,omitempty"`
	} `json:"content,omitempty"`

	// FileId The ID of the file that result was found in.
	FileId string `json:"file_id"`

	// FileName The name of the file that result was found in.
	FileName string `json:"file_name"`

	// Score The score of the result. All values must be a floating point number between 0 and 1.
	Score float32 `json:"score"`
}

// RunStepDetailsToolCallsFileSearchResultObjectContentType The type of the content.
type RunStepDetailsToolCallsFileSearchResultObjectContentType string

// RunStepDetailsToolCallsFunctionObject defines model for RunStepDetailsToolCallsFunctionObject.
type RunStepDetailsToolCallsFunctionObject struct {
	// Function The definition of the function that was called.
	Function struct {
		// Arguments The arguments passed to the function.
		Arguments string `json:"arguments"`

		// Name The name of the function.
		Name string `json:"name"`

		// Output The output of the function. This will be `null` if the outputs have not been [submitted](/docs/api-reference/runs/submitToolOutputs) yet.
		Output *string `json:"output"`
	} `json:"function"`

	// Id The ID of the tool call object.
	Id string `json:"id"`

	// Type The type of tool call. This is always going to be `function` for this type of tool call.
	Type RunStepDetailsToolCallsFunctionObjectType `json:"type"`
}

// RunStepDetailsToolCallsFunctionObjectType The type of tool call. This is always going to be `function` for this type of tool call.
type RunStepDetailsToolCallsFunctionObjectType string

// RunStepDetailsToolCallsObject Details of the tool call.
type RunStepDetailsToolCallsObject struct {
	// ToolCalls An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `file_search`, or `function`.
	ToolCalls []RunStepDetailsToolCallsObject_ToolCalls_Item `json:"tool_calls"`

	// Type Always `tool_calls`.
	Type RunStepDetailsToolCallsObjectType `json:"type"`
}

// RunStepDetailsToolCallsObject_ToolCalls_Item defines model for RunStepDetailsToolCallsObject.tool_calls.Item.
type RunStepDetailsToolCallsObject_ToolCalls_Item struct {
	union json.RawMessage
}

// RunStepDetailsToolCallsObjectType Always `tool_calls`.
type RunStepDetailsToolCallsObjectType string

// RunStepObject Represents a step in execution of a run.
type RunStepObject struct {
	// AssistantId The ID of the [assistant](/docs/api-reference/assistants) associated with the run step.
	AssistantId string `json:"assistant_id"`

	// CancelledAt The Unix timestamp (in seconds) for when the run step was cancelled.
	CancelledAt *int `json:"cancelled_at"`

	// CompletedAt The Unix timestamp (in seconds) for when the run step completed.
	CompletedAt *int `json:"completed_at"`

	// CreatedAt The Unix timestamp (in seconds) for when the run step was created.
	CreatedAt int `json:"created_at"`

	// ExpiredAt The Unix timestamp (in seconds) for when the run step expired. A step is considered expired if the parent run is expired.
	ExpiredAt *int `json:"expired_at"`

	// FailedAt The Unix timestamp (in seconds) for when the run step failed.
	FailedAt *int `json:"failed_at"`

	// Id The identifier of the run step, which can be referenced in API endpoints.
	Id string `json:"id"`

	// LastError The last error associated with this run step. Will be `null` if there are no errors.
	LastError *struct {
		// Code One of `server_error` or `rate_limit_exceeded`.
		Code RunStepObjectLastErrorCode `json:"code"`

		// Message A human-readable description of the error.
		Message string `json:"message"`
	} `json:"last_error"`

	// Metadata Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
	Metadata *map[string]interface{} `json:"metadata"`

	// Object The object type, which is always `thread.run.step`.
	Object RunStepObjectObject `json:"object"`

	// RunId The ID of the [run](/docs/api-reference/runs) that this run step is a part of.
	RunId string `json:"run_id"`

	// Status The status of the run step, which can be either `in_progress`, `cancelled`, `failed`, `completed`, or `expired`.
	Status RunStepObjectStatus `json:"status"`

	// StepDetails The details of the run step.
	StepDetails RunStepObject_StepDetails `json:"step_details"`

	// ThreadId The ID of the [thread](/docs/api-reference/threads) that was run.
	ThreadId string `json:"thread_id"`

	// Type The type of run step, which can be either `message_creation` or `tool_calls`.
	Type RunStepObjectType `json:"type"`

	// Usage Usage statistics related to the run step. This value will be `null` while the run step's status is `in_progress`.
	Usage *RunStepCompletionUsage `json:"usage"`
}

// RunStepObjectLastErrorCode One of `server_error` or `rate_limit_exceeded`.
type RunStepObjectLastErrorCode string

// RunStepObjectObject The object type, which is always `thread.run.step`.
type RunStepObjectObject string

// RunStepObjectStatus The status of the run step, which can be either `in_progress`, `cancelled`, `failed`, `completed`, or `expired`.
type RunStepObjectStatus string

// RunStepObject_StepDetails The details of the run step.
type RunStepObject_StepDetails struct {
	union json.RawMessage
}

// RunStepObjectType The type of run step, which can be either `message_creation` or `tool_calls`.
type RunStepObjectType string

// RunToolCallObject Tool call objects
type RunToolCallObject struct {
	// Function The function definition.
	Function struct {
		// Arguments The arguments that the model expects you to pass to the function.
		Arguments string `json:"arguments"`

		// Name The name of the function.
		Name string `json:"name"`
	} `json:"function"`

	// Id The ID of the tool call. This ID must be referenced when you submit the tool outputs in using the [Submit tool outputs to run](/docs/api-reference/runs/submitToolOutputs) endpoint.
	Id string `json:"id"`

	// Type The type of tool call the output is required for. For now, this is always `function`.
	Type RunToolCallObjectType `json:"type"`
}

// RunToolCallObjectType The type of tool call the output is required for. For now, this is always `function`.
type RunToolCallObjectType string

// StaticChunkingStrategy defines model for StaticChunkingStrategy.
type StaticChunkingStrategy struct {
	// ChunkOverlapTokens The number of tokens that overlap between chunks. The default value is `400`.
	//
	// Note that the overlap must not exceed half of `max_chunk_size_tokens`.
	ChunkOverlapTokens int `json:"chunk_overlap_tokens"`

	// MaxChunkSizeTokens The maximum number of tokens in each chunk. The default value is `800`. The minimum value is `100` and the maximum value is `4096`.
	MaxChunkSizeTokens int `json:"max_chunk_size_tokens"`
}

// StaticChunkingStrategyRequestParam defines model for StaticChunkingStrategyRequestParam.
type StaticChunkingStrategyRequestParam struct {
	Static StaticChunkingStrategy `json:"static"`

	// Type Always `static`.
	Type StaticChunkingStrategyRequestParamType `json:"type"`
}

// StaticChunkingStrategyRequestParamType Always `static`.
type StaticChunkingStrategyRequestParamType string

// StaticChunkingStrategyResponseParam defines model for StaticChunkingStrategyResponseParam.
type StaticChunkingStrategyResponseParam struct {
	Static StaticChunkingStrategy `json:"static"`

	// Type Always `static`.
	Type StaticChunkingStrategyResponseParamType `json:"type"`
}

// StaticChunkingStrategyResponseParamType Always `static`.
type StaticChunkingStrategyResponseParamType string

// SubmitToolOutputsRunRequest defines model for SubmitToolOutputsRunRequest.
type SubmitToolOutputsRunRequest struct {
	// Stream If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message.
	Stream *bool `json:"stream"`

	// ToolOutputs A list of tools for which the outputs are being submitted.
	ToolOutputs []struct {
		// Output The output of the tool call to be submitted to continue the run.
		Output *string `json:"output,omitempty"`

		// ToolCallId The ID of the tool call in the `required_action` object within the run object the output is being submitted for.
		ToolCallId *string `json:"tool_call_id,omitempty"`
	} `json:"tool_outputs"`
}

// ThreadObject Represents a thread that contains [messages](/docs/api-reference/messages).
type ThreadObject struct {
	// CreatedAt The Unix timestamp (in seconds) for when the thread was created.
	CreatedAt int `json:"created_at"`

	// Id The identifier, which can be referenced in API endpoints.
	Id string `json:"id"`

	// Metadata Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
	Metadata *map[string]interface{} `json:"metadata"`

	// Object The object type, which is always `thread`.
	Object ThreadObjectObject `json:"object"`

	// ToolResources A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
	ToolResources *struct {
		CodeInterpreter *struct {
			// FileIds A list of [file](/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.
			FileIds *[]string `json:"file_ids,omitempty"`
		} `json:"code_interpreter,omitempty"`
		FileSearch *struct {
			// VectorStoreIds The [vector store](/docs/api-reference/vector-stores/object) attached to this thread. There can be a maximum of 1 vector store attached to the thread.
			VectorStoreIds *[]string `json:"vector_store_ids,omitempty"`
		} `json:"file_search,omitempty"`
	} `json:"tool_resources"`
}

// ThreadObjectObject The object type, which is always `thread`.
type ThreadObjectObject string

// TranscriptionSegment defines model for TranscriptionSegment.
type TranscriptionSegment struct {
	// AvgLogprob Average logprob of the segment. If the value is lower than -1, consider the logprobs failed.
	AvgLogprob float32 `json:"avg_logprob"`

	// CompressionRatio Compression ratio of the segment. If the value is greater than 2.4, consider the compression failed.
	CompressionRatio float32 `json:"compression_ratio"`

	// End End time of the segment in seconds.
	End float32 `json:"end"`

	// Id Unique identifier of the segment.
	Id int `json:"id"`

	// NoSpeechProb Probability of no speech in the segment. If the value is higher than 1.0 and the `avg_logprob` is below -1, consider this segment silent.
	NoSpeechProb float32 `json:"no_speech_prob"`

	// Seek Seek offset of the segment.
	Seek int `json:"seek"`

	// Start Start time of the segment in seconds.
	Start float32 `json:"start"`

	// Temperature Temperature parameter used for generating the segment.
	Temperature float32 `json:"temperature"`

	// Text Text content of the segment.
	Text string `json:"text"`

	// Tokens Array of token IDs for the text content.
	Tokens []int `json:"tokens"`
}

// TranscriptionWord defines model for TranscriptionWord.
type TranscriptionWord struct {
	// End End time of the word in seconds.
	End float32 `json:"end"`

	// Start Start time of the word in seconds.
	Start float32 `json:"start"`

	// Word The text content of the word.
	Word string `json:"word"`
}

// TruncationObject Controls for how a thread will be truncated prior to the run. Use this to control the intial context window of the run.
type TruncationObject struct {
	// LastMessages The number of most recent messages from the thread when constructing the context for the run.
	LastMessages *int `json:"last_messages"`

	// Type The truncation strategy to use for the thread. The default is `auto`. If set to `last_messages`, the thread will be truncated to the n most recent messages in the thread. When set to `auto`, messages in the middle of the thread will be dropped to fit the context length of the model, `max_prompt_tokens`.
	Type TruncationObjectType `json:"type"`
}

// TruncationObjectType The truncation strategy to use for the thread. The default is `auto`. If set to `last_messages`, the thread will be truncated to the n most recent messages in the thread. When set to `auto`, messages in the middle of the thread will be dropped to fit the context length of the model, `max_prompt_tokens`.
type TruncationObjectType string

// UpdateVectorStoreRequest defines model for UpdateVectorStoreRequest.
type UpdateVectorStoreRequest struct {
	// ExpiresAfter The expiration policy for a vector store.
	ExpiresAfter *VectorStoreExpirationAfter `json:"expires_after,omitempty"`

	// Metadata Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
	Metadata *map[string]interface{} `json:"metadata"`

	// Name The name of the vector store.
	Name *string `json:"name"`
}

// Upload The Upload object can accept byte chunks in the form of Parts.
type Upload struct {
	// Bytes The intended number of bytes to be uploaded.
	Bytes int `json:"bytes"`

	// CreatedAt The Unix timestamp (in seconds) for when the Upload was created.
	CreatedAt int `json:"created_at"`

	// ExpiresAt The Unix timestamp (in seconds) for when the Upload was created.
	ExpiresAt int `json:"expires_at"`

	// File The `File` object represents a document that has been uploaded to OpenAI.
	File *OpenAIFile `json:"file,omitempty"`

	// Filename The name of the file to be uploaded.
	Filename string `json:"filename"`

	// Id The Upload unique identifier, which can be referenced in API endpoints.
	Id string `json:"id"`

	// Object The object type, which is always "upload".
	Object *UploadObject `json:"object,omitempty"`

	// Purpose The intended purpose of the file. [Please refer here](/docs/api-reference/files/object#files/object-purpose) for acceptable values.
	Purpose string `json:"purpose"`

	// Status The status of the Upload.
	Status UploadStatus `json:"status"`
}

// UploadObject The object type, which is always "upload".
type UploadObject string

// UploadStatus The status of the Upload.
type UploadStatus string

// UploadPart The upload Part represents a chunk of bytes we can add to an Upload object.
type UploadPart struct {
	// CreatedAt The Unix timestamp (in seconds) for when the Part was created.
	CreatedAt int `json:"created_at"`

	// Id The upload Part unique identifier, which can be referenced in API endpoints.
	Id string `json:"id"`

	// Object The object type, which is always `upload.part`.
	Object UploadPartObject `json:"object"`

	// UploadId The ID of the Upload object that this Part was added to.
	UploadId string `json:"upload_id"`
}

// UploadPartObject The object type, which is always `upload.part`.
type UploadPartObject string

// User Represents an individual `user` within an organization.
type User struct {
	// AddedAt The Unix timestamp (in seconds) of when the user was added.
	AddedAt int `json:"added_at"`

	// Email The email address of the user
	Email string `json:"email"`

	// Id The identifier, which can be referenced in API endpoints
	Id string `json:"id"`

	// Name The name of the user
	Name string `json:"name"`

	// Object The object type, which is always `organization.user`
	Object UserObject `json:"object"`

	// Role `owner` or `reader`
	Role UserRole `json:"role"`
}

// UserObject The object type, which is always `organization.user`
type UserObject string

// UserRole `owner` or `reader`
type UserRole string

// UserDeleteResponse defines model for UserDeleteResponse.
type UserDeleteResponse struct {
	Deleted bool                     `json:"deleted"`
	Id      string                   `json:"id"`
	Object  UserDeleteResponseObject `json:"object"`
}

// UserDeleteResponseObject defines model for UserDeleteResponse.Object.
type UserDeleteResponseObject string

// UserListResponse defines model for UserListResponse.
type UserListResponse struct {
	Data    []User                 `json:"data"`
	FirstId string                 `json:"first_id"`
	HasMore bool                   `json:"has_more"`
	LastId  string                 `json:"last_id"`
	Object  UserListResponseObject `json:"object"`
}

// UserListResponseObject defines model for UserListResponse.Object.
type UserListResponseObject string

// UserRoleUpdateRequest defines model for UserRoleUpdateRequest.
type UserRoleUpdateRequest struct {
	// Role `owner` or `reader`
	Role UserRoleUpdateRequestRole `json:"role"`
}

// UserRoleUpdateRequestRole `owner` or `reader`
type UserRoleUpdateRequestRole string

// VectorStoreExpirationAfter The expiration policy for a vector store.
type VectorStoreExpirationAfter struct {
	// Anchor Anchor timestamp after which the expiration policy applies. Supported anchors: `last_active_at`.
	Anchor VectorStoreExpirationAfterAnchor `json:"anchor"`

	// Days The number of days after the anchor time that the vector store will expire.
	Days int `json:"days"`
}

// VectorStoreExpirationAfterAnchor Anchor timestamp after which the expiration policy applies. Supported anchors: `last_active_at`.
type VectorStoreExpirationAfterAnchor string

// VectorStoreFileBatchObject A batch of files attached to a vector store.
type VectorStoreFileBatchObject struct {
	// CreatedAt The Unix timestamp (in seconds) for when the vector store files batch was created.
	CreatedAt  int `json:"created_at"`
	FileCounts struct {
		// Cancelled The number of files that where cancelled.
		Cancelled int `json:"cancelled"`

		// Completed The number of files that have been processed.
		Completed int `json:"completed"`

		// Failed The number of files that have failed to process.
		Failed int `json:"failed"`

		// InProgress The number of files that are currently being processed.
		InProgress int `json:"in_progress"`

		// Total The total number of files.
		Total int `json:"total"`
	} `json:"file_counts"`

	// Id The identifier, which can be referenced in API endpoints.
	Id string `json:"id"`

	// Object The object type, which is always `vector_store.file_batch`.
	Object VectorStoreFileBatchObjectObject `json:"object"`

	// Status The status of the vector store files batch, which can be either `in_progress`, `completed`, `cancelled` or `failed`.
	Status VectorStoreFileBatchObjectStatus `json:"status"`

	// VectorStoreId The ID of the [vector store](/docs/api-reference/vector-stores/object) that the [File](/docs/api-reference/files) is attached to.
	VectorStoreId string `json:"vector_store_id"`
}

// VectorStoreFileBatchObjectObject The object type, which is always `vector_store.file_batch`.
type VectorStoreFileBatchObjectObject string

// VectorStoreFileBatchObjectStatus The status of the vector store files batch, which can be either `in_progress`, `completed`, `cancelled` or `failed`.
type VectorStoreFileBatchObjectStatus string

// VectorStoreFileObject A list of files attached to a vector store.
type VectorStoreFileObject struct {
	// ChunkingStrategy The strategy used to chunk the file.
	ChunkingStrategy *VectorStoreFileObject_ChunkingStrategy `json:"chunking_strategy,omitempty"`

	// CreatedAt The Unix timestamp (in seconds) for when the vector store file was created.
	CreatedAt int `json:"created_at"`

	// Id The identifier, which can be referenced in API endpoints.
	Id string `json:"id"`

	// LastError The last error associated with this vector store file. Will be `null` if there are no errors.
	LastError *struct {
		// Code One of `server_error` or `rate_limit_exceeded`.
		Code VectorStoreFileObjectLastErrorCode `json:"code"`

		// Message A human-readable description of the error.
		Message string `json:"message"`
	} `json:"last_error"`

	// Object The object type, which is always `vector_store.file`.
	Object VectorStoreFileObjectObject `json:"object"`

	// Status The status of the vector store file, which can be either `in_progress`, `completed`, `cancelled`, or `failed`. The status `completed` indicates that the vector store file is ready for use.
	Status VectorStoreFileObjectStatus `json:"status"`

	// UsageBytes The total vector store usage in bytes. Note that this may be different from the original file size.
	UsageBytes int `json:"usage_bytes"`

	// VectorStoreId The ID of the [vector store](/docs/api-reference/vector-stores/object) that the [File](/docs/api-reference/files) is attached to.
	VectorStoreId string `json:"vector_store_id"`
}

// VectorStoreFileObject_ChunkingStrategy The strategy used to chunk the file.
type VectorStoreFileObject_ChunkingStrategy struct {
	union json.RawMessage
}

// VectorStoreFileObjectLastErrorCode One of `server_error` or `rate_limit_exceeded`.
type VectorStoreFileObjectLastErrorCode string

// VectorStoreFileObjectObject The object type, which is always `vector_store.file`.
type VectorStoreFileObjectObject string

// VectorStoreFileObjectStatus The status of the vector store file, which can be either `in_progress`, `completed`, `cancelled`, or `failed`. The status `completed` indicates that the vector store file is ready for use.
type VectorStoreFileObjectStatus string

// VectorStoreObject A vector store is a collection of processed files can be used by the `file_search` tool.
type VectorStoreObject struct {
	// CreatedAt The Unix timestamp (in seconds) for when the vector store was created.
	CreatedAt int `json:"created_at"`

	// ExpiresAfter The expiration policy for a vector store.
	ExpiresAfter *VectorStoreExpirationAfter `json:"expires_after,omitempty"`

	// ExpiresAt The Unix timestamp (in seconds) for when the vector store will expire.
	ExpiresAt  *int `json:"expires_at"`
	FileCounts struct {
		// Cancelled The number of files that were cancelled.
		Cancelled int `json:"cancelled"`

		// Completed The number of files that have been successfully processed.
		Completed int `json:"completed"`

		// Failed The number of files that have failed to process.
		Failed int `json:"failed"`

		// InProgress The number of files that are currently being processed.
		InProgress int `json:"in_progress"`

		// Total The total number of files.
		Total int `json:"total"`
	} `json:"file_counts"`

	// Id The identifier, which can be referenced in API endpoints.
	Id string `json:"id"`

	// LastActiveAt The Unix timestamp (in seconds) for when the vector store was last active.
	LastActiveAt *int `json:"last_active_at"`

	// Metadata Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
	Metadata *map[string]interface{} `json:"metadata"`

	// Name The name of the vector store.
	Name string `json:"name"`

	// Object The object type, which is always `vector_store`.
	Object VectorStoreObjectObject `json:"object"`

	// Status The status of the vector store, which can be either `expired`, `in_progress`, or `completed`. A status of `completed` indicates that the vector store is ready for use.
	Status VectorStoreObjectStatus `json:"status"`

	// UsageBytes The total number of bytes used by the files in the vector store.
	UsageBytes int `json:"usage_bytes"`
}

// VectorStoreObjectObject The object type, which is always `vector_store`.
type VectorStoreObjectObject string

// VectorStoreObjectStatus The status of the vector store, which can be either `expired`, `in_progress`, or `completed`. A status of `completed` indicates that the vector store is ready for use.
type VectorStoreObjectStatus string

// ListAssistantsParams defines parameters for ListAssistants.
type ListAssistantsParams struct {
	// Limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Order Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.
	Order *ListAssistantsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// After A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Before A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list.
	Before *string `form:"before,omitempty" json:"before,omitempty"`
}

// ListAssistantsParamsOrder defines parameters for ListAssistants.
type ListAssistantsParamsOrder string

// ListBatchesParams defines parameters for ListBatches.
type ListBatchesParams struct {
	// After A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// CreateBatchJSONBody defines parameters for CreateBatch.
type CreateBatchJSONBody struct {
	// CompletionWindow The time frame within which the batch should be processed. Currently only `24h` is supported.
	CompletionWindow CreateBatchJSONBodyCompletionWindow `json:"completion_window"`

	// Endpoint The endpoint to be used for all requests in the batch. Currently `/v1/chat/completions`, `/v1/embeddings`, and `/v1/completions` are supported. Note that `/v1/embeddings` batches are also restricted to a maximum of 50,000 embedding inputs across all requests in the batch.
	Endpoint CreateBatchJSONBodyEndpoint `json:"endpoint"`

	// InputFileId The ID of an uploaded file that contains requests for the new batch.
	//
	// See [upload file](/docs/api-reference/files/create) for how to upload a file.
	//
	// Your input file must be formatted as a [JSONL file](/docs/api-reference/batch/request-input), and must be uploaded with the purpose `batch`. The file can contain up to 50,000 requests, and can be up to 200 MB in size.
	InputFileId string `json:"input_file_id"`

	// Metadata Optional custom metadata for the batch.
	Metadata *map[string]string `json:"metadata"`
}

// CreateBatchJSONBodyCompletionWindow defines parameters for CreateBatch.
type CreateBatchJSONBodyCompletionWindow string

// CreateBatchJSONBodyEndpoint defines parameters for CreateBatch.
type CreateBatchJSONBodyEndpoint string

// ListFilesParams defines parameters for ListFiles.
type ListFilesParams struct {
	// Purpose Only return files with the given purpose.
	Purpose *string `form:"purpose,omitempty" json:"purpose,omitempty"`

	// Limit A limit on the number of objects to be returned. Limit can range between 1 and 10,000, and the default is 10,000.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Order Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.
	Order *ListFilesParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// After A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

// ListFilesParamsOrder defines parameters for ListFiles.
type ListFilesParamsOrder string

// ListPaginatedFineTuningJobsParams defines parameters for ListPaginatedFineTuningJobs.
type ListPaginatedFineTuningJobsParams struct {
	// After Identifier for the last job from the previous pagination request.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Limit Number of fine-tuning jobs to retrieve.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// ListFineTuningJobCheckpointsParams defines parameters for ListFineTuningJobCheckpoints.
type ListFineTuningJobCheckpointsParams struct {
	// After Identifier for the last checkpoint ID from the previous pagination request.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Limit Number of checkpoints to retrieve.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// ListFineTuningEventsParams defines parameters for ListFineTuningEvents.
type ListFineTuningEventsParams struct {
	// After Identifier for the last event from the previous pagination request.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Limit Number of events to retrieve.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// ListAuditLogsParams defines parameters for ListAuditLogs.
type ListAuditLogsParams struct {
	// EffectiveAt Return only events whose `effective_at` (Unix seconds) is in this range.
	EffectiveAt *struct {
		// Gt Return only events whose `effective_at` (Unix seconds) is greater than this value.
		Gt *int `json:"gt,omitempty"`

		// Gte Return only events whose `effective_at` (Unix seconds) is greater than or equal to this value.
		Gte *int `json:"gte,omitempty"`

		// Lt Return only events whose `effective_at` (Unix seconds) is less than this value.
		Lt *int `json:"lt,omitempty"`

		// Lte Return only events whose `effective_at` (Unix seconds) is less than or equal to this value.
		Lte *int `json:"lte,omitempty"`
	} `form:"effective_at,omitempty" json:"effective_at,omitempty"`

	// ProjectIds Return only events for these projects.
	ProjectIds *[]string `form:"project_ids[],omitempty" json:"project_ids[],omitempty"`

	// EventTypes Return only events with a `type` in one of these values. For example, `project.created`. For all options, see the documentation for the [audit log object](/docs/api-reference/audit-logs/object).
	EventTypes *[]AuditLogEventType `form:"event_types[],omitempty" json:"event_types[],omitempty"`

	// ActorIds Return only events performed by these actors. Can be a user ID, a service account ID, or an api key tracking ID.
	ActorIds *[]string `form:"actor_ids[],omitempty" json:"actor_ids[],omitempty"`

	// ActorEmails Return only events performed by users with these emails.
	ActorEmails *[]string `form:"actor_emails[],omitempty" json:"actor_emails[],omitempty"`

	// ResourceIds Return only events performed on these targets. For example, a project ID updated.
	ResourceIds *[]string `form:"resource_ids[],omitempty" json:"resource_ids[],omitempty"`

	// Limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// After A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Before A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list.
	Before *string `form:"before,omitempty" json:"before,omitempty"`
}

// ListInvitesParams defines parameters for ListInvites.
type ListInvitesParams struct {
	// Limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// After A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

// ListProjectsParams defines parameters for ListProjects.
type ListProjectsParams struct {
	// Limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// After A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// IncludeArchived If `true` returns all projects including those that have been `archived`. Archived projects are not included by default.
	IncludeArchived *bool `form:"include_archived,omitempty" json:"include_archived,omitempty"`
}

// ListProjectApiKeysParams defines parameters for ListProjectApiKeys.
type ListProjectApiKeysParams struct {
	// Limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// After A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

// ListProjectRateLimitsParams defines parameters for ListProjectRateLimits.
type ListProjectRateLimitsParams struct {
	// Limit A limit on the number of objects to be returned. The default is 100.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// After A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Before A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, beginning with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list.
	Before *string `form:"before,omitempty" json:"before,omitempty"`
}

// ListProjectServiceAccountsParams defines parameters for ListProjectServiceAccounts.
type ListProjectServiceAccountsParams struct {
	// Limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// After A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

// ListProjectUsersParams defines parameters for ListProjectUsers.
type ListProjectUsersParams struct {
	// Limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// After A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

// ListUsersParams defines parameters for ListUsers.
type ListUsersParams struct {
	// Limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// After A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

// ListMessagesParams defines parameters for ListMessages.
type ListMessagesParams struct {
	// Limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Order Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.
	Order *ListMessagesParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// After A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Before A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list.
	Before *string `form:"before,omitempty" json:"before,omitempty"`

	// RunId Filter messages by the run ID that generated them.
	RunId *string `form:"run_id,omitempty" json:"run_id,omitempty"`
}

// ListMessagesParamsOrder defines parameters for ListMessages.
type ListMessagesParamsOrder string

// ListRunsParams defines parameters for ListRuns.
type ListRunsParams struct {
	// Limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Order Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.
	Order *ListRunsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// After A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Before A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list.
	Before *string `form:"before,omitempty" json:"before,omitempty"`
}

// ListRunsParamsOrder defines parameters for ListRuns.
type ListRunsParamsOrder string

// CreateRunParams defines parameters for CreateRun.
type CreateRunParams struct {
	// Include A list of additional fields to include in the response. Currently the only supported value is `step_details.tool_calls[*].file_search.results[*].content` to fetch the file search result content.
	//
	// See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information.
	Include *[]CreateRunParamsInclude `form:"include[],omitempty" json:"include[],omitempty"`
}

// CreateRunParamsInclude defines parameters for CreateRun.
type CreateRunParamsInclude string

// ListRunStepsParams defines parameters for ListRunSteps.
type ListRunStepsParams struct {
	// Limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Order Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.
	Order *ListRunStepsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// After A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Before A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list.
	Before *string `form:"before,omitempty" json:"before,omitempty"`

	// Include A list of additional fields to include in the response. Currently the only supported value is `step_details.tool_calls[*].file_search.results[*].content` to fetch the file search result content.
	//
	// See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information.
	Include *[]ListRunStepsParamsInclude `form:"include[],omitempty" json:"include[],omitempty"`
}

// ListRunStepsParamsOrder defines parameters for ListRunSteps.
type ListRunStepsParamsOrder string

// ListRunStepsParamsInclude defines parameters for ListRunSteps.
type ListRunStepsParamsInclude string

// GetRunStepParams defines parameters for GetRunStep.
type GetRunStepParams struct {
	// Include A list of additional fields to include in the response. Currently the only supported value is `step_details.tool_calls[*].file_search.results[*].content` to fetch the file search result content.
	//
	// See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information.
	Include *[]GetRunStepParamsInclude `form:"include[],omitempty" json:"include[],omitempty"`
}

// GetRunStepParamsInclude defines parameters for GetRunStep.
type GetRunStepParamsInclude string

// ListVectorStoresParams defines parameters for ListVectorStores.
type ListVectorStoresParams struct {
	// Limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Order Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.
	Order *ListVectorStoresParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// After A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Before A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list.
	Before *string `form:"before,omitempty" json:"before,omitempty"`
}

// ListVectorStoresParamsOrder defines parameters for ListVectorStores.
type ListVectorStoresParamsOrder string

// ListFilesInVectorStoreBatchParams defines parameters for ListFilesInVectorStoreBatch.
type ListFilesInVectorStoreBatchParams struct {
	// Limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Order Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.
	Order *ListFilesInVectorStoreBatchParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// After A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Before A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list.
	Before *string `form:"before,omitempty" json:"before,omitempty"`

	// Filter Filter by file status. One of `in_progress`, `completed`, `failed`, `cancelled`.
	Filter *ListFilesInVectorStoreBatchParamsFilter `form:"filter,omitempty" json:"filter,omitempty"`
}

// ListFilesInVectorStoreBatchParamsOrder defines parameters for ListFilesInVectorStoreBatch.
type ListFilesInVectorStoreBatchParamsOrder string

// ListFilesInVectorStoreBatchParamsFilter defines parameters for ListFilesInVectorStoreBatch.
type ListFilesInVectorStoreBatchParamsFilter string

// ListVectorStoreFilesParams defines parameters for ListVectorStoreFiles.
type ListVectorStoreFilesParams struct {
	// Limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Order Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.
	Order *ListVectorStoreFilesParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// After A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Before A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list.
	Before *string `form:"before,omitempty" json:"before,omitempty"`

	// Filter Filter by file status. One of `in_progress`, `completed`, `failed`, `cancelled`.
	Filter *ListVectorStoreFilesParamsFilter `form:"filter,omitempty" json:"filter,omitempty"`
}

// ListVectorStoreFilesParamsOrder defines parameters for ListVectorStoreFiles.
type ListVectorStoreFilesParamsOrder string

// ListVectorStoreFilesParamsFilter defines parameters for ListVectorStoreFiles.
type ListVectorStoreFilesParamsFilter string

// CreateAssistantJSONRequestBody defines body for CreateAssistant for application/json ContentType.
type CreateAssistantJSONRequestBody = CreateAssistantRequest

// ModifyAssistantJSONRequestBody defines body for ModifyAssistant for application/json ContentType.
type ModifyAssistantJSONRequestBody = ModifyAssistantRequest

// CreateSpeechJSONRequestBody defines body for CreateSpeech for application/json ContentType.
type CreateSpeechJSONRequestBody = CreateSpeechRequest

// CreateTranscriptionMultipartRequestBody defines body for CreateTranscription for multipart/form-data ContentType.
type CreateTranscriptionMultipartRequestBody = CreateTranscriptionRequest

// CreateTranslationMultipartRequestBody defines body for CreateTranslation for multipart/form-data ContentType.
type CreateTranslationMultipartRequestBody = CreateTranslationRequest

// CreateBatchJSONRequestBody defines body for CreateBatch for application/json ContentType.
type CreateBatchJSONRequestBody CreateBatchJSONBody

// CreateChatCompletionJSONRequestBody defines body for CreateChatCompletion for application/json ContentType.
type CreateChatCompletionJSONRequestBody = CreateChatCompletionRequest

// CreateCompletionJSONRequestBody defines body for CreateCompletion for application/json ContentType.
type CreateCompletionJSONRequestBody = CreateCompletionRequest

// CreateEmbeddingJSONRequestBody defines body for CreateEmbedding for application/json ContentType.
type CreateEmbeddingJSONRequestBody = CreateEmbeddingRequest

// CreateFileMultipartRequestBody defines body for CreateFile for multipart/form-data ContentType.
type CreateFileMultipartRequestBody = CreateFileRequest

// CreateFineTuningJobJSONRequestBody defines body for CreateFineTuningJob for application/json ContentType.
type CreateFineTuningJobJSONRequestBody = CreateFineTuningJobRequest

// CreateImageEditMultipartRequestBody defines body for CreateImageEdit for multipart/form-data ContentType.
type CreateImageEditMultipartRequestBody = CreateImageEditRequest

// CreateImageJSONRequestBody defines body for CreateImage for application/json ContentType.
type CreateImageJSONRequestBody = CreateImageRequest

// CreateImageVariationMultipartRequestBody defines body for CreateImageVariation for multipart/form-data ContentType.
type CreateImageVariationMultipartRequestBody = CreateImageVariationRequest

// CreateModerationJSONRequestBody defines body for CreateModeration for application/json ContentType.
type CreateModerationJSONRequestBody = CreateModerationRequest

// InviteUserJSONRequestBody defines body for InviteUser for application/json ContentType.
type InviteUserJSONRequestBody = InviteRequest

// CreateProjectJSONRequestBody defines body for CreateProject for application/json ContentType.
type CreateProjectJSONRequestBody = ProjectCreateRequest

// ModifyProjectJSONRequestBody defines body for ModifyProject for application/json ContentType.
type ModifyProjectJSONRequestBody = ProjectUpdateRequest

// UpdateProjectRateLimitsJSONRequestBody defines body for UpdateProjectRateLimits for application/json ContentType.
type UpdateProjectRateLimitsJSONRequestBody = ProjectRateLimitUpdateRequest

// CreateProjectServiceAccountJSONRequestBody defines body for CreateProjectServiceAccount for application/json ContentType.
type CreateProjectServiceAccountJSONRequestBody = ProjectServiceAccountCreateRequest

// CreateProjectUserJSONRequestBody defines body for CreateProjectUser for application/json ContentType.
type CreateProjectUserJSONRequestBody = ProjectUserCreateRequest

// ModifyProjectUserJSONRequestBody defines body for ModifyProjectUser for application/json ContentType.
type ModifyProjectUserJSONRequestBody = ProjectUserUpdateRequest

// ModifyUserJSONRequestBody defines body for ModifyUser for application/json ContentType.
type ModifyUserJSONRequestBody = UserRoleUpdateRequest

// CreateThreadJSONRequestBody defines body for CreateThread for application/json ContentType.
type CreateThreadJSONRequestBody = CreateThreadRequest

// CreateThreadAndRunJSONRequestBody defines body for CreateThreadAndRun for application/json ContentType.
type CreateThreadAndRunJSONRequestBody = CreateThreadAndRunRequest

// ModifyThreadJSONRequestBody defines body for ModifyThread for application/json ContentType.
type ModifyThreadJSONRequestBody = ModifyThreadRequest

// CreateMessageJSONRequestBody defines body for CreateMessage for application/json ContentType.
type CreateMessageJSONRequestBody = CreateMessageRequest

// ModifyMessageJSONRequestBody defines body for ModifyMessage for application/json ContentType.
type ModifyMessageJSONRequestBody = ModifyMessageRequest

// CreateRunJSONRequestBody defines body for CreateRun for application/json ContentType.
type CreateRunJSONRequestBody = CreateRunRequest

// ModifyRunJSONRequestBody defines body for ModifyRun for application/json ContentType.
type ModifyRunJSONRequestBody = ModifyRunRequest

// SubmitToolOuputsToRunJSONRequestBody defines body for SubmitToolOuputsToRun for application/json ContentType.
type SubmitToolOuputsToRunJSONRequestBody = SubmitToolOutputsRunRequest

// CreateUploadJSONRequestBody defines body for CreateUpload for application/json ContentType.
type CreateUploadJSONRequestBody = CreateUploadRequest

// CompleteUploadJSONRequestBody defines body for CompleteUpload for application/json ContentType.
type CompleteUploadJSONRequestBody = CompleteUploadRequest

// AddUploadPartMultipartRequestBody defines body for AddUploadPart for multipart/form-data ContentType.
type AddUploadPartMultipartRequestBody = AddUploadPartRequest

// CreateVectorStoreJSONRequestBody defines body for CreateVectorStore for application/json ContentType.
type CreateVectorStoreJSONRequestBody = CreateVectorStoreRequest

// ModifyVectorStoreJSONRequestBody defines body for ModifyVectorStore for application/json ContentType.
type ModifyVectorStoreJSONRequestBody = UpdateVectorStoreRequest

// CreateVectorStoreFileBatchJSONRequestBody defines body for CreateVectorStoreFileBatch for application/json ContentType.
type CreateVectorStoreFileBatchJSONRequestBody = CreateVectorStoreFileBatchRequest

// CreateVectorStoreFileJSONRequestBody defines body for CreateVectorStoreFile for application/json ContentType.
type CreateVectorStoreFileJSONRequestBody = CreateVectorStoreFileRequest

// AsAssistantToolsCode returns the union data inside the AssistantObject_Tools_Item as a AssistantToolsCode
func (t AssistantObject_Tools_Item) AsAssistantToolsCode() (AssistantToolsCode, error) {
	var body AssistantToolsCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssistantToolsCode overwrites any union data inside the AssistantObject_Tools_Item as the provided AssistantToolsCode
func (t *AssistantObject_Tools_Item) FromAssistantToolsCode(v AssistantToolsCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssistantToolsCode performs a merge with any union data inside the AssistantObject_Tools_Item, using the provided AssistantToolsCode
func (t *AssistantObject_Tools_Item) MergeAssistantToolsCode(v AssistantToolsCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAssistantToolsFileSearch returns the union data inside the AssistantObject_Tools_Item as a AssistantToolsFileSearch
func (t AssistantObject_Tools_Item) AsAssistantToolsFileSearch() (AssistantToolsFileSearch, error) {
	var body AssistantToolsFileSearch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssistantToolsFileSearch overwrites any union data inside the AssistantObject_Tools_Item as the provided AssistantToolsFileSearch
func (t *AssistantObject_Tools_Item) FromAssistantToolsFileSearch(v AssistantToolsFileSearch) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssistantToolsFileSearch performs a merge with any union data inside the AssistantObject_Tools_Item, using the provided AssistantToolsFileSearch
func (t *AssistantObject_Tools_Item) MergeAssistantToolsFileSearch(v AssistantToolsFileSearch) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAssistantToolsFunction returns the union data inside the AssistantObject_Tools_Item as a AssistantToolsFunction
func (t AssistantObject_Tools_Item) AsAssistantToolsFunction() (AssistantToolsFunction, error) {
	var body AssistantToolsFunction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssistantToolsFunction overwrites any union data inside the AssistantObject_Tools_Item as the provided AssistantToolsFunction
func (t *AssistantObject_Tools_Item) FromAssistantToolsFunction(v AssistantToolsFunction) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssistantToolsFunction performs a merge with any union data inside the AssistantObject_Tools_Item, using the provided AssistantToolsFunction
func (t *AssistantObject_Tools_Item) MergeAssistantToolsFunction(v AssistantToolsFunction) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AssistantObject_Tools_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AssistantObject_Tools_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAssistantsApiResponseFormatOption0 returns the union data inside the AssistantsApiResponseFormatOption as a AssistantsApiResponseFormatOption0
func (t AssistantsApiResponseFormatOption) AsAssistantsApiResponseFormatOption0() (AssistantsApiResponseFormatOption0, error) {
	var body AssistantsApiResponseFormatOption0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssistantsApiResponseFormatOption0 overwrites any union data inside the AssistantsApiResponseFormatOption as the provided AssistantsApiResponseFormatOption0
func (t *AssistantsApiResponseFormatOption) FromAssistantsApiResponseFormatOption0(v AssistantsApiResponseFormatOption0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssistantsApiResponseFormatOption0 performs a merge with any union data inside the AssistantsApiResponseFormatOption, using the provided AssistantsApiResponseFormatOption0
func (t *AssistantsApiResponseFormatOption) MergeAssistantsApiResponseFormatOption0(v AssistantsApiResponseFormatOption0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResponseFormatText returns the union data inside the AssistantsApiResponseFormatOption as a ResponseFormatText
func (t AssistantsApiResponseFormatOption) AsResponseFormatText() (ResponseFormatText, error) {
	var body ResponseFormatText
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResponseFormatText overwrites any union data inside the AssistantsApiResponseFormatOption as the provided ResponseFormatText
func (t *AssistantsApiResponseFormatOption) FromResponseFormatText(v ResponseFormatText) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResponseFormatText performs a merge with any union data inside the AssistantsApiResponseFormatOption, using the provided ResponseFormatText
func (t *AssistantsApiResponseFormatOption) MergeResponseFormatText(v ResponseFormatText) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResponseFormatJsonObject returns the union data inside the AssistantsApiResponseFormatOption as a ResponseFormatJsonObject
func (t AssistantsApiResponseFormatOption) AsResponseFormatJsonObject() (ResponseFormatJsonObject, error) {
	var body ResponseFormatJsonObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResponseFormatJsonObject overwrites any union data inside the AssistantsApiResponseFormatOption as the provided ResponseFormatJsonObject
func (t *AssistantsApiResponseFormatOption) FromResponseFormatJsonObject(v ResponseFormatJsonObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResponseFormatJsonObject performs a merge with any union data inside the AssistantsApiResponseFormatOption, using the provided ResponseFormatJsonObject
func (t *AssistantsApiResponseFormatOption) MergeResponseFormatJsonObject(v ResponseFormatJsonObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResponseFormatJsonSchema returns the union data inside the AssistantsApiResponseFormatOption as a ResponseFormatJsonSchema
func (t AssistantsApiResponseFormatOption) AsResponseFormatJsonSchema() (ResponseFormatJsonSchema, error) {
	var body ResponseFormatJsonSchema
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResponseFormatJsonSchema overwrites any union data inside the AssistantsApiResponseFormatOption as the provided ResponseFormatJsonSchema
func (t *AssistantsApiResponseFormatOption) FromResponseFormatJsonSchema(v ResponseFormatJsonSchema) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResponseFormatJsonSchema performs a merge with any union data inside the AssistantsApiResponseFormatOption, using the provided ResponseFormatJsonSchema
func (t *AssistantsApiResponseFormatOption) MergeResponseFormatJsonSchema(v ResponseFormatJsonSchema) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AssistantsApiResponseFormatOption) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AssistantsApiResponseFormatOption) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAssistantsApiToolChoiceOption0 returns the union data inside the AssistantsApiToolChoiceOption as a AssistantsApiToolChoiceOption0
func (t AssistantsApiToolChoiceOption) AsAssistantsApiToolChoiceOption0() (AssistantsApiToolChoiceOption0, error) {
	var body AssistantsApiToolChoiceOption0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssistantsApiToolChoiceOption0 overwrites any union data inside the AssistantsApiToolChoiceOption as the provided AssistantsApiToolChoiceOption0
func (t *AssistantsApiToolChoiceOption) FromAssistantsApiToolChoiceOption0(v AssistantsApiToolChoiceOption0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssistantsApiToolChoiceOption0 performs a merge with any union data inside the AssistantsApiToolChoiceOption, using the provided AssistantsApiToolChoiceOption0
func (t *AssistantsApiToolChoiceOption) MergeAssistantsApiToolChoiceOption0(v AssistantsApiToolChoiceOption0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAssistantsNamedToolChoice returns the union data inside the AssistantsApiToolChoiceOption as a AssistantsNamedToolChoice
func (t AssistantsApiToolChoiceOption) AsAssistantsNamedToolChoice() (AssistantsNamedToolChoice, error) {
	var body AssistantsNamedToolChoice
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssistantsNamedToolChoice overwrites any union data inside the AssistantsApiToolChoiceOption as the provided AssistantsNamedToolChoice
func (t *AssistantsApiToolChoiceOption) FromAssistantsNamedToolChoice(v AssistantsNamedToolChoice) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssistantsNamedToolChoice performs a merge with any union data inside the AssistantsApiToolChoiceOption, using the provided AssistantsNamedToolChoice
func (t *AssistantsApiToolChoiceOption) MergeAssistantsNamedToolChoice(v AssistantsNamedToolChoice) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AssistantsApiToolChoiceOption) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AssistantsApiToolChoiceOption) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsChatCompletionRequestAssistantMessageContent0 returns the union data inside the ChatCompletionRequestAssistantMessage_Content as a ChatCompletionRequestAssistantMessageContent0
func (t ChatCompletionRequestAssistantMessage_Content) AsChatCompletionRequestAssistantMessageContent0() (ChatCompletionRequestAssistantMessageContent0, error) {
	var body ChatCompletionRequestAssistantMessageContent0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestAssistantMessageContent0 overwrites any union data inside the ChatCompletionRequestAssistantMessage_Content as the provided ChatCompletionRequestAssistantMessageContent0
func (t *ChatCompletionRequestAssistantMessage_Content) FromChatCompletionRequestAssistantMessageContent0(v ChatCompletionRequestAssistantMessageContent0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestAssistantMessageContent0 performs a merge with any union data inside the ChatCompletionRequestAssistantMessage_Content, using the provided ChatCompletionRequestAssistantMessageContent0
func (t *ChatCompletionRequestAssistantMessage_Content) MergeChatCompletionRequestAssistantMessageContent0(v ChatCompletionRequestAssistantMessageContent0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChatCompletionRequestAssistantMessageContent1 returns the union data inside the ChatCompletionRequestAssistantMessage_Content as a ChatCompletionRequestAssistantMessageContent1
func (t ChatCompletionRequestAssistantMessage_Content) AsChatCompletionRequestAssistantMessageContent1() (ChatCompletionRequestAssistantMessageContent1, error) {
	var body ChatCompletionRequestAssistantMessageContent1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestAssistantMessageContent1 overwrites any union data inside the ChatCompletionRequestAssistantMessage_Content as the provided ChatCompletionRequestAssistantMessageContent1
func (t *ChatCompletionRequestAssistantMessage_Content) FromChatCompletionRequestAssistantMessageContent1(v ChatCompletionRequestAssistantMessageContent1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestAssistantMessageContent1 performs a merge with any union data inside the ChatCompletionRequestAssistantMessage_Content, using the provided ChatCompletionRequestAssistantMessageContent1
func (t *ChatCompletionRequestAssistantMessage_Content) MergeChatCompletionRequestAssistantMessageContent1(v ChatCompletionRequestAssistantMessageContent1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ChatCompletionRequestAssistantMessage_Content) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ChatCompletionRequestAssistantMessage_Content) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsChatCompletionRequestMessageContentPartText returns the union data inside the ChatCompletionRequestAssistantMessageContentPart as a ChatCompletionRequestMessageContentPartText
func (t ChatCompletionRequestAssistantMessageContentPart) AsChatCompletionRequestMessageContentPartText() (ChatCompletionRequestMessageContentPartText, error) {
	var body ChatCompletionRequestMessageContentPartText
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestMessageContentPartText overwrites any union data inside the ChatCompletionRequestAssistantMessageContentPart as the provided ChatCompletionRequestMessageContentPartText
func (t *ChatCompletionRequestAssistantMessageContentPart) FromChatCompletionRequestMessageContentPartText(v ChatCompletionRequestMessageContentPartText) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestMessageContentPartText performs a merge with any union data inside the ChatCompletionRequestAssistantMessageContentPart, using the provided ChatCompletionRequestMessageContentPartText
func (t *ChatCompletionRequestAssistantMessageContentPart) MergeChatCompletionRequestMessageContentPartText(v ChatCompletionRequestMessageContentPartText) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChatCompletionRequestMessageContentPartRefusal returns the union data inside the ChatCompletionRequestAssistantMessageContentPart as a ChatCompletionRequestMessageContentPartRefusal
func (t ChatCompletionRequestAssistantMessageContentPart) AsChatCompletionRequestMessageContentPartRefusal() (ChatCompletionRequestMessageContentPartRefusal, error) {
	var body ChatCompletionRequestMessageContentPartRefusal
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestMessageContentPartRefusal overwrites any union data inside the ChatCompletionRequestAssistantMessageContentPart as the provided ChatCompletionRequestMessageContentPartRefusal
func (t *ChatCompletionRequestAssistantMessageContentPart) FromChatCompletionRequestMessageContentPartRefusal(v ChatCompletionRequestMessageContentPartRefusal) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestMessageContentPartRefusal performs a merge with any union data inside the ChatCompletionRequestAssistantMessageContentPart, using the provided ChatCompletionRequestMessageContentPartRefusal
func (t *ChatCompletionRequestAssistantMessageContentPart) MergeChatCompletionRequestMessageContentPartRefusal(v ChatCompletionRequestMessageContentPartRefusal) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ChatCompletionRequestAssistantMessageContentPart) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ChatCompletionRequestAssistantMessageContentPart) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsChatCompletionRequestSystemMessage returns the union data inside the ChatCompletionRequestMessage as a ChatCompletionRequestSystemMessage
func (t ChatCompletionRequestMessage) AsChatCompletionRequestSystemMessage() (ChatCompletionRequestSystemMessage, error) {
	var body ChatCompletionRequestSystemMessage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestSystemMessage overwrites any union data inside the ChatCompletionRequestMessage as the provided ChatCompletionRequestSystemMessage
func (t *ChatCompletionRequestMessage) FromChatCompletionRequestSystemMessage(v ChatCompletionRequestSystemMessage) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestSystemMessage performs a merge with any union data inside the ChatCompletionRequestMessage, using the provided ChatCompletionRequestSystemMessage
func (t *ChatCompletionRequestMessage) MergeChatCompletionRequestSystemMessage(v ChatCompletionRequestSystemMessage) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChatCompletionRequestUserMessage returns the union data inside the ChatCompletionRequestMessage as a ChatCompletionRequestUserMessage
func (t ChatCompletionRequestMessage) AsChatCompletionRequestUserMessage() (ChatCompletionRequestUserMessage, error) {
	var body ChatCompletionRequestUserMessage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestUserMessage overwrites any union data inside the ChatCompletionRequestMessage as the provided ChatCompletionRequestUserMessage
func (t *ChatCompletionRequestMessage) FromChatCompletionRequestUserMessage(v ChatCompletionRequestUserMessage) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestUserMessage performs a merge with any union data inside the ChatCompletionRequestMessage, using the provided ChatCompletionRequestUserMessage
func (t *ChatCompletionRequestMessage) MergeChatCompletionRequestUserMessage(v ChatCompletionRequestUserMessage) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChatCompletionRequestAssistantMessage returns the union data inside the ChatCompletionRequestMessage as a ChatCompletionRequestAssistantMessage
func (t ChatCompletionRequestMessage) AsChatCompletionRequestAssistantMessage() (ChatCompletionRequestAssistantMessage, error) {
	var body ChatCompletionRequestAssistantMessage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestAssistantMessage overwrites any union data inside the ChatCompletionRequestMessage as the provided ChatCompletionRequestAssistantMessage
func (t *ChatCompletionRequestMessage) FromChatCompletionRequestAssistantMessage(v ChatCompletionRequestAssistantMessage) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestAssistantMessage performs a merge with any union data inside the ChatCompletionRequestMessage, using the provided ChatCompletionRequestAssistantMessage
func (t *ChatCompletionRequestMessage) MergeChatCompletionRequestAssistantMessage(v ChatCompletionRequestAssistantMessage) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChatCompletionRequestToolMessage returns the union data inside the ChatCompletionRequestMessage as a ChatCompletionRequestToolMessage
func (t ChatCompletionRequestMessage) AsChatCompletionRequestToolMessage() (ChatCompletionRequestToolMessage, error) {
	var body ChatCompletionRequestToolMessage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestToolMessage overwrites any union data inside the ChatCompletionRequestMessage as the provided ChatCompletionRequestToolMessage
func (t *ChatCompletionRequestMessage) FromChatCompletionRequestToolMessage(v ChatCompletionRequestToolMessage) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestToolMessage performs a merge with any union data inside the ChatCompletionRequestMessage, using the provided ChatCompletionRequestToolMessage
func (t *ChatCompletionRequestMessage) MergeChatCompletionRequestToolMessage(v ChatCompletionRequestToolMessage) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChatCompletionRequestFunctionMessage returns the union data inside the ChatCompletionRequestMessage as a ChatCompletionRequestFunctionMessage
func (t ChatCompletionRequestMessage) AsChatCompletionRequestFunctionMessage() (ChatCompletionRequestFunctionMessage, error) {
	var body ChatCompletionRequestFunctionMessage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestFunctionMessage overwrites any union data inside the ChatCompletionRequestMessage as the provided ChatCompletionRequestFunctionMessage
func (t *ChatCompletionRequestMessage) FromChatCompletionRequestFunctionMessage(v ChatCompletionRequestFunctionMessage) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestFunctionMessage performs a merge with any union data inside the ChatCompletionRequestMessage, using the provided ChatCompletionRequestFunctionMessage
func (t *ChatCompletionRequestMessage) MergeChatCompletionRequestFunctionMessage(v ChatCompletionRequestFunctionMessage) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ChatCompletionRequestMessage) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ChatCompletionRequestMessage) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsChatCompletionRequestSystemMessageContent0 returns the union data inside the ChatCompletionRequestSystemMessage_Content as a ChatCompletionRequestSystemMessageContent0
func (t ChatCompletionRequestSystemMessage_Content) AsChatCompletionRequestSystemMessageContent0() (ChatCompletionRequestSystemMessageContent0, error) {
	var body ChatCompletionRequestSystemMessageContent0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestSystemMessageContent0 overwrites any union data inside the ChatCompletionRequestSystemMessage_Content as the provided ChatCompletionRequestSystemMessageContent0
func (t *ChatCompletionRequestSystemMessage_Content) FromChatCompletionRequestSystemMessageContent0(v ChatCompletionRequestSystemMessageContent0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestSystemMessageContent0 performs a merge with any union data inside the ChatCompletionRequestSystemMessage_Content, using the provided ChatCompletionRequestSystemMessageContent0
func (t *ChatCompletionRequestSystemMessage_Content) MergeChatCompletionRequestSystemMessageContent0(v ChatCompletionRequestSystemMessageContent0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChatCompletionRequestSystemMessageContent1 returns the union data inside the ChatCompletionRequestSystemMessage_Content as a ChatCompletionRequestSystemMessageContent1
func (t ChatCompletionRequestSystemMessage_Content) AsChatCompletionRequestSystemMessageContent1() (ChatCompletionRequestSystemMessageContent1, error) {
	var body ChatCompletionRequestSystemMessageContent1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestSystemMessageContent1 overwrites any union data inside the ChatCompletionRequestSystemMessage_Content as the provided ChatCompletionRequestSystemMessageContent1
func (t *ChatCompletionRequestSystemMessage_Content) FromChatCompletionRequestSystemMessageContent1(v ChatCompletionRequestSystemMessageContent1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestSystemMessageContent1 performs a merge with any union data inside the ChatCompletionRequestSystemMessage_Content, using the provided ChatCompletionRequestSystemMessageContent1
func (t *ChatCompletionRequestSystemMessage_Content) MergeChatCompletionRequestSystemMessageContent1(v ChatCompletionRequestSystemMessageContent1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ChatCompletionRequestSystemMessage_Content) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ChatCompletionRequestSystemMessage_Content) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsChatCompletionRequestMessageContentPartText returns the union data inside the ChatCompletionRequestSystemMessageContentPart as a ChatCompletionRequestMessageContentPartText
func (t ChatCompletionRequestSystemMessageContentPart) AsChatCompletionRequestMessageContentPartText() (ChatCompletionRequestMessageContentPartText, error) {
	var body ChatCompletionRequestMessageContentPartText
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestMessageContentPartText overwrites any union data inside the ChatCompletionRequestSystemMessageContentPart as the provided ChatCompletionRequestMessageContentPartText
func (t *ChatCompletionRequestSystemMessageContentPart) FromChatCompletionRequestMessageContentPartText(v ChatCompletionRequestMessageContentPartText) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestMessageContentPartText performs a merge with any union data inside the ChatCompletionRequestSystemMessageContentPart, using the provided ChatCompletionRequestMessageContentPartText
func (t *ChatCompletionRequestSystemMessageContentPart) MergeChatCompletionRequestMessageContentPartText(v ChatCompletionRequestMessageContentPartText) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ChatCompletionRequestSystemMessageContentPart) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ChatCompletionRequestSystemMessageContentPart) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsChatCompletionRequestToolMessageContent0 returns the union data inside the ChatCompletionRequestToolMessage_Content as a ChatCompletionRequestToolMessageContent0
func (t ChatCompletionRequestToolMessage_Content) AsChatCompletionRequestToolMessageContent0() (ChatCompletionRequestToolMessageContent0, error) {
	var body ChatCompletionRequestToolMessageContent0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestToolMessageContent0 overwrites any union data inside the ChatCompletionRequestToolMessage_Content as the provided ChatCompletionRequestToolMessageContent0
func (t *ChatCompletionRequestToolMessage_Content) FromChatCompletionRequestToolMessageContent0(v ChatCompletionRequestToolMessageContent0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestToolMessageContent0 performs a merge with any union data inside the ChatCompletionRequestToolMessage_Content, using the provided ChatCompletionRequestToolMessageContent0
func (t *ChatCompletionRequestToolMessage_Content) MergeChatCompletionRequestToolMessageContent0(v ChatCompletionRequestToolMessageContent0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChatCompletionRequestToolMessageContent1 returns the union data inside the ChatCompletionRequestToolMessage_Content as a ChatCompletionRequestToolMessageContent1
func (t ChatCompletionRequestToolMessage_Content) AsChatCompletionRequestToolMessageContent1() (ChatCompletionRequestToolMessageContent1, error) {
	var body ChatCompletionRequestToolMessageContent1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestToolMessageContent1 overwrites any union data inside the ChatCompletionRequestToolMessage_Content as the provided ChatCompletionRequestToolMessageContent1
func (t *ChatCompletionRequestToolMessage_Content) FromChatCompletionRequestToolMessageContent1(v ChatCompletionRequestToolMessageContent1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestToolMessageContent1 performs a merge with any union data inside the ChatCompletionRequestToolMessage_Content, using the provided ChatCompletionRequestToolMessageContent1
func (t *ChatCompletionRequestToolMessage_Content) MergeChatCompletionRequestToolMessageContent1(v ChatCompletionRequestToolMessageContent1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ChatCompletionRequestToolMessage_Content) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ChatCompletionRequestToolMessage_Content) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsChatCompletionRequestMessageContentPartText returns the union data inside the ChatCompletionRequestToolMessageContentPart as a ChatCompletionRequestMessageContentPartText
func (t ChatCompletionRequestToolMessageContentPart) AsChatCompletionRequestMessageContentPartText() (ChatCompletionRequestMessageContentPartText, error) {
	var body ChatCompletionRequestMessageContentPartText
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestMessageContentPartText overwrites any union data inside the ChatCompletionRequestToolMessageContentPart as the provided ChatCompletionRequestMessageContentPartText
func (t *ChatCompletionRequestToolMessageContentPart) FromChatCompletionRequestMessageContentPartText(v ChatCompletionRequestMessageContentPartText) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestMessageContentPartText performs a merge with any union data inside the ChatCompletionRequestToolMessageContentPart, using the provided ChatCompletionRequestMessageContentPartText
func (t *ChatCompletionRequestToolMessageContentPart) MergeChatCompletionRequestMessageContentPartText(v ChatCompletionRequestMessageContentPartText) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ChatCompletionRequestToolMessageContentPart) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ChatCompletionRequestToolMessageContentPart) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsChatCompletionRequestUserMessageContent0 returns the union data inside the ChatCompletionRequestUserMessage_Content as a ChatCompletionRequestUserMessageContent0
func (t ChatCompletionRequestUserMessage_Content) AsChatCompletionRequestUserMessageContent0() (ChatCompletionRequestUserMessageContent0, error) {
	var body ChatCompletionRequestUserMessageContent0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestUserMessageContent0 overwrites any union data inside the ChatCompletionRequestUserMessage_Content as the provided ChatCompletionRequestUserMessageContent0
func (t *ChatCompletionRequestUserMessage_Content) FromChatCompletionRequestUserMessageContent0(v ChatCompletionRequestUserMessageContent0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestUserMessageContent0 performs a merge with any union data inside the ChatCompletionRequestUserMessage_Content, using the provided ChatCompletionRequestUserMessageContent0
func (t *ChatCompletionRequestUserMessage_Content) MergeChatCompletionRequestUserMessageContent0(v ChatCompletionRequestUserMessageContent0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChatCompletionRequestUserMessageContent1 returns the union data inside the ChatCompletionRequestUserMessage_Content as a ChatCompletionRequestUserMessageContent1
func (t ChatCompletionRequestUserMessage_Content) AsChatCompletionRequestUserMessageContent1() (ChatCompletionRequestUserMessageContent1, error) {
	var body ChatCompletionRequestUserMessageContent1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestUserMessageContent1 overwrites any union data inside the ChatCompletionRequestUserMessage_Content as the provided ChatCompletionRequestUserMessageContent1
func (t *ChatCompletionRequestUserMessage_Content) FromChatCompletionRequestUserMessageContent1(v ChatCompletionRequestUserMessageContent1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestUserMessageContent1 performs a merge with any union data inside the ChatCompletionRequestUserMessage_Content, using the provided ChatCompletionRequestUserMessageContent1
func (t *ChatCompletionRequestUserMessage_Content) MergeChatCompletionRequestUserMessageContent1(v ChatCompletionRequestUserMessageContent1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ChatCompletionRequestUserMessage_Content) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ChatCompletionRequestUserMessage_Content) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsChatCompletionRequestMessageContentPartText returns the union data inside the ChatCompletionRequestUserMessageContentPart as a ChatCompletionRequestMessageContentPartText
func (t ChatCompletionRequestUserMessageContentPart) AsChatCompletionRequestMessageContentPartText() (ChatCompletionRequestMessageContentPartText, error) {
	var body ChatCompletionRequestMessageContentPartText
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestMessageContentPartText overwrites any union data inside the ChatCompletionRequestUserMessageContentPart as the provided ChatCompletionRequestMessageContentPartText
func (t *ChatCompletionRequestUserMessageContentPart) FromChatCompletionRequestMessageContentPartText(v ChatCompletionRequestMessageContentPartText) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestMessageContentPartText performs a merge with any union data inside the ChatCompletionRequestUserMessageContentPart, using the provided ChatCompletionRequestMessageContentPartText
func (t *ChatCompletionRequestUserMessageContentPart) MergeChatCompletionRequestMessageContentPartText(v ChatCompletionRequestMessageContentPartText) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChatCompletionRequestMessageContentPartImage returns the union data inside the ChatCompletionRequestUserMessageContentPart as a ChatCompletionRequestMessageContentPartImage
func (t ChatCompletionRequestUserMessageContentPart) AsChatCompletionRequestMessageContentPartImage() (ChatCompletionRequestMessageContentPartImage, error) {
	var body ChatCompletionRequestMessageContentPartImage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestMessageContentPartImage overwrites any union data inside the ChatCompletionRequestUserMessageContentPart as the provided ChatCompletionRequestMessageContentPartImage
func (t *ChatCompletionRequestUserMessageContentPart) FromChatCompletionRequestMessageContentPartImage(v ChatCompletionRequestMessageContentPartImage) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestMessageContentPartImage performs a merge with any union data inside the ChatCompletionRequestUserMessageContentPart, using the provided ChatCompletionRequestMessageContentPartImage
func (t *ChatCompletionRequestUserMessageContentPart) MergeChatCompletionRequestMessageContentPartImage(v ChatCompletionRequestMessageContentPartImage) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChatCompletionRequestMessageContentPartAudio returns the union data inside the ChatCompletionRequestUserMessageContentPart as a ChatCompletionRequestMessageContentPartAudio
func (t ChatCompletionRequestUserMessageContentPart) AsChatCompletionRequestMessageContentPartAudio() (ChatCompletionRequestMessageContentPartAudio, error) {
	var body ChatCompletionRequestMessageContentPartAudio
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionRequestMessageContentPartAudio overwrites any union data inside the ChatCompletionRequestUserMessageContentPart as the provided ChatCompletionRequestMessageContentPartAudio
func (t *ChatCompletionRequestUserMessageContentPart) FromChatCompletionRequestMessageContentPartAudio(v ChatCompletionRequestMessageContentPartAudio) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionRequestMessageContentPartAudio performs a merge with any union data inside the ChatCompletionRequestUserMessageContentPart, using the provided ChatCompletionRequestMessageContentPartAudio
func (t *ChatCompletionRequestUserMessageContentPart) MergeChatCompletionRequestMessageContentPartAudio(v ChatCompletionRequestMessageContentPartAudio) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ChatCompletionRequestUserMessageContentPart) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ChatCompletionRequestUserMessageContentPart) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsChatCompletionToolChoiceOption0 returns the union data inside the ChatCompletionToolChoiceOption as a ChatCompletionToolChoiceOption0
func (t ChatCompletionToolChoiceOption) AsChatCompletionToolChoiceOption0() (ChatCompletionToolChoiceOption0, error) {
	var body ChatCompletionToolChoiceOption0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionToolChoiceOption0 overwrites any union data inside the ChatCompletionToolChoiceOption as the provided ChatCompletionToolChoiceOption0
func (t *ChatCompletionToolChoiceOption) FromChatCompletionToolChoiceOption0(v ChatCompletionToolChoiceOption0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionToolChoiceOption0 performs a merge with any union data inside the ChatCompletionToolChoiceOption, using the provided ChatCompletionToolChoiceOption0
func (t *ChatCompletionToolChoiceOption) MergeChatCompletionToolChoiceOption0(v ChatCompletionToolChoiceOption0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChatCompletionNamedToolChoice returns the union data inside the ChatCompletionToolChoiceOption as a ChatCompletionNamedToolChoice
func (t ChatCompletionToolChoiceOption) AsChatCompletionNamedToolChoice() (ChatCompletionNamedToolChoice, error) {
	var body ChatCompletionNamedToolChoice
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionNamedToolChoice overwrites any union data inside the ChatCompletionToolChoiceOption as the provided ChatCompletionNamedToolChoice
func (t *ChatCompletionToolChoiceOption) FromChatCompletionNamedToolChoice(v ChatCompletionNamedToolChoice) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionNamedToolChoice performs a merge with any union data inside the ChatCompletionToolChoiceOption, using the provided ChatCompletionNamedToolChoice
func (t *ChatCompletionToolChoiceOption) MergeChatCompletionNamedToolChoice(v ChatCompletionNamedToolChoice) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ChatCompletionToolChoiceOption) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ChatCompletionToolChoiceOption) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAutoChunkingStrategyRequestParam returns the union data inside the ChunkingStrategyRequestParam as a AutoChunkingStrategyRequestParam
func (t ChunkingStrategyRequestParam) AsAutoChunkingStrategyRequestParam() (AutoChunkingStrategyRequestParam, error) {
	var body AutoChunkingStrategyRequestParam
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAutoChunkingStrategyRequestParam overwrites any union data inside the ChunkingStrategyRequestParam as the provided AutoChunkingStrategyRequestParam
func (t *ChunkingStrategyRequestParam) FromAutoChunkingStrategyRequestParam(v AutoChunkingStrategyRequestParam) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAutoChunkingStrategyRequestParam performs a merge with any union data inside the ChunkingStrategyRequestParam, using the provided AutoChunkingStrategyRequestParam
func (t *ChunkingStrategyRequestParam) MergeAutoChunkingStrategyRequestParam(v AutoChunkingStrategyRequestParam) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStaticChunkingStrategyRequestParam returns the union data inside the ChunkingStrategyRequestParam as a StaticChunkingStrategyRequestParam
func (t ChunkingStrategyRequestParam) AsStaticChunkingStrategyRequestParam() (StaticChunkingStrategyRequestParam, error) {
	var body StaticChunkingStrategyRequestParam
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStaticChunkingStrategyRequestParam overwrites any union data inside the ChunkingStrategyRequestParam as the provided StaticChunkingStrategyRequestParam
func (t *ChunkingStrategyRequestParam) FromStaticChunkingStrategyRequestParam(v StaticChunkingStrategyRequestParam) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStaticChunkingStrategyRequestParam performs a merge with any union data inside the ChunkingStrategyRequestParam, using the provided StaticChunkingStrategyRequestParam
func (t *ChunkingStrategyRequestParam) MergeStaticChunkingStrategyRequestParam(v StaticChunkingStrategyRequestParam) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ChunkingStrategyRequestParam) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ChunkingStrategyRequestParam) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateAssistantRequestModel0 returns the union data inside the CreateAssistantRequest_Model as a CreateAssistantRequestModel0
func (t CreateAssistantRequest_Model) AsCreateAssistantRequestModel0() (CreateAssistantRequestModel0, error) {
	var body CreateAssistantRequestModel0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateAssistantRequestModel0 overwrites any union data inside the CreateAssistantRequest_Model as the provided CreateAssistantRequestModel0
func (t *CreateAssistantRequest_Model) FromCreateAssistantRequestModel0(v CreateAssistantRequestModel0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateAssistantRequestModel0 performs a merge with any union data inside the CreateAssistantRequest_Model, using the provided CreateAssistantRequestModel0
func (t *CreateAssistantRequest_Model) MergeCreateAssistantRequestModel0(v CreateAssistantRequestModel0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateAssistantRequestModel1 returns the union data inside the CreateAssistantRequest_Model as a CreateAssistantRequestModel1
func (t CreateAssistantRequest_Model) AsCreateAssistantRequestModel1() (CreateAssistantRequestModel1, error) {
	var body CreateAssistantRequestModel1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateAssistantRequestModel1 overwrites any union data inside the CreateAssistantRequest_Model as the provided CreateAssistantRequestModel1
func (t *CreateAssistantRequest_Model) FromCreateAssistantRequestModel1(v CreateAssistantRequestModel1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateAssistantRequestModel1 performs a merge with any union data inside the CreateAssistantRequest_Model, using the provided CreateAssistantRequestModel1
func (t *CreateAssistantRequest_Model) MergeCreateAssistantRequestModel1(v CreateAssistantRequestModel1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateAssistantRequest_Model) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateAssistantRequest_Model) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy0 returns the union data inside the CreateAssistantRequest_ToolResources_FileSearch_VectorStores_ChunkingStrategy as a CreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy0
func (t CreateAssistantRequest_ToolResources_FileSearch_VectorStores_ChunkingStrategy) AsCreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy0() (CreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy0, error) {
	var body CreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy0 overwrites any union data inside the CreateAssistantRequest_ToolResources_FileSearch_VectorStores_ChunkingStrategy as the provided CreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy0
func (t *CreateAssistantRequest_ToolResources_FileSearch_VectorStores_ChunkingStrategy) FromCreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy0(v CreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy0 performs a merge with any union data inside the CreateAssistantRequest_ToolResources_FileSearch_VectorStores_ChunkingStrategy, using the provided CreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy0
func (t *CreateAssistantRequest_ToolResources_FileSearch_VectorStores_ChunkingStrategy) MergeCreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy0(v CreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy1 returns the union data inside the CreateAssistantRequest_ToolResources_FileSearch_VectorStores_ChunkingStrategy as a CreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy1
func (t CreateAssistantRequest_ToolResources_FileSearch_VectorStores_ChunkingStrategy) AsCreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy1() (CreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy1, error) {
	var body CreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy1 overwrites any union data inside the CreateAssistantRequest_ToolResources_FileSearch_VectorStores_ChunkingStrategy as the provided CreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy1
func (t *CreateAssistantRequest_ToolResources_FileSearch_VectorStores_ChunkingStrategy) FromCreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy1(v CreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy1 performs a merge with any union data inside the CreateAssistantRequest_ToolResources_FileSearch_VectorStores_ChunkingStrategy, using the provided CreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy1
func (t *CreateAssistantRequest_ToolResources_FileSearch_VectorStores_ChunkingStrategy) MergeCreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy1(v CreateAssistantRequestToolResourcesFileSearchVectorStoresChunkingStrategy1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateAssistantRequest_ToolResources_FileSearch_VectorStores_ChunkingStrategy) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateAssistantRequest_ToolResources_FileSearch_VectorStores_ChunkingStrategy) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateAssistantRequestToolResourcesFileSearch0 returns the union data inside the CreateAssistantRequest_ToolResources_FileSearch as a CreateAssistantRequestToolResourcesFileSearch0
func (t CreateAssistantRequest_ToolResources_FileSearch) AsCreateAssistantRequestToolResourcesFileSearch0() (CreateAssistantRequestToolResourcesFileSearch0, error) {
	var body CreateAssistantRequestToolResourcesFileSearch0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateAssistantRequestToolResourcesFileSearch0 overwrites any union data inside the CreateAssistantRequest_ToolResources_FileSearch as the provided CreateAssistantRequestToolResourcesFileSearch0
func (t *CreateAssistantRequest_ToolResources_FileSearch) FromCreateAssistantRequestToolResourcesFileSearch0(v CreateAssistantRequestToolResourcesFileSearch0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateAssistantRequestToolResourcesFileSearch0 performs a merge with any union data inside the CreateAssistantRequest_ToolResources_FileSearch, using the provided CreateAssistantRequestToolResourcesFileSearch0
func (t *CreateAssistantRequest_ToolResources_FileSearch) MergeCreateAssistantRequestToolResourcesFileSearch0(v CreateAssistantRequestToolResourcesFileSearch0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateAssistantRequestToolResourcesFileSearch1 returns the union data inside the CreateAssistantRequest_ToolResources_FileSearch as a CreateAssistantRequestToolResourcesFileSearch1
func (t CreateAssistantRequest_ToolResources_FileSearch) AsCreateAssistantRequestToolResourcesFileSearch1() (CreateAssistantRequestToolResourcesFileSearch1, error) {
	var body CreateAssistantRequestToolResourcesFileSearch1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateAssistantRequestToolResourcesFileSearch1 overwrites any union data inside the CreateAssistantRequest_ToolResources_FileSearch as the provided CreateAssistantRequestToolResourcesFileSearch1
func (t *CreateAssistantRequest_ToolResources_FileSearch) FromCreateAssistantRequestToolResourcesFileSearch1(v CreateAssistantRequestToolResourcesFileSearch1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateAssistantRequestToolResourcesFileSearch1 performs a merge with any union data inside the CreateAssistantRequest_ToolResources_FileSearch, using the provided CreateAssistantRequestToolResourcesFileSearch1
func (t *CreateAssistantRequest_ToolResources_FileSearch) MergeCreateAssistantRequestToolResourcesFileSearch1(v CreateAssistantRequestToolResourcesFileSearch1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateAssistantRequest_ToolResources_FileSearch) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.VectorStoreIds != nil {
		object["vector_store_ids"], err = json.Marshal(t.VectorStoreIds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'vector_store_ids': %w", err)
		}
	}

	if t.VectorStores != nil {
		object["vector_stores"], err = json.Marshal(t.VectorStores)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'vector_stores': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *CreateAssistantRequest_ToolResources_FileSearch) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["vector_store_ids"]; found {
		err = json.Unmarshal(raw, &t.VectorStoreIds)
		if err != nil {
			return fmt.Errorf("error reading 'vector_store_ids': %w", err)
		}
	}

	if raw, found := object["vector_stores"]; found {
		err = json.Unmarshal(raw, &t.VectorStores)
		if err != nil {
			return fmt.Errorf("error reading 'vector_stores': %w", err)
		}
	}

	return err
}

// AsAssistantToolsCode returns the union data inside the CreateAssistantRequest_Tools_Item as a AssistantToolsCode
func (t CreateAssistantRequest_Tools_Item) AsAssistantToolsCode() (AssistantToolsCode, error) {
	var body AssistantToolsCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssistantToolsCode overwrites any union data inside the CreateAssistantRequest_Tools_Item as the provided AssistantToolsCode
func (t *CreateAssistantRequest_Tools_Item) FromAssistantToolsCode(v AssistantToolsCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssistantToolsCode performs a merge with any union data inside the CreateAssistantRequest_Tools_Item, using the provided AssistantToolsCode
func (t *CreateAssistantRequest_Tools_Item) MergeAssistantToolsCode(v AssistantToolsCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAssistantToolsFileSearch returns the union data inside the CreateAssistantRequest_Tools_Item as a AssistantToolsFileSearch
func (t CreateAssistantRequest_Tools_Item) AsAssistantToolsFileSearch() (AssistantToolsFileSearch, error) {
	var body AssistantToolsFileSearch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssistantToolsFileSearch overwrites any union data inside the CreateAssistantRequest_Tools_Item as the provided AssistantToolsFileSearch
func (t *CreateAssistantRequest_Tools_Item) FromAssistantToolsFileSearch(v AssistantToolsFileSearch) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssistantToolsFileSearch performs a merge with any union data inside the CreateAssistantRequest_Tools_Item, using the provided AssistantToolsFileSearch
func (t *CreateAssistantRequest_Tools_Item) MergeAssistantToolsFileSearch(v AssistantToolsFileSearch) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAssistantToolsFunction returns the union data inside the CreateAssistantRequest_Tools_Item as a AssistantToolsFunction
func (t CreateAssistantRequest_Tools_Item) AsAssistantToolsFunction() (AssistantToolsFunction, error) {
	var body AssistantToolsFunction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssistantToolsFunction overwrites any union data inside the CreateAssistantRequest_Tools_Item as the provided AssistantToolsFunction
func (t *CreateAssistantRequest_Tools_Item) FromAssistantToolsFunction(v AssistantToolsFunction) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssistantToolsFunction performs a merge with any union data inside the CreateAssistantRequest_Tools_Item, using the provided AssistantToolsFunction
func (t *CreateAssistantRequest_Tools_Item) MergeAssistantToolsFunction(v AssistantToolsFunction) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateAssistantRequest_Tools_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateAssistantRequest_Tools_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateChatCompletionRequestFunctionCall0 returns the union data inside the CreateChatCompletionRequest_FunctionCall as a CreateChatCompletionRequestFunctionCall0
func (t CreateChatCompletionRequest_FunctionCall) AsCreateChatCompletionRequestFunctionCall0() (CreateChatCompletionRequestFunctionCall0, error) {
	var body CreateChatCompletionRequestFunctionCall0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateChatCompletionRequestFunctionCall0 overwrites any union data inside the CreateChatCompletionRequest_FunctionCall as the provided CreateChatCompletionRequestFunctionCall0
func (t *CreateChatCompletionRequest_FunctionCall) FromCreateChatCompletionRequestFunctionCall0(v CreateChatCompletionRequestFunctionCall0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateChatCompletionRequestFunctionCall0 performs a merge with any union data inside the CreateChatCompletionRequest_FunctionCall, using the provided CreateChatCompletionRequestFunctionCall0
func (t *CreateChatCompletionRequest_FunctionCall) MergeCreateChatCompletionRequestFunctionCall0(v CreateChatCompletionRequestFunctionCall0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChatCompletionFunctionCallOption returns the union data inside the CreateChatCompletionRequest_FunctionCall as a ChatCompletionFunctionCallOption
func (t CreateChatCompletionRequest_FunctionCall) AsChatCompletionFunctionCallOption() (ChatCompletionFunctionCallOption, error) {
	var body ChatCompletionFunctionCallOption
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatCompletionFunctionCallOption overwrites any union data inside the CreateChatCompletionRequest_FunctionCall as the provided ChatCompletionFunctionCallOption
func (t *CreateChatCompletionRequest_FunctionCall) FromChatCompletionFunctionCallOption(v ChatCompletionFunctionCallOption) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatCompletionFunctionCallOption performs a merge with any union data inside the CreateChatCompletionRequest_FunctionCall, using the provided ChatCompletionFunctionCallOption
func (t *CreateChatCompletionRequest_FunctionCall) MergeChatCompletionFunctionCallOption(v ChatCompletionFunctionCallOption) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateChatCompletionRequest_FunctionCall) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateChatCompletionRequest_FunctionCall) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateChatCompletionRequestModel0 returns the union data inside the CreateChatCompletionRequest_Model as a CreateChatCompletionRequestModel0
func (t CreateChatCompletionRequest_Model) AsCreateChatCompletionRequestModel0() (CreateChatCompletionRequestModel0, error) {
	var body CreateChatCompletionRequestModel0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateChatCompletionRequestModel0 overwrites any union data inside the CreateChatCompletionRequest_Model as the provided CreateChatCompletionRequestModel0
func (t *CreateChatCompletionRequest_Model) FromCreateChatCompletionRequestModel0(v CreateChatCompletionRequestModel0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateChatCompletionRequestModel0 performs a merge with any union data inside the CreateChatCompletionRequest_Model, using the provided CreateChatCompletionRequestModel0
func (t *CreateChatCompletionRequest_Model) MergeCreateChatCompletionRequestModel0(v CreateChatCompletionRequestModel0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateChatCompletionRequestModel1 returns the union data inside the CreateChatCompletionRequest_Model as a CreateChatCompletionRequestModel1
func (t CreateChatCompletionRequest_Model) AsCreateChatCompletionRequestModel1() (CreateChatCompletionRequestModel1, error) {
	var body CreateChatCompletionRequestModel1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateChatCompletionRequestModel1 overwrites any union data inside the CreateChatCompletionRequest_Model as the provided CreateChatCompletionRequestModel1
func (t *CreateChatCompletionRequest_Model) FromCreateChatCompletionRequestModel1(v CreateChatCompletionRequestModel1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateChatCompletionRequestModel1 performs a merge with any union data inside the CreateChatCompletionRequest_Model, using the provided CreateChatCompletionRequestModel1
func (t *CreateChatCompletionRequest_Model) MergeCreateChatCompletionRequestModel1(v CreateChatCompletionRequestModel1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateChatCompletionRequest_Model) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateChatCompletionRequest_Model) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPredictionContent returns the union data inside the CreateChatCompletionRequest_Prediction as a PredictionContent
func (t CreateChatCompletionRequest_Prediction) AsPredictionContent() (PredictionContent, error) {
	var body PredictionContent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPredictionContent overwrites any union data inside the CreateChatCompletionRequest_Prediction as the provided PredictionContent
func (t *CreateChatCompletionRequest_Prediction) FromPredictionContent(v PredictionContent) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePredictionContent performs a merge with any union data inside the CreateChatCompletionRequest_Prediction, using the provided PredictionContent
func (t *CreateChatCompletionRequest_Prediction) MergePredictionContent(v PredictionContent) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateChatCompletionRequest_Prediction) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateChatCompletionRequest_Prediction) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsResponseFormatText returns the union data inside the CreateChatCompletionRequest_ResponseFormat as a ResponseFormatText
func (t CreateChatCompletionRequest_ResponseFormat) AsResponseFormatText() (ResponseFormatText, error) {
	var body ResponseFormatText
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResponseFormatText overwrites any union data inside the CreateChatCompletionRequest_ResponseFormat as the provided ResponseFormatText
func (t *CreateChatCompletionRequest_ResponseFormat) FromResponseFormatText(v ResponseFormatText) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResponseFormatText performs a merge with any union data inside the CreateChatCompletionRequest_ResponseFormat, using the provided ResponseFormatText
func (t *CreateChatCompletionRequest_ResponseFormat) MergeResponseFormatText(v ResponseFormatText) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResponseFormatJsonObject returns the union data inside the CreateChatCompletionRequest_ResponseFormat as a ResponseFormatJsonObject
func (t CreateChatCompletionRequest_ResponseFormat) AsResponseFormatJsonObject() (ResponseFormatJsonObject, error) {
	var body ResponseFormatJsonObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResponseFormatJsonObject overwrites any union data inside the CreateChatCompletionRequest_ResponseFormat as the provided ResponseFormatJsonObject
func (t *CreateChatCompletionRequest_ResponseFormat) FromResponseFormatJsonObject(v ResponseFormatJsonObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResponseFormatJsonObject performs a merge with any union data inside the CreateChatCompletionRequest_ResponseFormat, using the provided ResponseFormatJsonObject
func (t *CreateChatCompletionRequest_ResponseFormat) MergeResponseFormatJsonObject(v ResponseFormatJsonObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResponseFormatJsonSchema returns the union data inside the CreateChatCompletionRequest_ResponseFormat as a ResponseFormatJsonSchema
func (t CreateChatCompletionRequest_ResponseFormat) AsResponseFormatJsonSchema() (ResponseFormatJsonSchema, error) {
	var body ResponseFormatJsonSchema
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResponseFormatJsonSchema overwrites any union data inside the CreateChatCompletionRequest_ResponseFormat as the provided ResponseFormatJsonSchema
func (t *CreateChatCompletionRequest_ResponseFormat) FromResponseFormatJsonSchema(v ResponseFormatJsonSchema) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResponseFormatJsonSchema performs a merge with any union data inside the CreateChatCompletionRequest_ResponseFormat, using the provided ResponseFormatJsonSchema
func (t *CreateChatCompletionRequest_ResponseFormat) MergeResponseFormatJsonSchema(v ResponseFormatJsonSchema) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateChatCompletionRequest_ResponseFormat) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateChatCompletionRequest_ResponseFormat) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateChatCompletionRequestStop0 returns the union data inside the CreateChatCompletionRequest_Stop as a CreateChatCompletionRequestStop0
func (t CreateChatCompletionRequest_Stop) AsCreateChatCompletionRequestStop0() (CreateChatCompletionRequestStop0, error) {
	var body CreateChatCompletionRequestStop0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateChatCompletionRequestStop0 overwrites any union data inside the CreateChatCompletionRequest_Stop as the provided CreateChatCompletionRequestStop0
func (t *CreateChatCompletionRequest_Stop) FromCreateChatCompletionRequestStop0(v CreateChatCompletionRequestStop0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateChatCompletionRequestStop0 performs a merge with any union data inside the CreateChatCompletionRequest_Stop, using the provided CreateChatCompletionRequestStop0
func (t *CreateChatCompletionRequest_Stop) MergeCreateChatCompletionRequestStop0(v CreateChatCompletionRequestStop0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateChatCompletionRequestStop1 returns the union data inside the CreateChatCompletionRequest_Stop as a CreateChatCompletionRequestStop1
func (t CreateChatCompletionRequest_Stop) AsCreateChatCompletionRequestStop1() (CreateChatCompletionRequestStop1, error) {
	var body CreateChatCompletionRequestStop1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateChatCompletionRequestStop1 overwrites any union data inside the CreateChatCompletionRequest_Stop as the provided CreateChatCompletionRequestStop1
func (t *CreateChatCompletionRequest_Stop) FromCreateChatCompletionRequestStop1(v CreateChatCompletionRequestStop1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateChatCompletionRequestStop1 performs a merge with any union data inside the CreateChatCompletionRequest_Stop, using the provided CreateChatCompletionRequestStop1
func (t *CreateChatCompletionRequest_Stop) MergeCreateChatCompletionRequestStop1(v CreateChatCompletionRequestStop1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateChatCompletionRequest_Stop) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateChatCompletionRequest_Stop) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateCompletionRequestModel0 returns the union data inside the CreateCompletionRequest_Model as a CreateCompletionRequestModel0
func (t CreateCompletionRequest_Model) AsCreateCompletionRequestModel0() (CreateCompletionRequestModel0, error) {
	var body CreateCompletionRequestModel0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateCompletionRequestModel0 overwrites any union data inside the CreateCompletionRequest_Model as the provided CreateCompletionRequestModel0
func (t *CreateCompletionRequest_Model) FromCreateCompletionRequestModel0(v CreateCompletionRequestModel0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateCompletionRequestModel0 performs a merge with any union data inside the CreateCompletionRequest_Model, using the provided CreateCompletionRequestModel0
func (t *CreateCompletionRequest_Model) MergeCreateCompletionRequestModel0(v CreateCompletionRequestModel0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateCompletionRequestModel1 returns the union data inside the CreateCompletionRequest_Model as a CreateCompletionRequestModel1
func (t CreateCompletionRequest_Model) AsCreateCompletionRequestModel1() (CreateCompletionRequestModel1, error) {
	var body CreateCompletionRequestModel1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateCompletionRequestModel1 overwrites any union data inside the CreateCompletionRequest_Model as the provided CreateCompletionRequestModel1
func (t *CreateCompletionRequest_Model) FromCreateCompletionRequestModel1(v CreateCompletionRequestModel1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateCompletionRequestModel1 performs a merge with any union data inside the CreateCompletionRequest_Model, using the provided CreateCompletionRequestModel1
func (t *CreateCompletionRequest_Model) MergeCreateCompletionRequestModel1(v CreateCompletionRequestModel1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateCompletionRequest_Model) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateCompletionRequest_Model) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateCompletionRequestPrompt0 returns the union data inside the CreateCompletionRequest_Prompt as a CreateCompletionRequestPrompt0
func (t CreateCompletionRequest_Prompt) AsCreateCompletionRequestPrompt0() (CreateCompletionRequestPrompt0, error) {
	var body CreateCompletionRequestPrompt0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateCompletionRequestPrompt0 overwrites any union data inside the CreateCompletionRequest_Prompt as the provided CreateCompletionRequestPrompt0
func (t *CreateCompletionRequest_Prompt) FromCreateCompletionRequestPrompt0(v CreateCompletionRequestPrompt0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateCompletionRequestPrompt0 performs a merge with any union data inside the CreateCompletionRequest_Prompt, using the provided CreateCompletionRequestPrompt0
func (t *CreateCompletionRequest_Prompt) MergeCreateCompletionRequestPrompt0(v CreateCompletionRequestPrompt0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateCompletionRequestPrompt1 returns the union data inside the CreateCompletionRequest_Prompt as a CreateCompletionRequestPrompt1
func (t CreateCompletionRequest_Prompt) AsCreateCompletionRequestPrompt1() (CreateCompletionRequestPrompt1, error) {
	var body CreateCompletionRequestPrompt1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateCompletionRequestPrompt1 overwrites any union data inside the CreateCompletionRequest_Prompt as the provided CreateCompletionRequestPrompt1
func (t *CreateCompletionRequest_Prompt) FromCreateCompletionRequestPrompt1(v CreateCompletionRequestPrompt1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateCompletionRequestPrompt1 performs a merge with any union data inside the CreateCompletionRequest_Prompt, using the provided CreateCompletionRequestPrompt1
func (t *CreateCompletionRequest_Prompt) MergeCreateCompletionRequestPrompt1(v CreateCompletionRequestPrompt1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateCompletionRequestPrompt2 returns the union data inside the CreateCompletionRequest_Prompt as a CreateCompletionRequestPrompt2
func (t CreateCompletionRequest_Prompt) AsCreateCompletionRequestPrompt2() (CreateCompletionRequestPrompt2, error) {
	var body CreateCompletionRequestPrompt2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateCompletionRequestPrompt2 overwrites any union data inside the CreateCompletionRequest_Prompt as the provided CreateCompletionRequestPrompt2
func (t *CreateCompletionRequest_Prompt) FromCreateCompletionRequestPrompt2(v CreateCompletionRequestPrompt2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateCompletionRequestPrompt2 performs a merge with any union data inside the CreateCompletionRequest_Prompt, using the provided CreateCompletionRequestPrompt2
func (t *CreateCompletionRequest_Prompt) MergeCreateCompletionRequestPrompt2(v CreateCompletionRequestPrompt2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateCompletionRequestPrompt3 returns the union data inside the CreateCompletionRequest_Prompt as a CreateCompletionRequestPrompt3
func (t CreateCompletionRequest_Prompt) AsCreateCompletionRequestPrompt3() (CreateCompletionRequestPrompt3, error) {
	var body CreateCompletionRequestPrompt3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateCompletionRequestPrompt3 overwrites any union data inside the CreateCompletionRequest_Prompt as the provided CreateCompletionRequestPrompt3
func (t *CreateCompletionRequest_Prompt) FromCreateCompletionRequestPrompt3(v CreateCompletionRequestPrompt3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateCompletionRequestPrompt3 performs a merge with any union data inside the CreateCompletionRequest_Prompt, using the provided CreateCompletionRequestPrompt3
func (t *CreateCompletionRequest_Prompt) MergeCreateCompletionRequestPrompt3(v CreateCompletionRequestPrompt3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateCompletionRequest_Prompt) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateCompletionRequest_Prompt) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateCompletionRequestStop0 returns the union data inside the CreateCompletionRequest_Stop as a CreateCompletionRequestStop0
func (t CreateCompletionRequest_Stop) AsCreateCompletionRequestStop0() (CreateCompletionRequestStop0, error) {
	var body CreateCompletionRequestStop0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateCompletionRequestStop0 overwrites any union data inside the CreateCompletionRequest_Stop as the provided CreateCompletionRequestStop0
func (t *CreateCompletionRequest_Stop) FromCreateCompletionRequestStop0(v CreateCompletionRequestStop0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateCompletionRequestStop0 performs a merge with any union data inside the CreateCompletionRequest_Stop, using the provided CreateCompletionRequestStop0
func (t *CreateCompletionRequest_Stop) MergeCreateCompletionRequestStop0(v CreateCompletionRequestStop0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateCompletionRequestStop1 returns the union data inside the CreateCompletionRequest_Stop as a CreateCompletionRequestStop1
func (t CreateCompletionRequest_Stop) AsCreateCompletionRequestStop1() (CreateCompletionRequestStop1, error) {
	var body CreateCompletionRequestStop1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateCompletionRequestStop1 overwrites any union data inside the CreateCompletionRequest_Stop as the provided CreateCompletionRequestStop1
func (t *CreateCompletionRequest_Stop) FromCreateCompletionRequestStop1(v CreateCompletionRequestStop1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateCompletionRequestStop1 performs a merge with any union data inside the CreateCompletionRequest_Stop, using the provided CreateCompletionRequestStop1
func (t *CreateCompletionRequest_Stop) MergeCreateCompletionRequestStop1(v CreateCompletionRequestStop1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateCompletionRequest_Stop) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateCompletionRequest_Stop) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateEmbeddingRequestInput0 returns the union data inside the CreateEmbeddingRequest_Input as a CreateEmbeddingRequestInput0
func (t CreateEmbeddingRequest_Input) AsCreateEmbeddingRequestInput0() (CreateEmbeddingRequestInput0, error) {
	var body CreateEmbeddingRequestInput0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateEmbeddingRequestInput0 overwrites any union data inside the CreateEmbeddingRequest_Input as the provided CreateEmbeddingRequestInput0
func (t *CreateEmbeddingRequest_Input) FromCreateEmbeddingRequestInput0(v CreateEmbeddingRequestInput0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateEmbeddingRequestInput0 performs a merge with any union data inside the CreateEmbeddingRequest_Input, using the provided CreateEmbeddingRequestInput0
func (t *CreateEmbeddingRequest_Input) MergeCreateEmbeddingRequestInput0(v CreateEmbeddingRequestInput0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateEmbeddingRequestInput1 returns the union data inside the CreateEmbeddingRequest_Input as a CreateEmbeddingRequestInput1
func (t CreateEmbeddingRequest_Input) AsCreateEmbeddingRequestInput1() (CreateEmbeddingRequestInput1, error) {
	var body CreateEmbeddingRequestInput1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateEmbeddingRequestInput1 overwrites any union data inside the CreateEmbeddingRequest_Input as the provided CreateEmbeddingRequestInput1
func (t *CreateEmbeddingRequest_Input) FromCreateEmbeddingRequestInput1(v CreateEmbeddingRequestInput1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateEmbeddingRequestInput1 performs a merge with any union data inside the CreateEmbeddingRequest_Input, using the provided CreateEmbeddingRequestInput1
func (t *CreateEmbeddingRequest_Input) MergeCreateEmbeddingRequestInput1(v CreateEmbeddingRequestInput1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateEmbeddingRequestInput2 returns the union data inside the CreateEmbeddingRequest_Input as a CreateEmbeddingRequestInput2
func (t CreateEmbeddingRequest_Input) AsCreateEmbeddingRequestInput2() (CreateEmbeddingRequestInput2, error) {
	var body CreateEmbeddingRequestInput2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateEmbeddingRequestInput2 overwrites any union data inside the CreateEmbeddingRequest_Input as the provided CreateEmbeddingRequestInput2
func (t *CreateEmbeddingRequest_Input) FromCreateEmbeddingRequestInput2(v CreateEmbeddingRequestInput2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateEmbeddingRequestInput2 performs a merge with any union data inside the CreateEmbeddingRequest_Input, using the provided CreateEmbeddingRequestInput2
func (t *CreateEmbeddingRequest_Input) MergeCreateEmbeddingRequestInput2(v CreateEmbeddingRequestInput2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateEmbeddingRequestInput3 returns the union data inside the CreateEmbeddingRequest_Input as a CreateEmbeddingRequestInput3
func (t CreateEmbeddingRequest_Input) AsCreateEmbeddingRequestInput3() (CreateEmbeddingRequestInput3, error) {
	var body CreateEmbeddingRequestInput3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateEmbeddingRequestInput3 overwrites any union data inside the CreateEmbeddingRequest_Input as the provided CreateEmbeddingRequestInput3
func (t *CreateEmbeddingRequest_Input) FromCreateEmbeddingRequestInput3(v CreateEmbeddingRequestInput3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateEmbeddingRequestInput3 performs a merge with any union data inside the CreateEmbeddingRequest_Input, using the provided CreateEmbeddingRequestInput3
func (t *CreateEmbeddingRequest_Input) MergeCreateEmbeddingRequestInput3(v CreateEmbeddingRequestInput3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateEmbeddingRequest_Input) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateEmbeddingRequest_Input) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateEmbeddingRequestModel0 returns the union data inside the CreateEmbeddingRequest_Model as a CreateEmbeddingRequestModel0
func (t CreateEmbeddingRequest_Model) AsCreateEmbeddingRequestModel0() (CreateEmbeddingRequestModel0, error) {
	var body CreateEmbeddingRequestModel0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateEmbeddingRequestModel0 overwrites any union data inside the CreateEmbeddingRequest_Model as the provided CreateEmbeddingRequestModel0
func (t *CreateEmbeddingRequest_Model) FromCreateEmbeddingRequestModel0(v CreateEmbeddingRequestModel0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateEmbeddingRequestModel0 performs a merge with any union data inside the CreateEmbeddingRequest_Model, using the provided CreateEmbeddingRequestModel0
func (t *CreateEmbeddingRequest_Model) MergeCreateEmbeddingRequestModel0(v CreateEmbeddingRequestModel0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateEmbeddingRequestModel1 returns the union data inside the CreateEmbeddingRequest_Model as a CreateEmbeddingRequestModel1
func (t CreateEmbeddingRequest_Model) AsCreateEmbeddingRequestModel1() (CreateEmbeddingRequestModel1, error) {
	var body CreateEmbeddingRequestModel1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateEmbeddingRequestModel1 overwrites any union data inside the CreateEmbeddingRequest_Model as the provided CreateEmbeddingRequestModel1
func (t *CreateEmbeddingRequest_Model) FromCreateEmbeddingRequestModel1(v CreateEmbeddingRequestModel1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateEmbeddingRequestModel1 performs a merge with any union data inside the CreateEmbeddingRequest_Model, using the provided CreateEmbeddingRequestModel1
func (t *CreateEmbeddingRequest_Model) MergeCreateEmbeddingRequestModel1(v CreateEmbeddingRequestModel1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateEmbeddingRequest_Model) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateEmbeddingRequest_Model) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateFineTuningJobRequestHyperparametersBatchSize0 returns the union data inside the CreateFineTuningJobRequest_Hyperparameters_BatchSize as a CreateFineTuningJobRequestHyperparametersBatchSize0
func (t CreateFineTuningJobRequest_Hyperparameters_BatchSize) AsCreateFineTuningJobRequestHyperparametersBatchSize0() (CreateFineTuningJobRequestHyperparametersBatchSize0, error) {
	var body CreateFineTuningJobRequestHyperparametersBatchSize0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateFineTuningJobRequestHyperparametersBatchSize0 overwrites any union data inside the CreateFineTuningJobRequest_Hyperparameters_BatchSize as the provided CreateFineTuningJobRequestHyperparametersBatchSize0
func (t *CreateFineTuningJobRequest_Hyperparameters_BatchSize) FromCreateFineTuningJobRequestHyperparametersBatchSize0(v CreateFineTuningJobRequestHyperparametersBatchSize0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateFineTuningJobRequestHyperparametersBatchSize0 performs a merge with any union data inside the CreateFineTuningJobRequest_Hyperparameters_BatchSize, using the provided CreateFineTuningJobRequestHyperparametersBatchSize0
func (t *CreateFineTuningJobRequest_Hyperparameters_BatchSize) MergeCreateFineTuningJobRequestHyperparametersBatchSize0(v CreateFineTuningJobRequestHyperparametersBatchSize0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateFineTuningJobRequestHyperparametersBatchSize1 returns the union data inside the CreateFineTuningJobRequest_Hyperparameters_BatchSize as a CreateFineTuningJobRequestHyperparametersBatchSize1
func (t CreateFineTuningJobRequest_Hyperparameters_BatchSize) AsCreateFineTuningJobRequestHyperparametersBatchSize1() (CreateFineTuningJobRequestHyperparametersBatchSize1, error) {
	var body CreateFineTuningJobRequestHyperparametersBatchSize1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateFineTuningJobRequestHyperparametersBatchSize1 overwrites any union data inside the CreateFineTuningJobRequest_Hyperparameters_BatchSize as the provided CreateFineTuningJobRequestHyperparametersBatchSize1
func (t *CreateFineTuningJobRequest_Hyperparameters_BatchSize) FromCreateFineTuningJobRequestHyperparametersBatchSize1(v CreateFineTuningJobRequestHyperparametersBatchSize1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateFineTuningJobRequestHyperparametersBatchSize1 performs a merge with any union data inside the CreateFineTuningJobRequest_Hyperparameters_BatchSize, using the provided CreateFineTuningJobRequestHyperparametersBatchSize1
func (t *CreateFineTuningJobRequest_Hyperparameters_BatchSize) MergeCreateFineTuningJobRequestHyperparametersBatchSize1(v CreateFineTuningJobRequestHyperparametersBatchSize1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateFineTuningJobRequest_Hyperparameters_BatchSize) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateFineTuningJobRequest_Hyperparameters_BatchSize) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateFineTuningJobRequestHyperparametersLearningRateMultiplier0 returns the union data inside the CreateFineTuningJobRequest_Hyperparameters_LearningRateMultiplier as a CreateFineTuningJobRequestHyperparametersLearningRateMultiplier0
func (t CreateFineTuningJobRequest_Hyperparameters_LearningRateMultiplier) AsCreateFineTuningJobRequestHyperparametersLearningRateMultiplier0() (CreateFineTuningJobRequestHyperparametersLearningRateMultiplier0, error) {
	var body CreateFineTuningJobRequestHyperparametersLearningRateMultiplier0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateFineTuningJobRequestHyperparametersLearningRateMultiplier0 overwrites any union data inside the CreateFineTuningJobRequest_Hyperparameters_LearningRateMultiplier as the provided CreateFineTuningJobRequestHyperparametersLearningRateMultiplier0
func (t *CreateFineTuningJobRequest_Hyperparameters_LearningRateMultiplier) FromCreateFineTuningJobRequestHyperparametersLearningRateMultiplier0(v CreateFineTuningJobRequestHyperparametersLearningRateMultiplier0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateFineTuningJobRequestHyperparametersLearningRateMultiplier0 performs a merge with any union data inside the CreateFineTuningJobRequest_Hyperparameters_LearningRateMultiplier, using the provided CreateFineTuningJobRequestHyperparametersLearningRateMultiplier0
func (t *CreateFineTuningJobRequest_Hyperparameters_LearningRateMultiplier) MergeCreateFineTuningJobRequestHyperparametersLearningRateMultiplier0(v CreateFineTuningJobRequestHyperparametersLearningRateMultiplier0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateFineTuningJobRequestHyperparametersLearningRateMultiplier1 returns the union data inside the CreateFineTuningJobRequest_Hyperparameters_LearningRateMultiplier as a CreateFineTuningJobRequestHyperparametersLearningRateMultiplier1
func (t CreateFineTuningJobRequest_Hyperparameters_LearningRateMultiplier) AsCreateFineTuningJobRequestHyperparametersLearningRateMultiplier1() (CreateFineTuningJobRequestHyperparametersLearningRateMultiplier1, error) {
	var body CreateFineTuningJobRequestHyperparametersLearningRateMultiplier1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateFineTuningJobRequestHyperparametersLearningRateMultiplier1 overwrites any union data inside the CreateFineTuningJobRequest_Hyperparameters_LearningRateMultiplier as the provided CreateFineTuningJobRequestHyperparametersLearningRateMultiplier1
func (t *CreateFineTuningJobRequest_Hyperparameters_LearningRateMultiplier) FromCreateFineTuningJobRequestHyperparametersLearningRateMultiplier1(v CreateFineTuningJobRequestHyperparametersLearningRateMultiplier1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateFineTuningJobRequestHyperparametersLearningRateMultiplier1 performs a merge with any union data inside the CreateFineTuningJobRequest_Hyperparameters_LearningRateMultiplier, using the provided CreateFineTuningJobRequestHyperparametersLearningRateMultiplier1
func (t *CreateFineTuningJobRequest_Hyperparameters_LearningRateMultiplier) MergeCreateFineTuningJobRequestHyperparametersLearningRateMultiplier1(v CreateFineTuningJobRequestHyperparametersLearningRateMultiplier1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateFineTuningJobRequest_Hyperparameters_LearningRateMultiplier) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateFineTuningJobRequest_Hyperparameters_LearningRateMultiplier) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateFineTuningJobRequestHyperparametersNEpochs0 returns the union data inside the CreateFineTuningJobRequest_Hyperparameters_NEpochs as a CreateFineTuningJobRequestHyperparametersNEpochs0
func (t CreateFineTuningJobRequest_Hyperparameters_NEpochs) AsCreateFineTuningJobRequestHyperparametersNEpochs0() (CreateFineTuningJobRequestHyperparametersNEpochs0, error) {
	var body CreateFineTuningJobRequestHyperparametersNEpochs0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateFineTuningJobRequestHyperparametersNEpochs0 overwrites any union data inside the CreateFineTuningJobRequest_Hyperparameters_NEpochs as the provided CreateFineTuningJobRequestHyperparametersNEpochs0
func (t *CreateFineTuningJobRequest_Hyperparameters_NEpochs) FromCreateFineTuningJobRequestHyperparametersNEpochs0(v CreateFineTuningJobRequestHyperparametersNEpochs0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateFineTuningJobRequestHyperparametersNEpochs0 performs a merge with any union data inside the CreateFineTuningJobRequest_Hyperparameters_NEpochs, using the provided CreateFineTuningJobRequestHyperparametersNEpochs0
func (t *CreateFineTuningJobRequest_Hyperparameters_NEpochs) MergeCreateFineTuningJobRequestHyperparametersNEpochs0(v CreateFineTuningJobRequestHyperparametersNEpochs0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateFineTuningJobRequestHyperparametersNEpochs1 returns the union data inside the CreateFineTuningJobRequest_Hyperparameters_NEpochs as a CreateFineTuningJobRequestHyperparametersNEpochs1
func (t CreateFineTuningJobRequest_Hyperparameters_NEpochs) AsCreateFineTuningJobRequestHyperparametersNEpochs1() (CreateFineTuningJobRequestHyperparametersNEpochs1, error) {
	var body CreateFineTuningJobRequestHyperparametersNEpochs1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateFineTuningJobRequestHyperparametersNEpochs1 overwrites any union data inside the CreateFineTuningJobRequest_Hyperparameters_NEpochs as the provided CreateFineTuningJobRequestHyperparametersNEpochs1
func (t *CreateFineTuningJobRequest_Hyperparameters_NEpochs) FromCreateFineTuningJobRequestHyperparametersNEpochs1(v CreateFineTuningJobRequestHyperparametersNEpochs1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateFineTuningJobRequestHyperparametersNEpochs1 performs a merge with any union data inside the CreateFineTuningJobRequest_Hyperparameters_NEpochs, using the provided CreateFineTuningJobRequestHyperparametersNEpochs1
func (t *CreateFineTuningJobRequest_Hyperparameters_NEpochs) MergeCreateFineTuningJobRequestHyperparametersNEpochs1(v CreateFineTuningJobRequestHyperparametersNEpochs1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateFineTuningJobRequest_Hyperparameters_NEpochs) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateFineTuningJobRequest_Hyperparameters_NEpochs) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateFineTuningJobRequestIntegrationsType0 returns the union data inside the CreateFineTuningJobRequest_Integrations_Type as a CreateFineTuningJobRequestIntegrationsType0
func (t CreateFineTuningJobRequest_Integrations_Type) AsCreateFineTuningJobRequestIntegrationsType0() (CreateFineTuningJobRequestIntegrationsType0, error) {
	var body CreateFineTuningJobRequestIntegrationsType0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateFineTuningJobRequestIntegrationsType0 overwrites any union data inside the CreateFineTuningJobRequest_Integrations_Type as the provided CreateFineTuningJobRequestIntegrationsType0
func (t *CreateFineTuningJobRequest_Integrations_Type) FromCreateFineTuningJobRequestIntegrationsType0(v CreateFineTuningJobRequestIntegrationsType0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateFineTuningJobRequestIntegrationsType0 performs a merge with any union data inside the CreateFineTuningJobRequest_Integrations_Type, using the provided CreateFineTuningJobRequestIntegrationsType0
func (t *CreateFineTuningJobRequest_Integrations_Type) MergeCreateFineTuningJobRequestIntegrationsType0(v CreateFineTuningJobRequestIntegrationsType0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateFineTuningJobRequest_Integrations_Type) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateFineTuningJobRequest_Integrations_Type) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateFineTuningJobRequestModel0 returns the union data inside the CreateFineTuningJobRequest_Model as a CreateFineTuningJobRequestModel0
func (t CreateFineTuningJobRequest_Model) AsCreateFineTuningJobRequestModel0() (CreateFineTuningJobRequestModel0, error) {
	var body CreateFineTuningJobRequestModel0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateFineTuningJobRequestModel0 overwrites any union data inside the CreateFineTuningJobRequest_Model as the provided CreateFineTuningJobRequestModel0
func (t *CreateFineTuningJobRequest_Model) FromCreateFineTuningJobRequestModel0(v CreateFineTuningJobRequestModel0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateFineTuningJobRequestModel0 performs a merge with any union data inside the CreateFineTuningJobRequest_Model, using the provided CreateFineTuningJobRequestModel0
func (t *CreateFineTuningJobRequest_Model) MergeCreateFineTuningJobRequestModel0(v CreateFineTuningJobRequestModel0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateFineTuningJobRequestModel1 returns the union data inside the CreateFineTuningJobRequest_Model as a CreateFineTuningJobRequestModel1
func (t CreateFineTuningJobRequest_Model) AsCreateFineTuningJobRequestModel1() (CreateFineTuningJobRequestModel1, error) {
	var body CreateFineTuningJobRequestModel1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateFineTuningJobRequestModel1 overwrites any union data inside the CreateFineTuningJobRequest_Model as the provided CreateFineTuningJobRequestModel1
func (t *CreateFineTuningJobRequest_Model) FromCreateFineTuningJobRequestModel1(v CreateFineTuningJobRequestModel1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateFineTuningJobRequestModel1 performs a merge with any union data inside the CreateFineTuningJobRequest_Model, using the provided CreateFineTuningJobRequestModel1
func (t *CreateFineTuningJobRequest_Model) MergeCreateFineTuningJobRequestModel1(v CreateFineTuningJobRequestModel1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateFineTuningJobRequest_Model) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateFineTuningJobRequest_Model) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateImageEditRequestModel0 returns the union data inside the CreateImageEditRequest_Model as a CreateImageEditRequestModel0
func (t CreateImageEditRequest_Model) AsCreateImageEditRequestModel0() (CreateImageEditRequestModel0, error) {
	var body CreateImageEditRequestModel0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateImageEditRequestModel0 overwrites any union data inside the CreateImageEditRequest_Model as the provided CreateImageEditRequestModel0
func (t *CreateImageEditRequest_Model) FromCreateImageEditRequestModel0(v CreateImageEditRequestModel0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateImageEditRequestModel0 performs a merge with any union data inside the CreateImageEditRequest_Model, using the provided CreateImageEditRequestModel0
func (t *CreateImageEditRequest_Model) MergeCreateImageEditRequestModel0(v CreateImageEditRequestModel0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateImageEditRequestModel1 returns the union data inside the CreateImageEditRequest_Model as a CreateImageEditRequestModel1
func (t CreateImageEditRequest_Model) AsCreateImageEditRequestModel1() (CreateImageEditRequestModel1, error) {
	var body CreateImageEditRequestModel1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateImageEditRequestModel1 overwrites any union data inside the CreateImageEditRequest_Model as the provided CreateImageEditRequestModel1
func (t *CreateImageEditRequest_Model) FromCreateImageEditRequestModel1(v CreateImageEditRequestModel1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateImageEditRequestModel1 performs a merge with any union data inside the CreateImageEditRequest_Model, using the provided CreateImageEditRequestModel1
func (t *CreateImageEditRequest_Model) MergeCreateImageEditRequestModel1(v CreateImageEditRequestModel1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateImageEditRequest_Model) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateImageEditRequest_Model) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateImageRequestModel0 returns the union data inside the CreateImageRequest_Model as a CreateImageRequestModel0
func (t CreateImageRequest_Model) AsCreateImageRequestModel0() (CreateImageRequestModel0, error) {
	var body CreateImageRequestModel0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateImageRequestModel0 overwrites any union data inside the CreateImageRequest_Model as the provided CreateImageRequestModel0
func (t *CreateImageRequest_Model) FromCreateImageRequestModel0(v CreateImageRequestModel0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateImageRequestModel0 performs a merge with any union data inside the CreateImageRequest_Model, using the provided CreateImageRequestModel0
func (t *CreateImageRequest_Model) MergeCreateImageRequestModel0(v CreateImageRequestModel0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateImageRequestModel1 returns the union data inside the CreateImageRequest_Model as a CreateImageRequestModel1
func (t CreateImageRequest_Model) AsCreateImageRequestModel1() (CreateImageRequestModel1, error) {
	var body CreateImageRequestModel1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateImageRequestModel1 overwrites any union data inside the CreateImageRequest_Model as the provided CreateImageRequestModel1
func (t *CreateImageRequest_Model) FromCreateImageRequestModel1(v CreateImageRequestModel1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateImageRequestModel1 performs a merge with any union data inside the CreateImageRequest_Model, using the provided CreateImageRequestModel1
func (t *CreateImageRequest_Model) MergeCreateImageRequestModel1(v CreateImageRequestModel1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateImageRequest_Model) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateImageRequest_Model) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateImageVariationRequestModel0 returns the union data inside the CreateImageVariationRequest_Model as a CreateImageVariationRequestModel0
func (t CreateImageVariationRequest_Model) AsCreateImageVariationRequestModel0() (CreateImageVariationRequestModel0, error) {
	var body CreateImageVariationRequestModel0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateImageVariationRequestModel0 overwrites any union data inside the CreateImageVariationRequest_Model as the provided CreateImageVariationRequestModel0
func (t *CreateImageVariationRequest_Model) FromCreateImageVariationRequestModel0(v CreateImageVariationRequestModel0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateImageVariationRequestModel0 performs a merge with any union data inside the CreateImageVariationRequest_Model, using the provided CreateImageVariationRequestModel0
func (t *CreateImageVariationRequest_Model) MergeCreateImageVariationRequestModel0(v CreateImageVariationRequestModel0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateImageVariationRequestModel1 returns the union data inside the CreateImageVariationRequest_Model as a CreateImageVariationRequestModel1
func (t CreateImageVariationRequest_Model) AsCreateImageVariationRequestModel1() (CreateImageVariationRequestModel1, error) {
	var body CreateImageVariationRequestModel1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateImageVariationRequestModel1 overwrites any union data inside the CreateImageVariationRequest_Model as the provided CreateImageVariationRequestModel1
func (t *CreateImageVariationRequest_Model) FromCreateImageVariationRequestModel1(v CreateImageVariationRequestModel1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateImageVariationRequestModel1 performs a merge with any union data inside the CreateImageVariationRequest_Model, using the provided CreateImageVariationRequestModel1
func (t *CreateImageVariationRequest_Model) MergeCreateImageVariationRequestModel1(v CreateImageVariationRequestModel1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateImageVariationRequest_Model) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateImageVariationRequest_Model) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAssistantToolsCode returns the union data inside the CreateMessageRequest_Attachments_Tools_Item as a AssistantToolsCode
func (t CreateMessageRequest_Attachments_Tools_Item) AsAssistantToolsCode() (AssistantToolsCode, error) {
	var body AssistantToolsCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssistantToolsCode overwrites any union data inside the CreateMessageRequest_Attachments_Tools_Item as the provided AssistantToolsCode
func (t *CreateMessageRequest_Attachments_Tools_Item) FromAssistantToolsCode(v AssistantToolsCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssistantToolsCode performs a merge with any union data inside the CreateMessageRequest_Attachments_Tools_Item, using the provided AssistantToolsCode
func (t *CreateMessageRequest_Attachments_Tools_Item) MergeAssistantToolsCode(v AssistantToolsCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAssistantToolsFileSearchTypeOnly returns the union data inside the CreateMessageRequest_Attachments_Tools_Item as a AssistantToolsFileSearchTypeOnly
func (t CreateMessageRequest_Attachments_Tools_Item) AsAssistantToolsFileSearchTypeOnly() (AssistantToolsFileSearchTypeOnly, error) {
	var body AssistantToolsFileSearchTypeOnly
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssistantToolsFileSearchTypeOnly overwrites any union data inside the CreateMessageRequest_Attachments_Tools_Item as the provided AssistantToolsFileSearchTypeOnly
func (t *CreateMessageRequest_Attachments_Tools_Item) FromAssistantToolsFileSearchTypeOnly(v AssistantToolsFileSearchTypeOnly) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssistantToolsFileSearchTypeOnly performs a merge with any union data inside the CreateMessageRequest_Attachments_Tools_Item, using the provided AssistantToolsFileSearchTypeOnly
func (t *CreateMessageRequest_Attachments_Tools_Item) MergeAssistantToolsFileSearchTypeOnly(v AssistantToolsFileSearchTypeOnly) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateMessageRequest_Attachments_Tools_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateMessageRequest_Attachments_Tools_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMessageContentImageFileObject returns the union data inside the CreateMessageRequest_Content_1_Item as a MessageContentImageFileObject
func (t CreateMessageRequest_Content_1_Item) AsMessageContentImageFileObject() (MessageContentImageFileObject, error) {
	var body MessageContentImageFileObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMessageContentImageFileObject overwrites any union data inside the CreateMessageRequest_Content_1_Item as the provided MessageContentImageFileObject
func (t *CreateMessageRequest_Content_1_Item) FromMessageContentImageFileObject(v MessageContentImageFileObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMessageContentImageFileObject performs a merge with any union data inside the CreateMessageRequest_Content_1_Item, using the provided MessageContentImageFileObject
func (t *CreateMessageRequest_Content_1_Item) MergeMessageContentImageFileObject(v MessageContentImageFileObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMessageContentImageUrlObject returns the union data inside the CreateMessageRequest_Content_1_Item as a MessageContentImageUrlObject
func (t CreateMessageRequest_Content_1_Item) AsMessageContentImageUrlObject() (MessageContentImageUrlObject, error) {
	var body MessageContentImageUrlObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMessageContentImageUrlObject overwrites any union data inside the CreateMessageRequest_Content_1_Item as the provided MessageContentImageUrlObject
func (t *CreateMessageRequest_Content_1_Item) FromMessageContentImageUrlObject(v MessageContentImageUrlObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMessageContentImageUrlObject performs a merge with any union data inside the CreateMessageRequest_Content_1_Item, using the provided MessageContentImageUrlObject
func (t *CreateMessageRequest_Content_1_Item) MergeMessageContentImageUrlObject(v MessageContentImageUrlObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMessageRequestContentTextObject returns the union data inside the CreateMessageRequest_Content_1_Item as a MessageRequestContentTextObject
func (t CreateMessageRequest_Content_1_Item) AsMessageRequestContentTextObject() (MessageRequestContentTextObject, error) {
	var body MessageRequestContentTextObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMessageRequestContentTextObject overwrites any union data inside the CreateMessageRequest_Content_1_Item as the provided MessageRequestContentTextObject
func (t *CreateMessageRequest_Content_1_Item) FromMessageRequestContentTextObject(v MessageRequestContentTextObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMessageRequestContentTextObject performs a merge with any union data inside the CreateMessageRequest_Content_1_Item, using the provided MessageRequestContentTextObject
func (t *CreateMessageRequest_Content_1_Item) MergeMessageRequestContentTextObject(v MessageRequestContentTextObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateMessageRequest_Content_1_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateMessageRequest_Content_1_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateMessageRequestContent0 returns the union data inside the CreateMessageRequest_Content as a CreateMessageRequestContent0
func (t CreateMessageRequest_Content) AsCreateMessageRequestContent0() (CreateMessageRequestContent0, error) {
	var body CreateMessageRequestContent0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateMessageRequestContent0 overwrites any union data inside the CreateMessageRequest_Content as the provided CreateMessageRequestContent0
func (t *CreateMessageRequest_Content) FromCreateMessageRequestContent0(v CreateMessageRequestContent0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateMessageRequestContent0 performs a merge with any union data inside the CreateMessageRequest_Content, using the provided CreateMessageRequestContent0
func (t *CreateMessageRequest_Content) MergeCreateMessageRequestContent0(v CreateMessageRequestContent0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateMessageRequestContent1 returns the union data inside the CreateMessageRequest_Content as a CreateMessageRequestContent1
func (t CreateMessageRequest_Content) AsCreateMessageRequestContent1() (CreateMessageRequestContent1, error) {
	var body CreateMessageRequestContent1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateMessageRequestContent1 overwrites any union data inside the CreateMessageRequest_Content as the provided CreateMessageRequestContent1
func (t *CreateMessageRequest_Content) FromCreateMessageRequestContent1(v CreateMessageRequestContent1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateMessageRequestContent1 performs a merge with any union data inside the CreateMessageRequest_Content, using the provided CreateMessageRequestContent1
func (t *CreateMessageRequest_Content) MergeCreateMessageRequestContent1(v CreateMessageRequestContent1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateMessageRequest_Content) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateMessageRequest_Content) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateModerationRequestInput20 returns the union data inside the CreateModerationRequest_Input_2_Item as a CreateModerationRequestInput20
func (t CreateModerationRequest_Input_2_Item) AsCreateModerationRequestInput20() (CreateModerationRequestInput20, error) {
	var body CreateModerationRequestInput20
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateModerationRequestInput20 overwrites any union data inside the CreateModerationRequest_Input_2_Item as the provided CreateModerationRequestInput20
func (t *CreateModerationRequest_Input_2_Item) FromCreateModerationRequestInput20(v CreateModerationRequestInput20) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateModerationRequestInput20 performs a merge with any union data inside the CreateModerationRequest_Input_2_Item, using the provided CreateModerationRequestInput20
func (t *CreateModerationRequest_Input_2_Item) MergeCreateModerationRequestInput20(v CreateModerationRequestInput20) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateModerationRequestInput21 returns the union data inside the CreateModerationRequest_Input_2_Item as a CreateModerationRequestInput21
func (t CreateModerationRequest_Input_2_Item) AsCreateModerationRequestInput21() (CreateModerationRequestInput21, error) {
	var body CreateModerationRequestInput21
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateModerationRequestInput21 overwrites any union data inside the CreateModerationRequest_Input_2_Item as the provided CreateModerationRequestInput21
func (t *CreateModerationRequest_Input_2_Item) FromCreateModerationRequestInput21(v CreateModerationRequestInput21) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateModerationRequestInput21 performs a merge with any union data inside the CreateModerationRequest_Input_2_Item, using the provided CreateModerationRequestInput21
func (t *CreateModerationRequest_Input_2_Item) MergeCreateModerationRequestInput21(v CreateModerationRequestInput21) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateModerationRequest_Input_2_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateModerationRequest_Input_2_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateModerationRequestInput0 returns the union data inside the CreateModerationRequest_Input as a CreateModerationRequestInput0
func (t CreateModerationRequest_Input) AsCreateModerationRequestInput0() (CreateModerationRequestInput0, error) {
	var body CreateModerationRequestInput0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateModerationRequestInput0 overwrites any union data inside the CreateModerationRequest_Input as the provided CreateModerationRequestInput0
func (t *CreateModerationRequest_Input) FromCreateModerationRequestInput0(v CreateModerationRequestInput0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateModerationRequestInput0 performs a merge with any union data inside the CreateModerationRequest_Input, using the provided CreateModerationRequestInput0
func (t *CreateModerationRequest_Input) MergeCreateModerationRequestInput0(v CreateModerationRequestInput0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateModerationRequestInput1 returns the union data inside the CreateModerationRequest_Input as a CreateModerationRequestInput1
func (t CreateModerationRequest_Input) AsCreateModerationRequestInput1() (CreateModerationRequestInput1, error) {
	var body CreateModerationRequestInput1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateModerationRequestInput1 overwrites any union data inside the CreateModerationRequest_Input as the provided CreateModerationRequestInput1
func (t *CreateModerationRequest_Input) FromCreateModerationRequestInput1(v CreateModerationRequestInput1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateModerationRequestInput1 performs a merge with any union data inside the CreateModerationRequest_Input, using the provided CreateModerationRequestInput1
func (t *CreateModerationRequest_Input) MergeCreateModerationRequestInput1(v CreateModerationRequestInput1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateModerationRequestInput2 returns the union data inside the CreateModerationRequest_Input as a CreateModerationRequestInput2
func (t CreateModerationRequest_Input) AsCreateModerationRequestInput2() (CreateModerationRequestInput2, error) {
	var body CreateModerationRequestInput2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateModerationRequestInput2 overwrites any union data inside the CreateModerationRequest_Input as the provided CreateModerationRequestInput2
func (t *CreateModerationRequest_Input) FromCreateModerationRequestInput2(v CreateModerationRequestInput2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateModerationRequestInput2 performs a merge with any union data inside the CreateModerationRequest_Input, using the provided CreateModerationRequestInput2
func (t *CreateModerationRequest_Input) MergeCreateModerationRequestInput2(v CreateModerationRequestInput2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateModerationRequest_Input) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateModerationRequest_Input) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateModerationRequestModel0 returns the union data inside the CreateModerationRequest_Model as a CreateModerationRequestModel0
func (t CreateModerationRequest_Model) AsCreateModerationRequestModel0() (CreateModerationRequestModel0, error) {
	var body CreateModerationRequestModel0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateModerationRequestModel0 overwrites any union data inside the CreateModerationRequest_Model as the provided CreateModerationRequestModel0
func (t *CreateModerationRequest_Model) FromCreateModerationRequestModel0(v CreateModerationRequestModel0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateModerationRequestModel0 performs a merge with any union data inside the CreateModerationRequest_Model, using the provided CreateModerationRequestModel0
func (t *CreateModerationRequest_Model) MergeCreateModerationRequestModel0(v CreateModerationRequestModel0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateModerationRequestModel1 returns the union data inside the CreateModerationRequest_Model as a CreateModerationRequestModel1
func (t CreateModerationRequest_Model) AsCreateModerationRequestModel1() (CreateModerationRequestModel1, error) {
	var body CreateModerationRequestModel1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateModerationRequestModel1 overwrites any union data inside the CreateModerationRequest_Model as the provided CreateModerationRequestModel1
func (t *CreateModerationRequest_Model) FromCreateModerationRequestModel1(v CreateModerationRequestModel1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateModerationRequestModel1 performs a merge with any union data inside the CreateModerationRequest_Model, using the provided CreateModerationRequestModel1
func (t *CreateModerationRequest_Model) MergeCreateModerationRequestModel1(v CreateModerationRequestModel1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateModerationRequest_Model) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateModerationRequest_Model) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateRunRequestModel0 returns the union data inside the CreateRunRequest_Model as a CreateRunRequestModel0
func (t CreateRunRequest_Model) AsCreateRunRequestModel0() (CreateRunRequestModel0, error) {
	var body CreateRunRequestModel0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateRunRequestModel0 overwrites any union data inside the CreateRunRequest_Model as the provided CreateRunRequestModel0
func (t *CreateRunRequest_Model) FromCreateRunRequestModel0(v CreateRunRequestModel0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateRunRequestModel0 performs a merge with any union data inside the CreateRunRequest_Model, using the provided CreateRunRequestModel0
func (t *CreateRunRequest_Model) MergeCreateRunRequestModel0(v CreateRunRequestModel0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateRunRequestModel1 returns the union data inside the CreateRunRequest_Model as a CreateRunRequestModel1
func (t CreateRunRequest_Model) AsCreateRunRequestModel1() (CreateRunRequestModel1, error) {
	var body CreateRunRequestModel1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateRunRequestModel1 overwrites any union data inside the CreateRunRequest_Model as the provided CreateRunRequestModel1
func (t *CreateRunRequest_Model) FromCreateRunRequestModel1(v CreateRunRequestModel1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateRunRequestModel1 performs a merge with any union data inside the CreateRunRequest_Model, using the provided CreateRunRequestModel1
func (t *CreateRunRequest_Model) MergeCreateRunRequestModel1(v CreateRunRequestModel1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateRunRequest_Model) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateRunRequest_Model) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAssistantToolsCode returns the union data inside the CreateRunRequest_Tools_Item as a AssistantToolsCode
func (t CreateRunRequest_Tools_Item) AsAssistantToolsCode() (AssistantToolsCode, error) {
	var body AssistantToolsCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssistantToolsCode overwrites any union data inside the CreateRunRequest_Tools_Item as the provided AssistantToolsCode
func (t *CreateRunRequest_Tools_Item) FromAssistantToolsCode(v AssistantToolsCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssistantToolsCode performs a merge with any union data inside the CreateRunRequest_Tools_Item, using the provided AssistantToolsCode
func (t *CreateRunRequest_Tools_Item) MergeAssistantToolsCode(v AssistantToolsCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAssistantToolsFileSearch returns the union data inside the CreateRunRequest_Tools_Item as a AssistantToolsFileSearch
func (t CreateRunRequest_Tools_Item) AsAssistantToolsFileSearch() (AssistantToolsFileSearch, error) {
	var body AssistantToolsFileSearch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssistantToolsFileSearch overwrites any union data inside the CreateRunRequest_Tools_Item as the provided AssistantToolsFileSearch
func (t *CreateRunRequest_Tools_Item) FromAssistantToolsFileSearch(v AssistantToolsFileSearch) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssistantToolsFileSearch performs a merge with any union data inside the CreateRunRequest_Tools_Item, using the provided AssistantToolsFileSearch
func (t *CreateRunRequest_Tools_Item) MergeAssistantToolsFileSearch(v AssistantToolsFileSearch) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAssistantToolsFunction returns the union data inside the CreateRunRequest_Tools_Item as a AssistantToolsFunction
func (t CreateRunRequest_Tools_Item) AsAssistantToolsFunction() (AssistantToolsFunction, error) {
	var body AssistantToolsFunction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssistantToolsFunction overwrites any union data inside the CreateRunRequest_Tools_Item as the provided AssistantToolsFunction
func (t *CreateRunRequest_Tools_Item) FromAssistantToolsFunction(v AssistantToolsFunction) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssistantToolsFunction performs a merge with any union data inside the CreateRunRequest_Tools_Item, using the provided AssistantToolsFunction
func (t *CreateRunRequest_Tools_Item) MergeAssistantToolsFunction(v AssistantToolsFunction) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateRunRequest_Tools_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateRunRequest_Tools_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateSpeechRequestModel0 returns the union data inside the CreateSpeechRequest_Model as a CreateSpeechRequestModel0
func (t CreateSpeechRequest_Model) AsCreateSpeechRequestModel0() (CreateSpeechRequestModel0, error) {
	var body CreateSpeechRequestModel0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateSpeechRequestModel0 overwrites any union data inside the CreateSpeechRequest_Model as the provided CreateSpeechRequestModel0
func (t *CreateSpeechRequest_Model) FromCreateSpeechRequestModel0(v CreateSpeechRequestModel0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateSpeechRequestModel0 performs a merge with any union data inside the CreateSpeechRequest_Model, using the provided CreateSpeechRequestModel0
func (t *CreateSpeechRequest_Model) MergeCreateSpeechRequestModel0(v CreateSpeechRequestModel0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateSpeechRequestModel1 returns the union data inside the CreateSpeechRequest_Model as a CreateSpeechRequestModel1
func (t CreateSpeechRequest_Model) AsCreateSpeechRequestModel1() (CreateSpeechRequestModel1, error) {
	var body CreateSpeechRequestModel1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateSpeechRequestModel1 overwrites any union data inside the CreateSpeechRequest_Model as the provided CreateSpeechRequestModel1
func (t *CreateSpeechRequest_Model) FromCreateSpeechRequestModel1(v CreateSpeechRequestModel1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateSpeechRequestModel1 performs a merge with any union data inside the CreateSpeechRequest_Model, using the provided CreateSpeechRequestModel1
func (t *CreateSpeechRequest_Model) MergeCreateSpeechRequestModel1(v CreateSpeechRequestModel1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateSpeechRequest_Model) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateSpeechRequest_Model) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateThreadAndRunRequestModel0 returns the union data inside the CreateThreadAndRunRequest_Model as a CreateThreadAndRunRequestModel0
func (t CreateThreadAndRunRequest_Model) AsCreateThreadAndRunRequestModel0() (CreateThreadAndRunRequestModel0, error) {
	var body CreateThreadAndRunRequestModel0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateThreadAndRunRequestModel0 overwrites any union data inside the CreateThreadAndRunRequest_Model as the provided CreateThreadAndRunRequestModel0
func (t *CreateThreadAndRunRequest_Model) FromCreateThreadAndRunRequestModel0(v CreateThreadAndRunRequestModel0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateThreadAndRunRequestModel0 performs a merge with any union data inside the CreateThreadAndRunRequest_Model, using the provided CreateThreadAndRunRequestModel0
func (t *CreateThreadAndRunRequest_Model) MergeCreateThreadAndRunRequestModel0(v CreateThreadAndRunRequestModel0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateThreadAndRunRequestModel1 returns the union data inside the CreateThreadAndRunRequest_Model as a CreateThreadAndRunRequestModel1
func (t CreateThreadAndRunRequest_Model) AsCreateThreadAndRunRequestModel1() (CreateThreadAndRunRequestModel1, error) {
	var body CreateThreadAndRunRequestModel1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateThreadAndRunRequestModel1 overwrites any union data inside the CreateThreadAndRunRequest_Model as the provided CreateThreadAndRunRequestModel1
func (t *CreateThreadAndRunRequest_Model) FromCreateThreadAndRunRequestModel1(v CreateThreadAndRunRequestModel1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateThreadAndRunRequestModel1 performs a merge with any union data inside the CreateThreadAndRunRequest_Model, using the provided CreateThreadAndRunRequestModel1
func (t *CreateThreadAndRunRequest_Model) MergeCreateThreadAndRunRequestModel1(v CreateThreadAndRunRequestModel1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateThreadAndRunRequest_Model) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateThreadAndRunRequest_Model) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAssistantToolsCode returns the union data inside the CreateThreadAndRunRequest_Tools_Item as a AssistantToolsCode
func (t CreateThreadAndRunRequest_Tools_Item) AsAssistantToolsCode() (AssistantToolsCode, error) {
	var body AssistantToolsCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssistantToolsCode overwrites any union data inside the CreateThreadAndRunRequest_Tools_Item as the provided AssistantToolsCode
func (t *CreateThreadAndRunRequest_Tools_Item) FromAssistantToolsCode(v AssistantToolsCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssistantToolsCode performs a merge with any union data inside the CreateThreadAndRunRequest_Tools_Item, using the provided AssistantToolsCode
func (t *CreateThreadAndRunRequest_Tools_Item) MergeAssistantToolsCode(v AssistantToolsCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAssistantToolsFileSearch returns the union data inside the CreateThreadAndRunRequest_Tools_Item as a AssistantToolsFileSearch
func (t CreateThreadAndRunRequest_Tools_Item) AsAssistantToolsFileSearch() (AssistantToolsFileSearch, error) {
	var body AssistantToolsFileSearch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssistantToolsFileSearch overwrites any union data inside the CreateThreadAndRunRequest_Tools_Item as the provided AssistantToolsFileSearch
func (t *CreateThreadAndRunRequest_Tools_Item) FromAssistantToolsFileSearch(v AssistantToolsFileSearch) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssistantToolsFileSearch performs a merge with any union data inside the CreateThreadAndRunRequest_Tools_Item, using the provided AssistantToolsFileSearch
func (t *CreateThreadAndRunRequest_Tools_Item) MergeAssistantToolsFileSearch(v AssistantToolsFileSearch) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAssistantToolsFunction returns the union data inside the CreateThreadAndRunRequest_Tools_Item as a AssistantToolsFunction
func (t CreateThreadAndRunRequest_Tools_Item) AsAssistantToolsFunction() (AssistantToolsFunction, error) {
	var body AssistantToolsFunction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssistantToolsFunction overwrites any union data inside the CreateThreadAndRunRequest_Tools_Item as the provided AssistantToolsFunction
func (t *CreateThreadAndRunRequest_Tools_Item) FromAssistantToolsFunction(v AssistantToolsFunction) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssistantToolsFunction performs a merge with any union data inside the CreateThreadAndRunRequest_Tools_Item, using the provided AssistantToolsFunction
func (t *CreateThreadAndRunRequest_Tools_Item) MergeAssistantToolsFunction(v AssistantToolsFunction) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateThreadAndRunRequest_Tools_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateThreadAndRunRequest_Tools_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy0 returns the union data inside the CreateThreadRequest_ToolResources_FileSearch_VectorStores_ChunkingStrategy as a CreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy0
func (t CreateThreadRequest_ToolResources_FileSearch_VectorStores_ChunkingStrategy) AsCreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy0() (CreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy0, error) {
	var body CreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy0 overwrites any union data inside the CreateThreadRequest_ToolResources_FileSearch_VectorStores_ChunkingStrategy as the provided CreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy0
func (t *CreateThreadRequest_ToolResources_FileSearch_VectorStores_ChunkingStrategy) FromCreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy0(v CreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy0 performs a merge with any union data inside the CreateThreadRequest_ToolResources_FileSearch_VectorStores_ChunkingStrategy, using the provided CreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy0
func (t *CreateThreadRequest_ToolResources_FileSearch_VectorStores_ChunkingStrategy) MergeCreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy0(v CreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy1 returns the union data inside the CreateThreadRequest_ToolResources_FileSearch_VectorStores_ChunkingStrategy as a CreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy1
func (t CreateThreadRequest_ToolResources_FileSearch_VectorStores_ChunkingStrategy) AsCreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy1() (CreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy1, error) {
	var body CreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy1 overwrites any union data inside the CreateThreadRequest_ToolResources_FileSearch_VectorStores_ChunkingStrategy as the provided CreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy1
func (t *CreateThreadRequest_ToolResources_FileSearch_VectorStores_ChunkingStrategy) FromCreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy1(v CreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy1 performs a merge with any union data inside the CreateThreadRequest_ToolResources_FileSearch_VectorStores_ChunkingStrategy, using the provided CreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy1
func (t *CreateThreadRequest_ToolResources_FileSearch_VectorStores_ChunkingStrategy) MergeCreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy1(v CreateThreadRequestToolResourcesFileSearchVectorStoresChunkingStrategy1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateThreadRequest_ToolResources_FileSearch_VectorStores_ChunkingStrategy) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateThreadRequest_ToolResources_FileSearch_VectorStores_ChunkingStrategy) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateThreadRequestToolResourcesFileSearch0 returns the union data inside the CreateThreadRequest_ToolResources_FileSearch as a CreateThreadRequestToolResourcesFileSearch0
func (t CreateThreadRequest_ToolResources_FileSearch) AsCreateThreadRequestToolResourcesFileSearch0() (CreateThreadRequestToolResourcesFileSearch0, error) {
	var body CreateThreadRequestToolResourcesFileSearch0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateThreadRequestToolResourcesFileSearch0 overwrites any union data inside the CreateThreadRequest_ToolResources_FileSearch as the provided CreateThreadRequestToolResourcesFileSearch0
func (t *CreateThreadRequest_ToolResources_FileSearch) FromCreateThreadRequestToolResourcesFileSearch0(v CreateThreadRequestToolResourcesFileSearch0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateThreadRequestToolResourcesFileSearch0 performs a merge with any union data inside the CreateThreadRequest_ToolResources_FileSearch, using the provided CreateThreadRequestToolResourcesFileSearch0
func (t *CreateThreadRequest_ToolResources_FileSearch) MergeCreateThreadRequestToolResourcesFileSearch0(v CreateThreadRequestToolResourcesFileSearch0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateThreadRequestToolResourcesFileSearch1 returns the union data inside the CreateThreadRequest_ToolResources_FileSearch as a CreateThreadRequestToolResourcesFileSearch1
func (t CreateThreadRequest_ToolResources_FileSearch) AsCreateThreadRequestToolResourcesFileSearch1() (CreateThreadRequestToolResourcesFileSearch1, error) {
	var body CreateThreadRequestToolResourcesFileSearch1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateThreadRequestToolResourcesFileSearch1 overwrites any union data inside the CreateThreadRequest_ToolResources_FileSearch as the provided CreateThreadRequestToolResourcesFileSearch1
func (t *CreateThreadRequest_ToolResources_FileSearch) FromCreateThreadRequestToolResourcesFileSearch1(v CreateThreadRequestToolResourcesFileSearch1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateThreadRequestToolResourcesFileSearch1 performs a merge with any union data inside the CreateThreadRequest_ToolResources_FileSearch, using the provided CreateThreadRequestToolResourcesFileSearch1
func (t *CreateThreadRequest_ToolResources_FileSearch) MergeCreateThreadRequestToolResourcesFileSearch1(v CreateThreadRequestToolResourcesFileSearch1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateThreadRequest_ToolResources_FileSearch) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.VectorStoreIds != nil {
		object["vector_store_ids"], err = json.Marshal(t.VectorStoreIds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'vector_store_ids': %w", err)
		}
	}

	if t.VectorStores != nil {
		object["vector_stores"], err = json.Marshal(t.VectorStores)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'vector_stores': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *CreateThreadRequest_ToolResources_FileSearch) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["vector_store_ids"]; found {
		err = json.Unmarshal(raw, &t.VectorStoreIds)
		if err != nil {
			return fmt.Errorf("error reading 'vector_store_ids': %w", err)
		}
	}

	if raw, found := object["vector_stores"]; found {
		err = json.Unmarshal(raw, &t.VectorStores)
		if err != nil {
			return fmt.Errorf("error reading 'vector_stores': %w", err)
		}
	}

	return err
}

// AsCreateTranscriptionRequestModel0 returns the union data inside the CreateTranscriptionRequest_Model as a CreateTranscriptionRequestModel0
func (t CreateTranscriptionRequest_Model) AsCreateTranscriptionRequestModel0() (CreateTranscriptionRequestModel0, error) {
	var body CreateTranscriptionRequestModel0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateTranscriptionRequestModel0 overwrites any union data inside the CreateTranscriptionRequest_Model as the provided CreateTranscriptionRequestModel0
func (t *CreateTranscriptionRequest_Model) FromCreateTranscriptionRequestModel0(v CreateTranscriptionRequestModel0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateTranscriptionRequestModel0 performs a merge with any union data inside the CreateTranscriptionRequest_Model, using the provided CreateTranscriptionRequestModel0
func (t *CreateTranscriptionRequest_Model) MergeCreateTranscriptionRequestModel0(v CreateTranscriptionRequestModel0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateTranscriptionRequestModel1 returns the union data inside the CreateTranscriptionRequest_Model as a CreateTranscriptionRequestModel1
func (t CreateTranscriptionRequest_Model) AsCreateTranscriptionRequestModel1() (CreateTranscriptionRequestModel1, error) {
	var body CreateTranscriptionRequestModel1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateTranscriptionRequestModel1 overwrites any union data inside the CreateTranscriptionRequest_Model as the provided CreateTranscriptionRequestModel1
func (t *CreateTranscriptionRequest_Model) FromCreateTranscriptionRequestModel1(v CreateTranscriptionRequestModel1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateTranscriptionRequestModel1 performs a merge with any union data inside the CreateTranscriptionRequest_Model, using the provided CreateTranscriptionRequestModel1
func (t *CreateTranscriptionRequest_Model) MergeCreateTranscriptionRequestModel1(v CreateTranscriptionRequestModel1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateTranscriptionRequest_Model) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateTranscriptionRequest_Model) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateTranslationRequestModel0 returns the union data inside the CreateTranslationRequest_Model as a CreateTranslationRequestModel0
func (t CreateTranslationRequest_Model) AsCreateTranslationRequestModel0() (CreateTranslationRequestModel0, error) {
	var body CreateTranslationRequestModel0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateTranslationRequestModel0 overwrites any union data inside the CreateTranslationRequest_Model as the provided CreateTranslationRequestModel0
func (t *CreateTranslationRequest_Model) FromCreateTranslationRequestModel0(v CreateTranslationRequestModel0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateTranslationRequestModel0 performs a merge with any union data inside the CreateTranslationRequest_Model, using the provided CreateTranslationRequestModel0
func (t *CreateTranslationRequest_Model) MergeCreateTranslationRequestModel0(v CreateTranslationRequestModel0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateTranslationRequestModel1 returns the union data inside the CreateTranslationRequest_Model as a CreateTranslationRequestModel1
func (t CreateTranslationRequest_Model) AsCreateTranslationRequestModel1() (CreateTranslationRequestModel1, error) {
	var body CreateTranslationRequestModel1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateTranslationRequestModel1 overwrites any union data inside the CreateTranslationRequest_Model as the provided CreateTranslationRequestModel1
func (t *CreateTranslationRequest_Model) FromCreateTranslationRequestModel1(v CreateTranslationRequestModel1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateTranslationRequestModel1 performs a merge with any union data inside the CreateTranslationRequest_Model, using the provided CreateTranslationRequestModel1
func (t *CreateTranslationRequest_Model) MergeCreateTranslationRequestModel1(v CreateTranslationRequestModel1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateTranslationRequest_Model) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateTranslationRequest_Model) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAutoChunkingStrategyRequestParam returns the union data inside the CreateVectorStoreRequest_ChunkingStrategy as a AutoChunkingStrategyRequestParam
func (t CreateVectorStoreRequest_ChunkingStrategy) AsAutoChunkingStrategyRequestParam() (AutoChunkingStrategyRequestParam, error) {
	var body AutoChunkingStrategyRequestParam
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAutoChunkingStrategyRequestParam overwrites any union data inside the CreateVectorStoreRequest_ChunkingStrategy as the provided AutoChunkingStrategyRequestParam
func (t *CreateVectorStoreRequest_ChunkingStrategy) FromAutoChunkingStrategyRequestParam(v AutoChunkingStrategyRequestParam) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAutoChunkingStrategyRequestParam performs a merge with any union data inside the CreateVectorStoreRequest_ChunkingStrategy, using the provided AutoChunkingStrategyRequestParam
func (t *CreateVectorStoreRequest_ChunkingStrategy) MergeAutoChunkingStrategyRequestParam(v AutoChunkingStrategyRequestParam) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStaticChunkingStrategyRequestParam returns the union data inside the CreateVectorStoreRequest_ChunkingStrategy as a StaticChunkingStrategyRequestParam
func (t CreateVectorStoreRequest_ChunkingStrategy) AsStaticChunkingStrategyRequestParam() (StaticChunkingStrategyRequestParam, error) {
	var body StaticChunkingStrategyRequestParam
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStaticChunkingStrategyRequestParam overwrites any union data inside the CreateVectorStoreRequest_ChunkingStrategy as the provided StaticChunkingStrategyRequestParam
func (t *CreateVectorStoreRequest_ChunkingStrategy) FromStaticChunkingStrategyRequestParam(v StaticChunkingStrategyRequestParam) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStaticChunkingStrategyRequestParam performs a merge with any union data inside the CreateVectorStoreRequest_ChunkingStrategy, using the provided StaticChunkingStrategyRequestParam
func (t *CreateVectorStoreRequest_ChunkingStrategy) MergeStaticChunkingStrategyRequestParam(v StaticChunkingStrategyRequestParam) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateVectorStoreRequest_ChunkingStrategy) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateVectorStoreRequest_ChunkingStrategy) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFineTuningJobHyperparametersNEpochs0 returns the union data inside the FineTuningJob_Hyperparameters_NEpochs as a FineTuningJobHyperparametersNEpochs0
func (t FineTuningJob_Hyperparameters_NEpochs) AsFineTuningJobHyperparametersNEpochs0() (FineTuningJobHyperparametersNEpochs0, error) {
	var body FineTuningJobHyperparametersNEpochs0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFineTuningJobHyperparametersNEpochs0 overwrites any union data inside the FineTuningJob_Hyperparameters_NEpochs as the provided FineTuningJobHyperparametersNEpochs0
func (t *FineTuningJob_Hyperparameters_NEpochs) FromFineTuningJobHyperparametersNEpochs0(v FineTuningJobHyperparametersNEpochs0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFineTuningJobHyperparametersNEpochs0 performs a merge with any union data inside the FineTuningJob_Hyperparameters_NEpochs, using the provided FineTuningJobHyperparametersNEpochs0
func (t *FineTuningJob_Hyperparameters_NEpochs) MergeFineTuningJobHyperparametersNEpochs0(v FineTuningJobHyperparametersNEpochs0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFineTuningJobHyperparametersNEpochs1 returns the union data inside the FineTuningJob_Hyperparameters_NEpochs as a FineTuningJobHyperparametersNEpochs1
func (t FineTuningJob_Hyperparameters_NEpochs) AsFineTuningJobHyperparametersNEpochs1() (FineTuningJobHyperparametersNEpochs1, error) {
	var body FineTuningJobHyperparametersNEpochs1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFineTuningJobHyperparametersNEpochs1 overwrites any union data inside the FineTuningJob_Hyperparameters_NEpochs as the provided FineTuningJobHyperparametersNEpochs1
func (t *FineTuningJob_Hyperparameters_NEpochs) FromFineTuningJobHyperparametersNEpochs1(v FineTuningJobHyperparametersNEpochs1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFineTuningJobHyperparametersNEpochs1 performs a merge with any union data inside the FineTuningJob_Hyperparameters_NEpochs, using the provided FineTuningJobHyperparametersNEpochs1
func (t *FineTuningJob_Hyperparameters_NEpochs) MergeFineTuningJobHyperparametersNEpochs1(v FineTuningJobHyperparametersNEpochs1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t FineTuningJob_Hyperparameters_NEpochs) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FineTuningJob_Hyperparameters_NEpochs) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFineTuningIntegration returns the union data inside the FineTuningJob_Integrations_Item as a FineTuningIntegration
func (t FineTuningJob_Integrations_Item) AsFineTuningIntegration() (FineTuningIntegration, error) {
	var body FineTuningIntegration
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFineTuningIntegration overwrites any union data inside the FineTuningJob_Integrations_Item as the provided FineTuningIntegration
func (t *FineTuningJob_Integrations_Item) FromFineTuningIntegration(v FineTuningIntegration) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFineTuningIntegration performs a merge with any union data inside the FineTuningJob_Integrations_Item, using the provided FineTuningIntegration
func (t *FineTuningJob_Integrations_Item) MergeFineTuningIntegration(v FineTuningIntegration) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t FineTuningJob_Integrations_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FineTuningJob_Integrations_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMessageContentTextAnnotationsFileCitationObject returns the union data inside the MessageContentTextObject_Text_Annotations_Item as a MessageContentTextAnnotationsFileCitationObject
func (t MessageContentTextObject_Text_Annotations_Item) AsMessageContentTextAnnotationsFileCitationObject() (MessageContentTextAnnotationsFileCitationObject, error) {
	var body MessageContentTextAnnotationsFileCitationObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMessageContentTextAnnotationsFileCitationObject overwrites any union data inside the MessageContentTextObject_Text_Annotations_Item as the provided MessageContentTextAnnotationsFileCitationObject
func (t *MessageContentTextObject_Text_Annotations_Item) FromMessageContentTextAnnotationsFileCitationObject(v MessageContentTextAnnotationsFileCitationObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMessageContentTextAnnotationsFileCitationObject performs a merge with any union data inside the MessageContentTextObject_Text_Annotations_Item, using the provided MessageContentTextAnnotationsFileCitationObject
func (t *MessageContentTextObject_Text_Annotations_Item) MergeMessageContentTextAnnotationsFileCitationObject(v MessageContentTextAnnotationsFileCitationObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMessageContentTextAnnotationsFilePathObject returns the union data inside the MessageContentTextObject_Text_Annotations_Item as a MessageContentTextAnnotationsFilePathObject
func (t MessageContentTextObject_Text_Annotations_Item) AsMessageContentTextAnnotationsFilePathObject() (MessageContentTextAnnotationsFilePathObject, error) {
	var body MessageContentTextAnnotationsFilePathObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMessageContentTextAnnotationsFilePathObject overwrites any union data inside the MessageContentTextObject_Text_Annotations_Item as the provided MessageContentTextAnnotationsFilePathObject
func (t *MessageContentTextObject_Text_Annotations_Item) FromMessageContentTextAnnotationsFilePathObject(v MessageContentTextAnnotationsFilePathObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMessageContentTextAnnotationsFilePathObject performs a merge with any union data inside the MessageContentTextObject_Text_Annotations_Item, using the provided MessageContentTextAnnotationsFilePathObject
func (t *MessageContentTextObject_Text_Annotations_Item) MergeMessageContentTextAnnotationsFilePathObject(v MessageContentTextAnnotationsFilePathObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MessageContentTextObject_Text_Annotations_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MessageContentTextObject_Text_Annotations_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAssistantToolsCode returns the union data inside the MessageObject_Attachments_Tools_Item as a AssistantToolsCode
func (t MessageObject_Attachments_Tools_Item) AsAssistantToolsCode() (AssistantToolsCode, error) {
	var body AssistantToolsCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssistantToolsCode overwrites any union data inside the MessageObject_Attachments_Tools_Item as the provided AssistantToolsCode
func (t *MessageObject_Attachments_Tools_Item) FromAssistantToolsCode(v AssistantToolsCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssistantToolsCode performs a merge with any union data inside the MessageObject_Attachments_Tools_Item, using the provided AssistantToolsCode
func (t *MessageObject_Attachments_Tools_Item) MergeAssistantToolsCode(v AssistantToolsCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAssistantToolsFileSearchTypeOnly returns the union data inside the MessageObject_Attachments_Tools_Item as a AssistantToolsFileSearchTypeOnly
func (t MessageObject_Attachments_Tools_Item) AsAssistantToolsFileSearchTypeOnly() (AssistantToolsFileSearchTypeOnly, error) {
	var body AssistantToolsFileSearchTypeOnly
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssistantToolsFileSearchTypeOnly overwrites any union data inside the MessageObject_Attachments_Tools_Item as the provided AssistantToolsFileSearchTypeOnly
func (t *MessageObject_Attachments_Tools_Item) FromAssistantToolsFileSearchTypeOnly(v AssistantToolsFileSearchTypeOnly) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssistantToolsFileSearchTypeOnly performs a merge with any union data inside the MessageObject_Attachments_Tools_Item, using the provided AssistantToolsFileSearchTypeOnly
func (t *MessageObject_Attachments_Tools_Item) MergeAssistantToolsFileSearchTypeOnly(v AssistantToolsFileSearchTypeOnly) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MessageObject_Attachments_Tools_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MessageObject_Attachments_Tools_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMessageContentImageFileObject returns the union data inside the MessageObject_Content_Item as a MessageContentImageFileObject
func (t MessageObject_Content_Item) AsMessageContentImageFileObject() (MessageContentImageFileObject, error) {
	var body MessageContentImageFileObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMessageContentImageFileObject overwrites any union data inside the MessageObject_Content_Item as the provided MessageContentImageFileObject
func (t *MessageObject_Content_Item) FromMessageContentImageFileObject(v MessageContentImageFileObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMessageContentImageFileObject performs a merge with any union data inside the MessageObject_Content_Item, using the provided MessageContentImageFileObject
func (t *MessageObject_Content_Item) MergeMessageContentImageFileObject(v MessageContentImageFileObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMessageContentImageUrlObject returns the union data inside the MessageObject_Content_Item as a MessageContentImageUrlObject
func (t MessageObject_Content_Item) AsMessageContentImageUrlObject() (MessageContentImageUrlObject, error) {
	var body MessageContentImageUrlObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMessageContentImageUrlObject overwrites any union data inside the MessageObject_Content_Item as the provided MessageContentImageUrlObject
func (t *MessageObject_Content_Item) FromMessageContentImageUrlObject(v MessageContentImageUrlObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMessageContentImageUrlObject performs a merge with any union data inside the MessageObject_Content_Item, using the provided MessageContentImageUrlObject
func (t *MessageObject_Content_Item) MergeMessageContentImageUrlObject(v MessageContentImageUrlObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMessageContentTextObject returns the union data inside the MessageObject_Content_Item as a MessageContentTextObject
func (t MessageObject_Content_Item) AsMessageContentTextObject() (MessageContentTextObject, error) {
	var body MessageContentTextObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMessageContentTextObject overwrites any union data inside the MessageObject_Content_Item as the provided MessageContentTextObject
func (t *MessageObject_Content_Item) FromMessageContentTextObject(v MessageContentTextObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMessageContentTextObject performs a merge with any union data inside the MessageObject_Content_Item, using the provided MessageContentTextObject
func (t *MessageObject_Content_Item) MergeMessageContentTextObject(v MessageContentTextObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMessageContentRefusalObject returns the union data inside the MessageObject_Content_Item as a MessageContentRefusalObject
func (t MessageObject_Content_Item) AsMessageContentRefusalObject() (MessageContentRefusalObject, error) {
	var body MessageContentRefusalObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMessageContentRefusalObject overwrites any union data inside the MessageObject_Content_Item as the provided MessageContentRefusalObject
func (t *MessageObject_Content_Item) FromMessageContentRefusalObject(v MessageContentRefusalObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMessageContentRefusalObject performs a merge with any union data inside the MessageObject_Content_Item, using the provided MessageContentRefusalObject
func (t *MessageObject_Content_Item) MergeMessageContentRefusalObject(v MessageContentRefusalObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MessageObject_Content_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MessageObject_Content_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsModifyAssistantRequestModel0 returns the union data inside the ModifyAssistantRequest_Model as a ModifyAssistantRequestModel0
func (t ModifyAssistantRequest_Model) AsModifyAssistantRequestModel0() (ModifyAssistantRequestModel0, error) {
	var body ModifyAssistantRequestModel0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromModifyAssistantRequestModel0 overwrites any union data inside the ModifyAssistantRequest_Model as the provided ModifyAssistantRequestModel0
func (t *ModifyAssistantRequest_Model) FromModifyAssistantRequestModel0(v ModifyAssistantRequestModel0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeModifyAssistantRequestModel0 performs a merge with any union data inside the ModifyAssistantRequest_Model, using the provided ModifyAssistantRequestModel0
func (t *ModifyAssistantRequest_Model) MergeModifyAssistantRequestModel0(v ModifyAssistantRequestModel0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ModifyAssistantRequest_Model) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ModifyAssistantRequest_Model) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAssistantToolsCode returns the union data inside the ModifyAssistantRequest_Tools_Item as a AssistantToolsCode
func (t ModifyAssistantRequest_Tools_Item) AsAssistantToolsCode() (AssistantToolsCode, error) {
	var body AssistantToolsCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssistantToolsCode overwrites any union data inside the ModifyAssistantRequest_Tools_Item as the provided AssistantToolsCode
func (t *ModifyAssistantRequest_Tools_Item) FromAssistantToolsCode(v AssistantToolsCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssistantToolsCode performs a merge with any union data inside the ModifyAssistantRequest_Tools_Item, using the provided AssistantToolsCode
func (t *ModifyAssistantRequest_Tools_Item) MergeAssistantToolsCode(v AssistantToolsCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAssistantToolsFileSearch returns the union data inside the ModifyAssistantRequest_Tools_Item as a AssistantToolsFileSearch
func (t ModifyAssistantRequest_Tools_Item) AsAssistantToolsFileSearch() (AssistantToolsFileSearch, error) {
	var body AssistantToolsFileSearch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssistantToolsFileSearch overwrites any union data inside the ModifyAssistantRequest_Tools_Item as the provided AssistantToolsFileSearch
func (t *ModifyAssistantRequest_Tools_Item) FromAssistantToolsFileSearch(v AssistantToolsFileSearch) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssistantToolsFileSearch performs a merge with any union data inside the ModifyAssistantRequest_Tools_Item, using the provided AssistantToolsFileSearch
func (t *ModifyAssistantRequest_Tools_Item) MergeAssistantToolsFileSearch(v AssistantToolsFileSearch) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAssistantToolsFunction returns the union data inside the ModifyAssistantRequest_Tools_Item as a AssistantToolsFunction
func (t ModifyAssistantRequest_Tools_Item) AsAssistantToolsFunction() (AssistantToolsFunction, error) {
	var body AssistantToolsFunction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssistantToolsFunction overwrites any union data inside the ModifyAssistantRequest_Tools_Item as the provided AssistantToolsFunction
func (t *ModifyAssistantRequest_Tools_Item) FromAssistantToolsFunction(v AssistantToolsFunction) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssistantToolsFunction performs a merge with any union data inside the ModifyAssistantRequest_Tools_Item, using the provided AssistantToolsFunction
func (t *ModifyAssistantRequest_Tools_Item) MergeAssistantToolsFunction(v AssistantToolsFunction) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ModifyAssistantRequest_Tools_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ModifyAssistantRequest_Tools_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPredictionContentContent0 returns the union data inside the PredictionContent_Content as a PredictionContentContent0
func (t PredictionContent_Content) AsPredictionContentContent0() (PredictionContentContent0, error) {
	var body PredictionContentContent0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPredictionContentContent0 overwrites any union data inside the PredictionContent_Content as the provided PredictionContentContent0
func (t *PredictionContent_Content) FromPredictionContentContent0(v PredictionContentContent0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePredictionContentContent0 performs a merge with any union data inside the PredictionContent_Content, using the provided PredictionContentContent0
func (t *PredictionContent_Content) MergePredictionContentContent0(v PredictionContentContent0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPredictionContentContent1 returns the union data inside the PredictionContent_Content as a PredictionContentContent1
func (t PredictionContent_Content) AsPredictionContentContent1() (PredictionContentContent1, error) {
	var body PredictionContentContent1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPredictionContentContent1 overwrites any union data inside the PredictionContent_Content as the provided PredictionContentContent1
func (t *PredictionContent_Content) FromPredictionContentContent1(v PredictionContentContent1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePredictionContentContent1 performs a merge with any union data inside the PredictionContent_Content, using the provided PredictionContentContent1
func (t *PredictionContent_Content) MergePredictionContentContent1(v PredictionContentContent1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PredictionContent_Content) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PredictionContent_Content) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAssistantToolsCode returns the union data inside the RunObject_Tools_Item as a AssistantToolsCode
func (t RunObject_Tools_Item) AsAssistantToolsCode() (AssistantToolsCode, error) {
	var body AssistantToolsCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssistantToolsCode overwrites any union data inside the RunObject_Tools_Item as the provided AssistantToolsCode
func (t *RunObject_Tools_Item) FromAssistantToolsCode(v AssistantToolsCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssistantToolsCode performs a merge with any union data inside the RunObject_Tools_Item, using the provided AssistantToolsCode
func (t *RunObject_Tools_Item) MergeAssistantToolsCode(v AssistantToolsCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAssistantToolsFileSearch returns the union data inside the RunObject_Tools_Item as a AssistantToolsFileSearch
func (t RunObject_Tools_Item) AsAssistantToolsFileSearch() (AssistantToolsFileSearch, error) {
	var body AssistantToolsFileSearch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssistantToolsFileSearch overwrites any union data inside the RunObject_Tools_Item as the provided AssistantToolsFileSearch
func (t *RunObject_Tools_Item) FromAssistantToolsFileSearch(v AssistantToolsFileSearch) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssistantToolsFileSearch performs a merge with any union data inside the RunObject_Tools_Item, using the provided AssistantToolsFileSearch
func (t *RunObject_Tools_Item) MergeAssistantToolsFileSearch(v AssistantToolsFileSearch) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAssistantToolsFunction returns the union data inside the RunObject_Tools_Item as a AssistantToolsFunction
func (t RunObject_Tools_Item) AsAssistantToolsFunction() (AssistantToolsFunction, error) {
	var body AssistantToolsFunction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssistantToolsFunction overwrites any union data inside the RunObject_Tools_Item as the provided AssistantToolsFunction
func (t *RunObject_Tools_Item) FromAssistantToolsFunction(v AssistantToolsFunction) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssistantToolsFunction performs a merge with any union data inside the RunObject_Tools_Item, using the provided AssistantToolsFunction
func (t *RunObject_Tools_Item) MergeAssistantToolsFunction(v AssistantToolsFunction) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RunObject_Tools_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RunObject_Tools_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRunStepDetailsToolCallsCodeOutputLogsObject returns the union data inside the RunStepDetailsToolCallsCodeObject_CodeInterpreter_Outputs_Item as a RunStepDetailsToolCallsCodeOutputLogsObject
func (t RunStepDetailsToolCallsCodeObject_CodeInterpreter_Outputs_Item) AsRunStepDetailsToolCallsCodeOutputLogsObject() (RunStepDetailsToolCallsCodeOutputLogsObject, error) {
	var body RunStepDetailsToolCallsCodeOutputLogsObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRunStepDetailsToolCallsCodeOutputLogsObject overwrites any union data inside the RunStepDetailsToolCallsCodeObject_CodeInterpreter_Outputs_Item as the provided RunStepDetailsToolCallsCodeOutputLogsObject
func (t *RunStepDetailsToolCallsCodeObject_CodeInterpreter_Outputs_Item) FromRunStepDetailsToolCallsCodeOutputLogsObject(v RunStepDetailsToolCallsCodeOutputLogsObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRunStepDetailsToolCallsCodeOutputLogsObject performs a merge with any union data inside the RunStepDetailsToolCallsCodeObject_CodeInterpreter_Outputs_Item, using the provided RunStepDetailsToolCallsCodeOutputLogsObject
func (t *RunStepDetailsToolCallsCodeObject_CodeInterpreter_Outputs_Item) MergeRunStepDetailsToolCallsCodeOutputLogsObject(v RunStepDetailsToolCallsCodeOutputLogsObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRunStepDetailsToolCallsCodeOutputImageObject returns the union data inside the RunStepDetailsToolCallsCodeObject_CodeInterpreter_Outputs_Item as a RunStepDetailsToolCallsCodeOutputImageObject
func (t RunStepDetailsToolCallsCodeObject_CodeInterpreter_Outputs_Item) AsRunStepDetailsToolCallsCodeOutputImageObject() (RunStepDetailsToolCallsCodeOutputImageObject, error) {
	var body RunStepDetailsToolCallsCodeOutputImageObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRunStepDetailsToolCallsCodeOutputImageObject overwrites any union data inside the RunStepDetailsToolCallsCodeObject_CodeInterpreter_Outputs_Item as the provided RunStepDetailsToolCallsCodeOutputImageObject
func (t *RunStepDetailsToolCallsCodeObject_CodeInterpreter_Outputs_Item) FromRunStepDetailsToolCallsCodeOutputImageObject(v RunStepDetailsToolCallsCodeOutputImageObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRunStepDetailsToolCallsCodeOutputImageObject performs a merge with any union data inside the RunStepDetailsToolCallsCodeObject_CodeInterpreter_Outputs_Item, using the provided RunStepDetailsToolCallsCodeOutputImageObject
func (t *RunStepDetailsToolCallsCodeObject_CodeInterpreter_Outputs_Item) MergeRunStepDetailsToolCallsCodeOutputImageObject(v RunStepDetailsToolCallsCodeOutputImageObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RunStepDetailsToolCallsCodeObject_CodeInterpreter_Outputs_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RunStepDetailsToolCallsCodeObject_CodeInterpreter_Outputs_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRunStepDetailsToolCallsCodeObject returns the union data inside the RunStepDetailsToolCallsObject_ToolCalls_Item as a RunStepDetailsToolCallsCodeObject
func (t RunStepDetailsToolCallsObject_ToolCalls_Item) AsRunStepDetailsToolCallsCodeObject() (RunStepDetailsToolCallsCodeObject, error) {
	var body RunStepDetailsToolCallsCodeObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRunStepDetailsToolCallsCodeObject overwrites any union data inside the RunStepDetailsToolCallsObject_ToolCalls_Item as the provided RunStepDetailsToolCallsCodeObject
func (t *RunStepDetailsToolCallsObject_ToolCalls_Item) FromRunStepDetailsToolCallsCodeObject(v RunStepDetailsToolCallsCodeObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRunStepDetailsToolCallsCodeObject performs a merge with any union data inside the RunStepDetailsToolCallsObject_ToolCalls_Item, using the provided RunStepDetailsToolCallsCodeObject
func (t *RunStepDetailsToolCallsObject_ToolCalls_Item) MergeRunStepDetailsToolCallsCodeObject(v RunStepDetailsToolCallsCodeObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRunStepDetailsToolCallsFileSearchObject returns the union data inside the RunStepDetailsToolCallsObject_ToolCalls_Item as a RunStepDetailsToolCallsFileSearchObject
func (t RunStepDetailsToolCallsObject_ToolCalls_Item) AsRunStepDetailsToolCallsFileSearchObject() (RunStepDetailsToolCallsFileSearchObject, error) {
	var body RunStepDetailsToolCallsFileSearchObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRunStepDetailsToolCallsFileSearchObject overwrites any union data inside the RunStepDetailsToolCallsObject_ToolCalls_Item as the provided RunStepDetailsToolCallsFileSearchObject
func (t *RunStepDetailsToolCallsObject_ToolCalls_Item) FromRunStepDetailsToolCallsFileSearchObject(v RunStepDetailsToolCallsFileSearchObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRunStepDetailsToolCallsFileSearchObject performs a merge with any union data inside the RunStepDetailsToolCallsObject_ToolCalls_Item, using the provided RunStepDetailsToolCallsFileSearchObject
func (t *RunStepDetailsToolCallsObject_ToolCalls_Item) MergeRunStepDetailsToolCallsFileSearchObject(v RunStepDetailsToolCallsFileSearchObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRunStepDetailsToolCallsFunctionObject returns the union data inside the RunStepDetailsToolCallsObject_ToolCalls_Item as a RunStepDetailsToolCallsFunctionObject
func (t RunStepDetailsToolCallsObject_ToolCalls_Item) AsRunStepDetailsToolCallsFunctionObject() (RunStepDetailsToolCallsFunctionObject, error) {
	var body RunStepDetailsToolCallsFunctionObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRunStepDetailsToolCallsFunctionObject overwrites any union data inside the RunStepDetailsToolCallsObject_ToolCalls_Item as the provided RunStepDetailsToolCallsFunctionObject
func (t *RunStepDetailsToolCallsObject_ToolCalls_Item) FromRunStepDetailsToolCallsFunctionObject(v RunStepDetailsToolCallsFunctionObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRunStepDetailsToolCallsFunctionObject performs a merge with any union data inside the RunStepDetailsToolCallsObject_ToolCalls_Item, using the provided RunStepDetailsToolCallsFunctionObject
func (t *RunStepDetailsToolCallsObject_ToolCalls_Item) MergeRunStepDetailsToolCallsFunctionObject(v RunStepDetailsToolCallsFunctionObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RunStepDetailsToolCallsObject_ToolCalls_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RunStepDetailsToolCallsObject_ToolCalls_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRunStepDetailsMessageCreationObject returns the union data inside the RunStepObject_StepDetails as a RunStepDetailsMessageCreationObject
func (t RunStepObject_StepDetails) AsRunStepDetailsMessageCreationObject() (RunStepDetailsMessageCreationObject, error) {
	var body RunStepDetailsMessageCreationObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRunStepDetailsMessageCreationObject overwrites any union data inside the RunStepObject_StepDetails as the provided RunStepDetailsMessageCreationObject
func (t *RunStepObject_StepDetails) FromRunStepDetailsMessageCreationObject(v RunStepDetailsMessageCreationObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRunStepDetailsMessageCreationObject performs a merge with any union data inside the RunStepObject_StepDetails, using the provided RunStepDetailsMessageCreationObject
func (t *RunStepObject_StepDetails) MergeRunStepDetailsMessageCreationObject(v RunStepDetailsMessageCreationObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRunStepDetailsToolCallsObject returns the union data inside the RunStepObject_StepDetails as a RunStepDetailsToolCallsObject
func (t RunStepObject_StepDetails) AsRunStepDetailsToolCallsObject() (RunStepDetailsToolCallsObject, error) {
	var body RunStepDetailsToolCallsObject
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRunStepDetailsToolCallsObject overwrites any union data inside the RunStepObject_StepDetails as the provided RunStepDetailsToolCallsObject
func (t *RunStepObject_StepDetails) FromRunStepDetailsToolCallsObject(v RunStepDetailsToolCallsObject) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRunStepDetailsToolCallsObject performs a merge with any union data inside the RunStepObject_StepDetails, using the provided RunStepDetailsToolCallsObject
func (t *RunStepObject_StepDetails) MergeRunStepDetailsToolCallsObject(v RunStepDetailsToolCallsObject) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RunStepObject_StepDetails) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RunStepObject_StepDetails) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStaticChunkingStrategyResponseParam returns the union data inside the VectorStoreFileObject_ChunkingStrategy as a StaticChunkingStrategyResponseParam
func (t VectorStoreFileObject_ChunkingStrategy) AsStaticChunkingStrategyResponseParam() (StaticChunkingStrategyResponseParam, error) {
	var body StaticChunkingStrategyResponseParam
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStaticChunkingStrategyResponseParam overwrites any union data inside the VectorStoreFileObject_ChunkingStrategy as the provided StaticChunkingStrategyResponseParam
func (t *VectorStoreFileObject_ChunkingStrategy) FromStaticChunkingStrategyResponseParam(v StaticChunkingStrategyResponseParam) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStaticChunkingStrategyResponseParam performs a merge with any union data inside the VectorStoreFileObject_ChunkingStrategy, using the provided StaticChunkingStrategyResponseParam
func (t *VectorStoreFileObject_ChunkingStrategy) MergeStaticChunkingStrategyResponseParam(v StaticChunkingStrategyResponseParam) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOtherChunkingStrategyResponseParam returns the union data inside the VectorStoreFileObject_ChunkingStrategy as a OtherChunkingStrategyResponseParam
func (t VectorStoreFileObject_ChunkingStrategy) AsOtherChunkingStrategyResponseParam() (OtherChunkingStrategyResponseParam, error) {
	var body OtherChunkingStrategyResponseParam
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOtherChunkingStrategyResponseParam overwrites any union data inside the VectorStoreFileObject_ChunkingStrategy as the provided OtherChunkingStrategyResponseParam
func (t *VectorStoreFileObject_ChunkingStrategy) FromOtherChunkingStrategyResponseParam(v OtherChunkingStrategyResponseParam) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOtherChunkingStrategyResponseParam performs a merge with any union data inside the VectorStoreFileObject_ChunkingStrategy, using the provided OtherChunkingStrategyResponseParam
func (t *VectorStoreFileObject_ChunkingStrategy) MergeOtherChunkingStrategyResponseParam(v OtherChunkingStrategyResponseParam) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t VectorStoreFileObject_ChunkingStrategy) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *VectorStoreFileObject_ChunkingStrategy) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListAssistants request
	ListAssistants(ctx context.Context, params *ListAssistantsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAssistantWithBody request with any body
	CreateAssistantWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAssistant(ctx context.Context, body CreateAssistantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAssistant request
	DeleteAssistant(ctx context.Context, assistantId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssistant request
	GetAssistant(ctx context.Context, assistantId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModifyAssistantWithBody request with any body
	ModifyAssistantWithBody(ctx context.Context, assistantId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ModifyAssistant(ctx context.Context, assistantId string, body ModifyAssistantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSpeechWithBody request with any body
	CreateSpeechWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSpeech(ctx context.Context, body CreateSpeechJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTranscriptionWithBody request with any body
	CreateTranscriptionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTranslationWithBody request with any body
	CreateTranslationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBatches request
	ListBatches(ctx context.Context, params *ListBatchesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBatchWithBody request with any body
	CreateBatchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBatch(ctx context.Context, body CreateBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveBatch request
	RetrieveBatch(ctx context.Context, batchId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelBatch request
	CancelBatch(ctx context.Context, batchId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateChatCompletionWithBody request with any body
	CreateChatCompletionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateChatCompletion(ctx context.Context, body CreateChatCompletionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCompletionWithBody request with any body
	CreateCompletionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCompletion(ctx context.Context, body CreateCompletionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEmbeddingWithBody request with any body
	CreateEmbeddingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEmbedding(ctx context.Context, body CreateEmbeddingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFiles request
	ListFiles(ctx context.Context, params *ListFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFileWithBody request with any body
	CreateFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFile request
	DeleteFile(ctx context.Context, fileId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveFile request
	RetrieveFile(ctx context.Context, fileId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadFile request
	DownloadFile(ctx context.Context, fileId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPaginatedFineTuningJobs request
	ListPaginatedFineTuningJobs(ctx context.Context, params *ListPaginatedFineTuningJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFineTuningJobWithBody request with any body
	CreateFineTuningJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFineTuningJob(ctx context.Context, body CreateFineTuningJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveFineTuningJob request
	RetrieveFineTuningJob(ctx context.Context, fineTuningJobId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelFineTuningJob request
	CancelFineTuningJob(ctx context.Context, fineTuningJobId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFineTuningJobCheckpoints request
	ListFineTuningJobCheckpoints(ctx context.Context, fineTuningJobId string, params *ListFineTuningJobCheckpointsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFineTuningEvents request
	ListFineTuningEvents(ctx context.Context, fineTuningJobId string, params *ListFineTuningEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateImageEditWithBody request with any body
	CreateImageEditWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateImageWithBody request with any body
	CreateImageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateImage(ctx context.Context, body CreateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateImageVariationWithBody request with any body
	CreateImageVariationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListModels request
	ListModels(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteModel request
	DeleteModel(ctx context.Context, model string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveModel request
	RetrieveModel(ctx context.Context, model string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateModerationWithBody request with any body
	CreateModerationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateModeration(ctx context.Context, body CreateModerationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAuditLogs request
	ListAuditLogs(ctx context.Context, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListInvites request
	ListInvites(ctx context.Context, params *ListInvitesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InviteUserWithBody request with any body
	InviteUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InviteUser(ctx context.Context, body InviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInvite request
	DeleteInvite(ctx context.Context, inviteId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveInvite request
	RetrieveInvite(ctx context.Context, inviteId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjects request
	ListProjects(ctx context.Context, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProjectWithBody request with any body
	CreateProjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProject(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveProject request
	RetrieveProject(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModifyProjectWithBody request with any body
	ModifyProjectWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ModifyProject(ctx context.Context, projectId string, body ModifyProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjectApiKeys request
	ListProjectApiKeys(ctx context.Context, projectId string, params *ListProjectApiKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProjectApiKey request
	DeleteProjectApiKey(ctx context.Context, projectId string, keyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveProjectApiKey request
	RetrieveProjectApiKey(ctx context.Context, projectId string, keyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveProject request
	ArchiveProject(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjectRateLimits request
	ListProjectRateLimits(ctx context.Context, projectId string, params *ListProjectRateLimitsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProjectRateLimitsWithBody request with any body
	UpdateProjectRateLimitsWithBody(ctx context.Context, projectId string, rateLimitId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProjectRateLimits(ctx context.Context, projectId string, rateLimitId string, body UpdateProjectRateLimitsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjectServiceAccounts request
	ListProjectServiceAccounts(ctx context.Context, projectId string, params *ListProjectServiceAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProjectServiceAccountWithBody request with any body
	CreateProjectServiceAccountWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProjectServiceAccount(ctx context.Context, projectId string, body CreateProjectServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProjectServiceAccount request
	DeleteProjectServiceAccount(ctx context.Context, projectId string, serviceAccountId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveProjectServiceAccount request
	RetrieveProjectServiceAccount(ctx context.Context, projectId string, serviceAccountId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjectUsers request
	ListProjectUsers(ctx context.Context, projectId string, params *ListProjectUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProjectUserWithBody request with any body
	CreateProjectUserWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProjectUser(ctx context.Context, projectId string, body CreateProjectUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProjectUser request
	DeleteProjectUser(ctx context.Context, projectId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveProjectUser request
	RetrieveProjectUser(ctx context.Context, projectId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModifyProjectUserWithBody request with any body
	ModifyProjectUserWithBody(ctx context.Context, projectId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ModifyProjectUser(ctx context.Context, projectId string, userId string, body ModifyProjectUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsers request
	ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveUser request
	RetrieveUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModifyUserWithBody request with any body
	ModifyUserWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ModifyUser(ctx context.Context, userId string, body ModifyUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateThreadWithBody request with any body
	CreateThreadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateThread(ctx context.Context, body CreateThreadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateThreadAndRunWithBody request with any body
	CreateThreadAndRunWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateThreadAndRun(ctx context.Context, body CreateThreadAndRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteThread request
	DeleteThread(ctx context.Context, threadId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetThread request
	GetThread(ctx context.Context, threadId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModifyThreadWithBody request with any body
	ModifyThreadWithBody(ctx context.Context, threadId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ModifyThread(ctx context.Context, threadId string, body ModifyThreadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMessages request
	ListMessages(ctx context.Context, threadId string, params *ListMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateMessageWithBody request with any body
	CreateMessageWithBody(ctx context.Context, threadId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateMessage(ctx context.Context, threadId string, body CreateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMessage request
	DeleteMessage(ctx context.Context, threadId string, messageId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMessage request
	GetMessage(ctx context.Context, threadId string, messageId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModifyMessageWithBody request with any body
	ModifyMessageWithBody(ctx context.Context, threadId string, messageId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ModifyMessage(ctx context.Context, threadId string, messageId string, body ModifyMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRuns request
	ListRuns(ctx context.Context, threadId string, params *ListRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRunWithBody request with any body
	CreateRunWithBody(ctx context.Context, threadId string, params *CreateRunParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRun(ctx context.Context, threadId string, params *CreateRunParams, body CreateRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRun request
	GetRun(ctx context.Context, threadId string, runId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModifyRunWithBody request with any body
	ModifyRunWithBody(ctx context.Context, threadId string, runId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ModifyRun(ctx context.Context, threadId string, runId string, body ModifyRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelRun request
	CancelRun(ctx context.Context, threadId string, runId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRunSteps request
	ListRunSteps(ctx context.Context, threadId string, runId string, params *ListRunStepsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRunStep request
	GetRunStep(ctx context.Context, threadId string, runId string, stepId string, params *GetRunStepParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SubmitToolOuputsToRunWithBody request with any body
	SubmitToolOuputsToRunWithBody(ctx context.Context, threadId string, runId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SubmitToolOuputsToRun(ctx context.Context, threadId string, runId string, body SubmitToolOuputsToRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUploadWithBody request with any body
	CreateUploadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUpload(ctx context.Context, body CreateUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelUpload request
	CancelUpload(ctx context.Context, uploadId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CompleteUploadWithBody request with any body
	CompleteUploadWithBody(ctx context.Context, uploadId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CompleteUpload(ctx context.Context, uploadId string, body CompleteUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddUploadPartWithBody request with any body
	AddUploadPartWithBody(ctx context.Context, uploadId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVectorStores request
	ListVectorStores(ctx context.Context, params *ListVectorStoresParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVectorStoreWithBody request with any body
	CreateVectorStoreWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVectorStore(ctx context.Context, body CreateVectorStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVectorStore request
	DeleteVectorStore(ctx context.Context, vectorStoreId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVectorStore request
	GetVectorStore(ctx context.Context, vectorStoreId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModifyVectorStoreWithBody request with any body
	ModifyVectorStoreWithBody(ctx context.Context, vectorStoreId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ModifyVectorStore(ctx context.Context, vectorStoreId string, body ModifyVectorStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVectorStoreFileBatchWithBody request with any body
	CreateVectorStoreFileBatchWithBody(ctx context.Context, vectorStoreId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVectorStoreFileBatch(ctx context.Context, vectorStoreId string, body CreateVectorStoreFileBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVectorStoreFileBatch request
	GetVectorStoreFileBatch(ctx context.Context, vectorStoreId string, batchId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelVectorStoreFileBatch request
	CancelVectorStoreFileBatch(ctx context.Context, vectorStoreId string, batchId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFilesInVectorStoreBatch request
	ListFilesInVectorStoreBatch(ctx context.Context, vectorStoreId string, batchId string, params *ListFilesInVectorStoreBatchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVectorStoreFiles request
	ListVectorStoreFiles(ctx context.Context, vectorStoreId string, params *ListVectorStoreFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVectorStoreFileWithBody request with any body
	CreateVectorStoreFileWithBody(ctx context.Context, vectorStoreId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVectorStoreFile(ctx context.Context, vectorStoreId string, body CreateVectorStoreFileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVectorStoreFile request
	DeleteVectorStoreFile(ctx context.Context, vectorStoreId string, fileId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVectorStoreFile request
	GetVectorStoreFile(ctx context.Context, vectorStoreId string, fileId string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListAssistants(ctx context.Context, params *ListAssistantsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAssistantsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAssistantWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAssistantRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAssistant(ctx context.Context, body CreateAssistantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAssistantRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAssistant(ctx context.Context, assistantId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAssistantRequest(c.Server, assistantId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssistant(ctx context.Context, assistantId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssistantRequest(c.Server, assistantId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyAssistantWithBody(ctx context.Context, assistantId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyAssistantRequestWithBody(c.Server, assistantId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyAssistant(ctx context.Context, assistantId string, body ModifyAssistantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyAssistantRequest(c.Server, assistantId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpeechWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpeechRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpeech(ctx context.Context, body CreateSpeechJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpeechRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTranscriptionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTranscriptionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTranslationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTranslationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBatches(ctx context.Context, params *ListBatchesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBatchesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBatchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBatchRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBatch(ctx context.Context, body CreateBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBatchRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveBatch(ctx context.Context, batchId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveBatchRequest(c.Server, batchId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelBatch(ctx context.Context, batchId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelBatchRequest(c.Server, batchId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateChatCompletionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateChatCompletionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateChatCompletion(ctx context.Context, body CreateChatCompletionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateChatCompletionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCompletionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCompletionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCompletion(ctx context.Context, body CreateCompletionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCompletionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEmbeddingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEmbeddingRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEmbedding(ctx context.Context, body CreateEmbeddingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEmbeddingRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFiles(ctx context.Context, params *ListFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFilesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFileRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFile(ctx context.Context, fileId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFileRequest(c.Server, fileId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveFile(ctx context.Context, fileId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveFileRequest(c.Server, fileId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadFile(ctx context.Context, fileId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadFileRequest(c.Server, fileId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPaginatedFineTuningJobs(ctx context.Context, params *ListPaginatedFineTuningJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPaginatedFineTuningJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFineTuningJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFineTuningJobRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFineTuningJob(ctx context.Context, body CreateFineTuningJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFineTuningJobRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveFineTuningJob(ctx context.Context, fineTuningJobId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveFineTuningJobRequest(c.Server, fineTuningJobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelFineTuningJob(ctx context.Context, fineTuningJobId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelFineTuningJobRequest(c.Server, fineTuningJobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFineTuningJobCheckpoints(ctx context.Context, fineTuningJobId string, params *ListFineTuningJobCheckpointsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFineTuningJobCheckpointsRequest(c.Server, fineTuningJobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFineTuningEvents(ctx context.Context, fineTuningJobId string, params *ListFineTuningEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFineTuningEventsRequest(c.Server, fineTuningJobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateImageEditWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateImageEditRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateImageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateImageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateImage(ctx context.Context, body CreateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateImageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateImageVariationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateImageVariationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListModels(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListModelsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteModel(ctx context.Context, model string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteModelRequest(c.Server, model)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveModel(ctx context.Context, model string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveModelRequest(c.Server, model)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateModerationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateModerationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateModeration(ctx context.Context, body CreateModerationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateModerationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAuditLogs(ctx context.Context, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAuditLogsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListInvites(ctx context.Context, params *ListInvitesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListInvitesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteUser(ctx context.Context, body InviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInvite(ctx context.Context, inviteId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInviteRequest(c.Server, inviteId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveInvite(ctx context.Context, inviteId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveInviteRequest(c.Server, inviteId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjects(ctx context.Context, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProject(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveProject(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveProjectRequest(c.Server, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyProjectWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyProjectRequestWithBody(c.Server, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyProject(ctx context.Context, projectId string, body ModifyProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyProjectRequest(c.Server, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjectApiKeys(ctx context.Context, projectId string, params *ListProjectApiKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectApiKeysRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProjectApiKey(ctx context.Context, projectId string, keyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProjectApiKeyRequest(c.Server, projectId, keyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveProjectApiKey(ctx context.Context, projectId string, keyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveProjectApiKeyRequest(c.Server, projectId, keyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveProject(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveProjectRequest(c.Server, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjectRateLimits(ctx context.Context, projectId string, params *ListProjectRateLimitsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectRateLimitsRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectRateLimitsWithBody(ctx context.Context, projectId string, rateLimitId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectRateLimitsRequestWithBody(c.Server, projectId, rateLimitId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectRateLimits(ctx context.Context, projectId string, rateLimitId string, body UpdateProjectRateLimitsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectRateLimitsRequest(c.Server, projectId, rateLimitId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjectServiceAccounts(ctx context.Context, projectId string, params *ListProjectServiceAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectServiceAccountsRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectServiceAccountWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectServiceAccountRequestWithBody(c.Server, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectServiceAccount(ctx context.Context, projectId string, body CreateProjectServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectServiceAccountRequest(c.Server, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProjectServiceAccount(ctx context.Context, projectId string, serviceAccountId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProjectServiceAccountRequest(c.Server, projectId, serviceAccountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveProjectServiceAccount(ctx context.Context, projectId string, serviceAccountId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveProjectServiceAccountRequest(c.Server, projectId, serviceAccountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjectUsers(ctx context.Context, projectId string, params *ListProjectUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectUsersRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectUserWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectUserRequestWithBody(c.Server, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectUser(ctx context.Context, projectId string, body CreateProjectUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectUserRequest(c.Server, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProjectUser(ctx context.Context, projectId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProjectUserRequest(c.Server, projectId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveProjectUser(ctx context.Context, projectId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveProjectUserRequest(c.Server, projectId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyProjectUserWithBody(ctx context.Context, projectId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyProjectUserRequestWithBody(c.Server, projectId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyProjectUser(ctx context.Context, projectId string, userId string, body ModifyProjectUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyProjectUserRequest(c.Server, projectId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveUserRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyUserWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyUserRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyUser(ctx context.Context, userId string, body ModifyUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyUserRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateThreadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateThreadRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateThread(ctx context.Context, body CreateThreadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateThreadRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateThreadAndRunWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateThreadAndRunRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateThreadAndRun(ctx context.Context, body CreateThreadAndRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateThreadAndRunRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteThread(ctx context.Context, threadId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteThreadRequest(c.Server, threadId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetThread(ctx context.Context, threadId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetThreadRequest(c.Server, threadId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyThreadWithBody(ctx context.Context, threadId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyThreadRequestWithBody(c.Server, threadId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyThread(ctx context.Context, threadId string, body ModifyThreadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyThreadRequest(c.Server, threadId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMessages(ctx context.Context, threadId string, params *ListMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMessagesRequest(c.Server, threadId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMessageWithBody(ctx context.Context, threadId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMessageRequestWithBody(c.Server, threadId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMessage(ctx context.Context, threadId string, body CreateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMessageRequest(c.Server, threadId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMessage(ctx context.Context, threadId string, messageId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMessageRequest(c.Server, threadId, messageId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMessage(ctx context.Context, threadId string, messageId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMessageRequest(c.Server, threadId, messageId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyMessageWithBody(ctx context.Context, threadId string, messageId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyMessageRequestWithBody(c.Server, threadId, messageId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyMessage(ctx context.Context, threadId string, messageId string, body ModifyMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyMessageRequest(c.Server, threadId, messageId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRuns(ctx context.Context, threadId string, params *ListRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRunsRequest(c.Server, threadId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRunWithBody(ctx context.Context, threadId string, params *CreateRunParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRunRequestWithBody(c.Server, threadId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRun(ctx context.Context, threadId string, params *CreateRunParams, body CreateRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRunRequest(c.Server, threadId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRun(ctx context.Context, threadId string, runId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRunRequest(c.Server, threadId, runId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyRunWithBody(ctx context.Context, threadId string, runId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyRunRequestWithBody(c.Server, threadId, runId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyRun(ctx context.Context, threadId string, runId string, body ModifyRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyRunRequest(c.Server, threadId, runId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelRun(ctx context.Context, threadId string, runId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelRunRequest(c.Server, threadId, runId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRunSteps(ctx context.Context, threadId string, runId string, params *ListRunStepsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRunStepsRequest(c.Server, threadId, runId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRunStep(ctx context.Context, threadId string, runId string, stepId string, params *GetRunStepParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRunStepRequest(c.Server, threadId, runId, stepId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubmitToolOuputsToRunWithBody(ctx context.Context, threadId string, runId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubmitToolOuputsToRunRequestWithBody(c.Server, threadId, runId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubmitToolOuputsToRun(ctx context.Context, threadId string, runId string, body SubmitToolOuputsToRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubmitToolOuputsToRunRequest(c.Server, threadId, runId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUploadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUploadRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUpload(ctx context.Context, body CreateUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUploadRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelUpload(ctx context.Context, uploadId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelUploadRequest(c.Server, uploadId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompleteUploadWithBody(ctx context.Context, uploadId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompleteUploadRequestWithBody(c.Server, uploadId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompleteUpload(ctx context.Context, uploadId string, body CompleteUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompleteUploadRequest(c.Server, uploadId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUploadPartWithBody(ctx context.Context, uploadId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUploadPartRequestWithBody(c.Server, uploadId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVectorStores(ctx context.Context, params *ListVectorStoresParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVectorStoresRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVectorStoreWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVectorStoreRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVectorStore(ctx context.Context, body CreateVectorStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVectorStoreRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVectorStore(ctx context.Context, vectorStoreId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVectorStoreRequest(c.Server, vectorStoreId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVectorStore(ctx context.Context, vectorStoreId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVectorStoreRequest(c.Server, vectorStoreId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyVectorStoreWithBody(ctx context.Context, vectorStoreId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyVectorStoreRequestWithBody(c.Server, vectorStoreId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyVectorStore(ctx context.Context, vectorStoreId string, body ModifyVectorStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyVectorStoreRequest(c.Server, vectorStoreId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVectorStoreFileBatchWithBody(ctx context.Context, vectorStoreId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVectorStoreFileBatchRequestWithBody(c.Server, vectorStoreId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVectorStoreFileBatch(ctx context.Context, vectorStoreId string, body CreateVectorStoreFileBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVectorStoreFileBatchRequest(c.Server, vectorStoreId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVectorStoreFileBatch(ctx context.Context, vectorStoreId string, batchId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVectorStoreFileBatchRequest(c.Server, vectorStoreId, batchId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelVectorStoreFileBatch(ctx context.Context, vectorStoreId string, batchId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelVectorStoreFileBatchRequest(c.Server, vectorStoreId, batchId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFilesInVectorStoreBatch(ctx context.Context, vectorStoreId string, batchId string, params *ListFilesInVectorStoreBatchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFilesInVectorStoreBatchRequest(c.Server, vectorStoreId, batchId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVectorStoreFiles(ctx context.Context, vectorStoreId string, params *ListVectorStoreFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVectorStoreFilesRequest(c.Server, vectorStoreId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVectorStoreFileWithBody(ctx context.Context, vectorStoreId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVectorStoreFileRequestWithBody(c.Server, vectorStoreId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVectorStoreFile(ctx context.Context, vectorStoreId string, body CreateVectorStoreFileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVectorStoreFileRequest(c.Server, vectorStoreId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVectorStoreFile(ctx context.Context, vectorStoreId string, fileId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVectorStoreFileRequest(c.Server, vectorStoreId, fileId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVectorStoreFile(ctx context.Context, vectorStoreId string, fileId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVectorStoreFileRequest(c.Server, vectorStoreId, fileId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListAssistantsRequest generates requests for ListAssistants
func NewListAssistantsRequest(server string, params *ListAssistantsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assistants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAssistantRequest calls the generic CreateAssistant builder with application/json body
func NewCreateAssistantRequest(server string, body CreateAssistantJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAssistantRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAssistantRequestWithBody generates requests for CreateAssistant with any type of body
func NewCreateAssistantRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assistants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAssistantRequest generates requests for DeleteAssistant
func NewDeleteAssistantRequest(server string, assistantId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "assistant_id", runtime.ParamLocationPath, assistantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assistants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAssistantRequest generates requests for GetAssistant
func NewGetAssistantRequest(server string, assistantId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "assistant_id", runtime.ParamLocationPath, assistantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assistants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewModifyAssistantRequest calls the generic ModifyAssistant builder with application/json body
func NewModifyAssistantRequest(server string, assistantId string, body ModifyAssistantJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewModifyAssistantRequestWithBody(server, assistantId, "application/json", bodyReader)
}

// NewModifyAssistantRequestWithBody generates requests for ModifyAssistant with any type of body
func NewModifyAssistantRequestWithBody(server string, assistantId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "assistant_id", runtime.ParamLocationPath, assistantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assistants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateSpeechRequest calls the generic CreateSpeech builder with application/json body
func NewCreateSpeechRequest(server string, body CreateSpeechJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSpeechRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSpeechRequestWithBody generates requests for CreateSpeech with any type of body
func NewCreateSpeechRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/audio/speech")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateTranscriptionRequestWithBody generates requests for CreateTranscription with any type of body
func NewCreateTranscriptionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/audio/transcriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateTranslationRequestWithBody generates requests for CreateTranslation with any type of body
func NewCreateTranslationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/audio/translations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListBatchesRequest generates requests for ListBatches
func NewListBatchesRequest(server string, params *ListBatchesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batches")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBatchRequest calls the generic CreateBatch builder with application/json body
func NewCreateBatchRequest(server string, body CreateBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBatchRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateBatchRequestWithBody generates requests for CreateBatch with any type of body
func NewCreateBatchRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batches")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRetrieveBatchRequest generates requests for RetrieveBatch
func NewRetrieveBatchRequest(server string, batchId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "batch_id", runtime.ParamLocationPath, batchId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batches/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelBatchRequest generates requests for CancelBatch
func NewCancelBatchRequest(server string, batchId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "batch_id", runtime.ParamLocationPath, batchId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batches/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateChatCompletionRequest calls the generic CreateChatCompletion builder with application/json body
func NewCreateChatCompletionRequest(server string, body CreateChatCompletionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateChatCompletionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateChatCompletionRequestWithBody generates requests for CreateChatCompletion with any type of body
func NewCreateChatCompletionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chat/completions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateCompletionRequest calls the generic CreateCompletion builder with application/json body
func NewCreateCompletionRequest(server string, body CreateCompletionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCompletionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateCompletionRequestWithBody generates requests for CreateCompletion with any type of body
func NewCreateCompletionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/completions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateEmbeddingRequest calls the generic CreateEmbedding builder with application/json body
func NewCreateEmbeddingRequest(server string, body CreateEmbeddingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEmbeddingRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateEmbeddingRequestWithBody generates requests for CreateEmbedding with any type of body
func NewCreateEmbeddingRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/embeddings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListFilesRequest generates requests for ListFiles
func NewListFilesRequest(server string, params *ListFilesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Purpose != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "purpose", runtime.ParamLocationQuery, *params.Purpose); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFileRequestWithBody generates requests for CreateFile with any type of body
func NewCreateFileRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFileRequest generates requests for DeleteFile
func NewDeleteFileRequest(server string, fileId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "file_id", runtime.ParamLocationPath, fileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrieveFileRequest generates requests for RetrieveFile
func NewRetrieveFileRequest(server string, fileId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "file_id", runtime.ParamLocationPath, fileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadFileRequest generates requests for DownloadFile
func NewDownloadFileRequest(server string, fileId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "file_id", runtime.ParamLocationPath, fileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files/%s/content", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPaginatedFineTuningJobsRequest generates requests for ListPaginatedFineTuningJobs
func NewListPaginatedFineTuningJobsRequest(server string, params *ListPaginatedFineTuningJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fine_tuning/jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFineTuningJobRequest calls the generic CreateFineTuningJob builder with application/json body
func NewCreateFineTuningJobRequest(server string, body CreateFineTuningJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFineTuningJobRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateFineTuningJobRequestWithBody generates requests for CreateFineTuningJob with any type of body
func NewCreateFineTuningJobRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fine_tuning/jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRetrieveFineTuningJobRequest generates requests for RetrieveFineTuningJob
func NewRetrieveFineTuningJobRequest(server string, fineTuningJobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "fine_tuning_job_id", runtime.ParamLocationPath, fineTuningJobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fine_tuning/jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelFineTuningJobRequest generates requests for CancelFineTuningJob
func NewCancelFineTuningJobRequest(server string, fineTuningJobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "fine_tuning_job_id", runtime.ParamLocationPath, fineTuningJobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fine_tuning/jobs/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListFineTuningJobCheckpointsRequest generates requests for ListFineTuningJobCheckpoints
func NewListFineTuningJobCheckpointsRequest(server string, fineTuningJobId string, params *ListFineTuningJobCheckpointsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "fine_tuning_job_id", runtime.ParamLocationPath, fineTuningJobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fine_tuning/jobs/%s/checkpoints", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListFineTuningEventsRequest generates requests for ListFineTuningEvents
func NewListFineTuningEventsRequest(server string, fineTuningJobId string, params *ListFineTuningEventsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "fine_tuning_job_id", runtime.ParamLocationPath, fineTuningJobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fine_tuning/jobs/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateImageEditRequestWithBody generates requests for CreateImageEdit with any type of body
func NewCreateImageEditRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/images/edits")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateImageRequest calls the generic CreateImage builder with application/json body
func NewCreateImageRequest(server string, body CreateImageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateImageRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateImageRequestWithBody generates requests for CreateImage with any type of body
func NewCreateImageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/images/generations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateImageVariationRequestWithBody generates requests for CreateImageVariation with any type of body
func NewCreateImageVariationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/images/variations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListModelsRequest generates requests for ListModels
func NewListModelsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteModelRequest generates requests for DeleteModel
func NewDeleteModelRequest(server string, model string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "model", runtime.ParamLocationPath, model)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrieveModelRequest generates requests for RetrieveModel
func NewRetrieveModelRequest(server string, model string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "model", runtime.ParamLocationPath, model)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateModerationRequest calls the generic CreateModeration builder with application/json body
func NewCreateModerationRequest(server string, body CreateModerationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateModerationRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateModerationRequestWithBody generates requests for CreateModeration with any type of body
func NewCreateModerationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAuditLogsRequest generates requests for ListAuditLogs
func NewListAuditLogsRequest(server string, params *ListAuditLogsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organization/audit_logs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.EffectiveAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective_at", runtime.ParamLocationQuery, *params.EffectiveAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "project_ids[]", runtime.ParamLocationQuery, *params.ProjectIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_types[]", runtime.ParamLocationQuery, *params.EventTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ActorIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "actor_ids[]", runtime.ParamLocationQuery, *params.ActorIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ActorEmails != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "actor_emails[]", runtime.ParamLocationQuery, *params.ActorEmails); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResourceIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resource_ids[]", runtime.ParamLocationQuery, *params.ResourceIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListInvitesRequest generates requests for ListInvites
func NewListInvitesRequest(server string, params *ListInvitesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organization/invites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInviteUserRequest calls the generic InviteUser builder with application/json body
func NewInviteUserRequest(server string, body InviteUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInviteUserRequestWithBody(server, "application/json", bodyReader)
}

// NewInviteUserRequestWithBody generates requests for InviteUser with any type of body
func NewInviteUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organization/invites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteInviteRequest generates requests for DeleteInvite
func NewDeleteInviteRequest(server string, inviteId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "invite_id", runtime.ParamLocationPath, inviteId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organization/invites/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrieveInviteRequest generates requests for RetrieveInvite
func NewRetrieveInviteRequest(server string, inviteId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "invite_id", runtime.ParamLocationPath, inviteId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organization/invites/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListProjectsRequest generates requests for ListProjects
func NewListProjectsRequest(server string, params *ListProjectsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organization/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeArchived != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_archived", runtime.ParamLocationQuery, *params.IncludeArchived); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProjectRequest calls the generic CreateProject builder with application/json body
func NewCreateProjectRequest(server string, body CreateProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProjectRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateProjectRequestWithBody generates requests for CreateProject with any type of body
func NewCreateProjectRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organization/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRetrieveProjectRequest generates requests for RetrieveProject
func NewRetrieveProjectRequest(server string, projectId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organization/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewModifyProjectRequest calls the generic ModifyProject builder with application/json body
func NewModifyProjectRequest(server string, projectId string, body ModifyProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewModifyProjectRequestWithBody(server, projectId, "application/json", bodyReader)
}

// NewModifyProjectRequestWithBody generates requests for ModifyProject with any type of body
func NewModifyProjectRequestWithBody(server string, projectId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organization/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListProjectApiKeysRequest generates requests for ListProjectApiKeys
func NewListProjectApiKeysRequest(server string, projectId string, params *ListProjectApiKeysParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organization/projects/%s/api_keys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteProjectApiKeyRequest generates requests for DeleteProjectApiKey
func NewDeleteProjectApiKeyRequest(server string, projectId string, keyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "key_id", runtime.ParamLocationPath, keyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organization/projects/%s/api_keys/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrieveProjectApiKeyRequest generates requests for RetrieveProjectApiKey
func NewRetrieveProjectApiKeyRequest(server string, projectId string, keyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "key_id", runtime.ParamLocationPath, keyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organization/projects/%s/api_keys/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewArchiveProjectRequest generates requests for ArchiveProject
func NewArchiveProjectRequest(server string, projectId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organization/projects/%s/archive", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListProjectRateLimitsRequest generates requests for ListProjectRateLimits
func NewListProjectRateLimitsRequest(server string, projectId string, params *ListProjectRateLimitsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organization/projects/%s/rate_limits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProjectRateLimitsRequest calls the generic UpdateProjectRateLimits builder with application/json body
func NewUpdateProjectRateLimitsRequest(server string, projectId string, rateLimitId string, body UpdateProjectRateLimitsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProjectRateLimitsRequestWithBody(server, projectId, rateLimitId, "application/json", bodyReader)
}

// NewUpdateProjectRateLimitsRequestWithBody generates requests for UpdateProjectRateLimits with any type of body
func NewUpdateProjectRateLimitsRequestWithBody(server string, projectId string, rateLimitId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "rate_limit_id", runtime.ParamLocationPath, rateLimitId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organization/projects/%s/rate_limits/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListProjectServiceAccountsRequest generates requests for ListProjectServiceAccounts
func NewListProjectServiceAccountsRequest(server string, projectId string, params *ListProjectServiceAccountsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organization/projects/%s/service_accounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProjectServiceAccountRequest calls the generic CreateProjectServiceAccount builder with application/json body
func NewCreateProjectServiceAccountRequest(server string, projectId string, body CreateProjectServiceAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProjectServiceAccountRequestWithBody(server, projectId, "application/json", bodyReader)
}

// NewCreateProjectServiceAccountRequestWithBody generates requests for CreateProjectServiceAccount with any type of body
func NewCreateProjectServiceAccountRequestWithBody(server string, projectId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organization/projects/%s/service_accounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProjectServiceAccountRequest generates requests for DeleteProjectServiceAccount
func NewDeleteProjectServiceAccountRequest(server string, projectId string, serviceAccountId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "service_account_id", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organization/projects/%s/service_accounts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrieveProjectServiceAccountRequest generates requests for RetrieveProjectServiceAccount
func NewRetrieveProjectServiceAccountRequest(server string, projectId string, serviceAccountId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "service_account_id", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organization/projects/%s/service_accounts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListProjectUsersRequest generates requests for ListProjectUsers
func NewListProjectUsersRequest(server string, projectId string, params *ListProjectUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organization/projects/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProjectUserRequest calls the generic CreateProjectUser builder with application/json body
func NewCreateProjectUserRequest(server string, projectId string, body CreateProjectUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProjectUserRequestWithBody(server, projectId, "application/json", bodyReader)
}

// NewCreateProjectUserRequestWithBody generates requests for CreateProjectUser with any type of body
func NewCreateProjectUserRequestWithBody(server string, projectId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organization/projects/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProjectUserRequest generates requests for DeleteProjectUser
func NewDeleteProjectUserRequest(server string, projectId string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organization/projects/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrieveProjectUserRequest generates requests for RetrieveProjectUser
func NewRetrieveProjectUserRequest(server string, projectId string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organization/projects/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewModifyProjectUserRequest calls the generic ModifyProjectUser builder with application/json body
func NewModifyProjectUserRequest(server string, projectId string, userId string, body ModifyProjectUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewModifyProjectUserRequestWithBody(server, projectId, userId, "application/json", bodyReader)
}

// NewModifyProjectUserRequestWithBody generates requests for ModifyProjectUser with any type of body
func NewModifyProjectUserRequestWithBody(server string, projectId string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organization/projects/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListUsersRequest generates requests for ListUsers
func NewListUsersRequest(server string, params *ListUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organization/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organization/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrieveUserRequest generates requests for RetrieveUser
func NewRetrieveUserRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organization/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewModifyUserRequest calls the generic ModifyUser builder with application/json body
func NewModifyUserRequest(server string, userId string, body ModifyUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewModifyUserRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewModifyUserRequestWithBody generates requests for ModifyUser with any type of body
func NewModifyUserRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organization/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateThreadRequest calls the generic CreateThread builder with application/json body
func NewCreateThreadRequest(server string, body CreateThreadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateThreadRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateThreadRequestWithBody generates requests for CreateThread with any type of body
func NewCreateThreadRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/threads")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateThreadAndRunRequest calls the generic CreateThreadAndRun builder with application/json body
func NewCreateThreadAndRunRequest(server string, body CreateThreadAndRunJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateThreadAndRunRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateThreadAndRunRequestWithBody generates requests for CreateThreadAndRun with any type of body
func NewCreateThreadAndRunRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/threads/runs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteThreadRequest generates requests for DeleteThread
func NewDeleteThreadRequest(server string, threadId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thread_id", runtime.ParamLocationPath, threadId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/threads/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetThreadRequest generates requests for GetThread
func NewGetThreadRequest(server string, threadId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thread_id", runtime.ParamLocationPath, threadId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/threads/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewModifyThreadRequest calls the generic ModifyThread builder with application/json body
func NewModifyThreadRequest(server string, threadId string, body ModifyThreadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewModifyThreadRequestWithBody(server, threadId, "application/json", bodyReader)
}

// NewModifyThreadRequestWithBody generates requests for ModifyThread with any type of body
func NewModifyThreadRequestWithBody(server string, threadId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thread_id", runtime.ParamLocationPath, threadId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/threads/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListMessagesRequest generates requests for ListMessages
func NewListMessagesRequest(server string, threadId string, params *ListMessagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thread_id", runtime.ParamLocationPath, threadId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/threads/%s/messages", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RunId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "run_id", runtime.ParamLocationQuery, *params.RunId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateMessageRequest calls the generic CreateMessage builder with application/json body
func NewCreateMessageRequest(server string, threadId string, body CreateMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateMessageRequestWithBody(server, threadId, "application/json", bodyReader)
}

// NewCreateMessageRequestWithBody generates requests for CreateMessage with any type of body
func NewCreateMessageRequestWithBody(server string, threadId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thread_id", runtime.ParamLocationPath, threadId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/threads/%s/messages", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMessageRequest generates requests for DeleteMessage
func NewDeleteMessageRequest(server string, threadId string, messageId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thread_id", runtime.ParamLocationPath, threadId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "message_id", runtime.ParamLocationPath, messageId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/threads/%s/messages/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMessageRequest generates requests for GetMessage
func NewGetMessageRequest(server string, threadId string, messageId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thread_id", runtime.ParamLocationPath, threadId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "message_id", runtime.ParamLocationPath, messageId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/threads/%s/messages/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewModifyMessageRequest calls the generic ModifyMessage builder with application/json body
func NewModifyMessageRequest(server string, threadId string, messageId string, body ModifyMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewModifyMessageRequestWithBody(server, threadId, messageId, "application/json", bodyReader)
}

// NewModifyMessageRequestWithBody generates requests for ModifyMessage with any type of body
func NewModifyMessageRequestWithBody(server string, threadId string, messageId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thread_id", runtime.ParamLocationPath, threadId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "message_id", runtime.ParamLocationPath, messageId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/threads/%s/messages/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListRunsRequest generates requests for ListRuns
func NewListRunsRequest(server string, threadId string, params *ListRunsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thread_id", runtime.ParamLocationPath, threadId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/threads/%s/runs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRunRequest calls the generic CreateRun builder with application/json body
func NewCreateRunRequest(server string, threadId string, params *CreateRunParams, body CreateRunJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRunRequestWithBody(server, threadId, params, "application/json", bodyReader)
}

// NewCreateRunRequestWithBody generates requests for CreateRun with any type of body
func NewCreateRunRequestWithBody(server string, threadId string, params *CreateRunParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thread_id", runtime.ParamLocationPath, threadId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/threads/%s/runs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include[]", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRunRequest generates requests for GetRun
func NewGetRunRequest(server string, threadId string, runId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thread_id", runtime.ParamLocationPath, threadId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/threads/%s/runs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewModifyRunRequest calls the generic ModifyRun builder with application/json body
func NewModifyRunRequest(server string, threadId string, runId string, body ModifyRunJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewModifyRunRequestWithBody(server, threadId, runId, "application/json", bodyReader)
}

// NewModifyRunRequestWithBody generates requests for ModifyRun with any type of body
func NewModifyRunRequestWithBody(server string, threadId string, runId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thread_id", runtime.ParamLocationPath, threadId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/threads/%s/runs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCancelRunRequest generates requests for CancelRun
func NewCancelRunRequest(server string, threadId string, runId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thread_id", runtime.ParamLocationPath, threadId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/threads/%s/runs/%s/cancel", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRunStepsRequest generates requests for ListRunSteps
func NewListRunStepsRequest(server string, threadId string, runId string, params *ListRunStepsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thread_id", runtime.ParamLocationPath, threadId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/threads/%s/runs/%s/steps", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include[]", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRunStepRequest generates requests for GetRunStep
func NewGetRunStepRequest(server string, threadId string, runId string, stepId string, params *GetRunStepParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thread_id", runtime.ParamLocationPath, threadId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "step_id", runtime.ParamLocationPath, stepId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/threads/%s/runs/%s/steps/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include[]", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSubmitToolOuputsToRunRequest calls the generic SubmitToolOuputsToRun builder with application/json body
func NewSubmitToolOuputsToRunRequest(server string, threadId string, runId string, body SubmitToolOuputsToRunJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSubmitToolOuputsToRunRequestWithBody(server, threadId, runId, "application/json", bodyReader)
}

// NewSubmitToolOuputsToRunRequestWithBody generates requests for SubmitToolOuputsToRun with any type of body
func NewSubmitToolOuputsToRunRequestWithBody(server string, threadId string, runId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thread_id", runtime.ParamLocationPath, threadId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/threads/%s/runs/%s/submit_tool_outputs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateUploadRequest calls the generic CreateUpload builder with application/json body
func NewCreateUploadRequest(server string, body CreateUploadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUploadRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateUploadRequestWithBody generates requests for CreateUpload with any type of body
func NewCreateUploadRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/uploads")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCancelUploadRequest generates requests for CancelUpload
func NewCancelUploadRequest(server string, uploadId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "upload_id", runtime.ParamLocationPath, uploadId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/uploads/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCompleteUploadRequest calls the generic CompleteUpload builder with application/json body
func NewCompleteUploadRequest(server string, uploadId string, body CompleteUploadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCompleteUploadRequestWithBody(server, uploadId, "application/json", bodyReader)
}

// NewCompleteUploadRequestWithBody generates requests for CompleteUpload with any type of body
func NewCompleteUploadRequestWithBody(server string, uploadId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "upload_id", runtime.ParamLocationPath, uploadId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/uploads/%s/complete", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddUploadPartRequestWithBody generates requests for AddUploadPart with any type of body
func NewAddUploadPartRequestWithBody(server string, uploadId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "upload_id", runtime.ParamLocationPath, uploadId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/uploads/%s/parts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListVectorStoresRequest generates requests for ListVectorStores
func NewListVectorStoresRequest(server string, params *ListVectorStoresParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vector_stores")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVectorStoreRequest calls the generic CreateVectorStore builder with application/json body
func NewCreateVectorStoreRequest(server string, body CreateVectorStoreJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVectorStoreRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateVectorStoreRequestWithBody generates requests for CreateVectorStore with any type of body
func NewCreateVectorStoreRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vector_stores")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVectorStoreRequest generates requests for DeleteVectorStore
func NewDeleteVectorStoreRequest(server string, vectorStoreId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vector_store_id", runtime.ParamLocationPath, vectorStoreId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vector_stores/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVectorStoreRequest generates requests for GetVectorStore
func NewGetVectorStoreRequest(server string, vectorStoreId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vector_store_id", runtime.ParamLocationPath, vectorStoreId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vector_stores/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewModifyVectorStoreRequest calls the generic ModifyVectorStore builder with application/json body
func NewModifyVectorStoreRequest(server string, vectorStoreId string, body ModifyVectorStoreJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewModifyVectorStoreRequestWithBody(server, vectorStoreId, "application/json", bodyReader)
}

// NewModifyVectorStoreRequestWithBody generates requests for ModifyVectorStore with any type of body
func NewModifyVectorStoreRequestWithBody(server string, vectorStoreId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vector_store_id", runtime.ParamLocationPath, vectorStoreId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vector_stores/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateVectorStoreFileBatchRequest calls the generic CreateVectorStoreFileBatch builder with application/json body
func NewCreateVectorStoreFileBatchRequest(server string, vectorStoreId string, body CreateVectorStoreFileBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVectorStoreFileBatchRequestWithBody(server, vectorStoreId, "application/json", bodyReader)
}

// NewCreateVectorStoreFileBatchRequestWithBody generates requests for CreateVectorStoreFileBatch with any type of body
func NewCreateVectorStoreFileBatchRequestWithBody(server string, vectorStoreId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vector_store_id", runtime.ParamLocationPath, vectorStoreId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vector_stores/%s/file_batches", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVectorStoreFileBatchRequest generates requests for GetVectorStoreFileBatch
func NewGetVectorStoreFileBatchRequest(server string, vectorStoreId string, batchId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vector_store_id", runtime.ParamLocationPath, vectorStoreId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batch_id", runtime.ParamLocationPath, batchId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vector_stores/%s/file_batches/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCancelVectorStoreFileBatchRequest generates requests for CancelVectorStoreFileBatch
func NewCancelVectorStoreFileBatchRequest(server string, vectorStoreId string, batchId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vector_store_id", runtime.ParamLocationPath, vectorStoreId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batch_id", runtime.ParamLocationPath, batchId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vector_stores/%s/file_batches/%s/cancel", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListFilesInVectorStoreBatchRequest generates requests for ListFilesInVectorStoreBatch
func NewListFilesInVectorStoreBatchRequest(server string, vectorStoreId string, batchId string, params *ListFilesInVectorStoreBatchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vector_store_id", runtime.ParamLocationPath, vectorStoreId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "batch_id", runtime.ParamLocationPath, batchId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vector_stores/%s/file_batches/%s/files", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListVectorStoreFilesRequest generates requests for ListVectorStoreFiles
func NewListVectorStoreFilesRequest(server string, vectorStoreId string, params *ListVectorStoreFilesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vector_store_id", runtime.ParamLocationPath, vectorStoreId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vector_stores/%s/files", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVectorStoreFileRequest calls the generic CreateVectorStoreFile builder with application/json body
func NewCreateVectorStoreFileRequest(server string, vectorStoreId string, body CreateVectorStoreFileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVectorStoreFileRequestWithBody(server, vectorStoreId, "application/json", bodyReader)
}

// NewCreateVectorStoreFileRequestWithBody generates requests for CreateVectorStoreFile with any type of body
func NewCreateVectorStoreFileRequestWithBody(server string, vectorStoreId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vector_store_id", runtime.ParamLocationPath, vectorStoreId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vector_stores/%s/files", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVectorStoreFileRequest generates requests for DeleteVectorStoreFile
func NewDeleteVectorStoreFileRequest(server string, vectorStoreId string, fileId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vector_store_id", runtime.ParamLocationPath, vectorStoreId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "file_id", runtime.ParamLocationPath, fileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vector_stores/%s/files/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVectorStoreFileRequest generates requests for GetVectorStoreFile
func NewGetVectorStoreFileRequest(server string, vectorStoreId string, fileId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vector_store_id", runtime.ParamLocationPath, vectorStoreId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "file_id", runtime.ParamLocationPath, fileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vector_stores/%s/files/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListAssistantsWithResponse request
	ListAssistantsWithResponse(ctx context.Context, params *ListAssistantsParams, reqEditors ...RequestEditorFn) (*ListAssistantsResp, error)

	// CreateAssistantWithBodyWithResponse request with any body
	CreateAssistantWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAssistantResp, error)

	CreateAssistantWithResponse(ctx context.Context, body CreateAssistantJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAssistantResp, error)

	// DeleteAssistantWithResponse request
	DeleteAssistantWithResponse(ctx context.Context, assistantId string, reqEditors ...RequestEditorFn) (*DeleteAssistantResp, error)

	// GetAssistantWithResponse request
	GetAssistantWithResponse(ctx context.Context, assistantId string, reqEditors ...RequestEditorFn) (*GetAssistantResp, error)

	// ModifyAssistantWithBodyWithResponse request with any body
	ModifyAssistantWithBodyWithResponse(ctx context.Context, assistantId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyAssistantResp, error)

	ModifyAssistantWithResponse(ctx context.Context, assistantId string, body ModifyAssistantJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyAssistantResp, error)

	// CreateSpeechWithBodyWithResponse request with any body
	CreateSpeechWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpeechResp, error)

	CreateSpeechWithResponse(ctx context.Context, body CreateSpeechJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpeechResp, error)

	// CreateTranscriptionWithBodyWithResponse request with any body
	CreateTranscriptionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTranscriptionResp, error)

	// CreateTranslationWithBodyWithResponse request with any body
	CreateTranslationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTranslationResp, error)

	// ListBatchesWithResponse request
	ListBatchesWithResponse(ctx context.Context, params *ListBatchesParams, reqEditors ...RequestEditorFn) (*ListBatchesResp, error)

	// CreateBatchWithBodyWithResponse request with any body
	CreateBatchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBatchResp, error)

	CreateBatchWithResponse(ctx context.Context, body CreateBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBatchResp, error)

	// RetrieveBatchWithResponse request
	RetrieveBatchWithResponse(ctx context.Context, batchId string, reqEditors ...RequestEditorFn) (*RetrieveBatchResp, error)

	// CancelBatchWithResponse request
	CancelBatchWithResponse(ctx context.Context, batchId string, reqEditors ...RequestEditorFn) (*CancelBatchResp, error)

	// CreateChatCompletionWithBodyWithResponse request with any body
	CreateChatCompletionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateChatCompletionResp, error)

	CreateChatCompletionWithResponse(ctx context.Context, body CreateChatCompletionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateChatCompletionResp, error)

	// CreateCompletionWithBodyWithResponse request with any body
	CreateCompletionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCompletionResp, error)

	CreateCompletionWithResponse(ctx context.Context, body CreateCompletionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCompletionResp, error)

	// CreateEmbeddingWithBodyWithResponse request with any body
	CreateEmbeddingWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEmbeddingResp, error)

	CreateEmbeddingWithResponse(ctx context.Context, body CreateEmbeddingJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEmbeddingResp, error)

	// ListFilesWithResponse request
	ListFilesWithResponse(ctx context.Context, params *ListFilesParams, reqEditors ...RequestEditorFn) (*ListFilesResp, error)

	// CreateFileWithBodyWithResponse request with any body
	CreateFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFileResp, error)

	// DeleteFileWithResponse request
	DeleteFileWithResponse(ctx context.Context, fileId string, reqEditors ...RequestEditorFn) (*DeleteFileResp, error)

	// RetrieveFileWithResponse request
	RetrieveFileWithResponse(ctx context.Context, fileId string, reqEditors ...RequestEditorFn) (*RetrieveFileResp, error)

	// DownloadFileWithResponse request
	DownloadFileWithResponse(ctx context.Context, fileId string, reqEditors ...RequestEditorFn) (*DownloadFileResp, error)

	// ListPaginatedFineTuningJobsWithResponse request
	ListPaginatedFineTuningJobsWithResponse(ctx context.Context, params *ListPaginatedFineTuningJobsParams, reqEditors ...RequestEditorFn) (*ListPaginatedFineTuningJobsResp, error)

	// CreateFineTuningJobWithBodyWithResponse request with any body
	CreateFineTuningJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFineTuningJobResp, error)

	CreateFineTuningJobWithResponse(ctx context.Context, body CreateFineTuningJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFineTuningJobResp, error)

	// RetrieveFineTuningJobWithResponse request
	RetrieveFineTuningJobWithResponse(ctx context.Context, fineTuningJobId string, reqEditors ...RequestEditorFn) (*RetrieveFineTuningJobResp, error)

	// CancelFineTuningJobWithResponse request
	CancelFineTuningJobWithResponse(ctx context.Context, fineTuningJobId string, reqEditors ...RequestEditorFn) (*CancelFineTuningJobResp, error)

	// ListFineTuningJobCheckpointsWithResponse request
	ListFineTuningJobCheckpointsWithResponse(ctx context.Context, fineTuningJobId string, params *ListFineTuningJobCheckpointsParams, reqEditors ...RequestEditorFn) (*ListFineTuningJobCheckpointsResp, error)

	// ListFineTuningEventsWithResponse request
	ListFineTuningEventsWithResponse(ctx context.Context, fineTuningJobId string, params *ListFineTuningEventsParams, reqEditors ...RequestEditorFn) (*ListFineTuningEventsResp, error)

	// CreateImageEditWithBodyWithResponse request with any body
	CreateImageEditWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateImageEditResp, error)

	// CreateImageWithBodyWithResponse request with any body
	CreateImageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateImageResp, error)

	CreateImageWithResponse(ctx context.Context, body CreateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateImageResp, error)

	// CreateImageVariationWithBodyWithResponse request with any body
	CreateImageVariationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateImageVariationResp, error)

	// ListModelsWithResponse request
	ListModelsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListModelsResp, error)

	// DeleteModelWithResponse request
	DeleteModelWithResponse(ctx context.Context, model string, reqEditors ...RequestEditorFn) (*DeleteModelResp, error)

	// RetrieveModelWithResponse request
	RetrieveModelWithResponse(ctx context.Context, model string, reqEditors ...RequestEditorFn) (*RetrieveModelResp, error)

	// CreateModerationWithBodyWithResponse request with any body
	CreateModerationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateModerationResp, error)

	CreateModerationWithResponse(ctx context.Context, body CreateModerationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateModerationResp, error)

	// ListAuditLogsWithResponse request
	ListAuditLogsWithResponse(ctx context.Context, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*ListAuditLogsResp, error)

	// ListInvitesWithResponse request
	ListInvitesWithResponse(ctx context.Context, params *ListInvitesParams, reqEditors ...RequestEditorFn) (*ListInvitesResp, error)

	// InviteUserWithBodyWithResponse request with any body
	InviteUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteUserResp, error)

	InviteUserWithResponse(ctx context.Context, body InviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteUserResp, error)

	// DeleteInviteWithResponse request
	DeleteInviteWithResponse(ctx context.Context, inviteId string, reqEditors ...RequestEditorFn) (*DeleteInviteResp, error)

	// RetrieveInviteWithResponse request
	RetrieveInviteWithResponse(ctx context.Context, inviteId string, reqEditors ...RequestEditorFn) (*RetrieveInviteResp, error)

	// ListProjectsWithResponse request
	ListProjectsWithResponse(ctx context.Context, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*ListProjectsResp, error)

	// CreateProjectWithBodyWithResponse request with any body
	CreateProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectResp, error)

	CreateProjectWithResponse(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectResp, error)

	// RetrieveProjectWithResponse request
	RetrieveProjectWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*RetrieveProjectResp, error)

	// ModifyProjectWithBodyWithResponse request with any body
	ModifyProjectWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyProjectResp, error)

	ModifyProjectWithResponse(ctx context.Context, projectId string, body ModifyProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyProjectResp, error)

	// ListProjectApiKeysWithResponse request
	ListProjectApiKeysWithResponse(ctx context.Context, projectId string, params *ListProjectApiKeysParams, reqEditors ...RequestEditorFn) (*ListProjectApiKeysResp, error)

	// DeleteProjectApiKeyWithResponse request
	DeleteProjectApiKeyWithResponse(ctx context.Context, projectId string, keyId string, reqEditors ...RequestEditorFn) (*DeleteProjectApiKeyResp, error)

	// RetrieveProjectApiKeyWithResponse request
	RetrieveProjectApiKeyWithResponse(ctx context.Context, projectId string, keyId string, reqEditors ...RequestEditorFn) (*RetrieveProjectApiKeyResp, error)

	// ArchiveProjectWithResponse request
	ArchiveProjectWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*ArchiveProjectResp, error)

	// ListProjectRateLimitsWithResponse request
	ListProjectRateLimitsWithResponse(ctx context.Context, projectId string, params *ListProjectRateLimitsParams, reqEditors ...RequestEditorFn) (*ListProjectRateLimitsResp, error)

	// UpdateProjectRateLimitsWithBodyWithResponse request with any body
	UpdateProjectRateLimitsWithBodyWithResponse(ctx context.Context, projectId string, rateLimitId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectRateLimitsResp, error)

	UpdateProjectRateLimitsWithResponse(ctx context.Context, projectId string, rateLimitId string, body UpdateProjectRateLimitsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectRateLimitsResp, error)

	// ListProjectServiceAccountsWithResponse request
	ListProjectServiceAccountsWithResponse(ctx context.Context, projectId string, params *ListProjectServiceAccountsParams, reqEditors ...RequestEditorFn) (*ListProjectServiceAccountsResp, error)

	// CreateProjectServiceAccountWithBodyWithResponse request with any body
	CreateProjectServiceAccountWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectServiceAccountResp, error)

	CreateProjectServiceAccountWithResponse(ctx context.Context, projectId string, body CreateProjectServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectServiceAccountResp, error)

	// DeleteProjectServiceAccountWithResponse request
	DeleteProjectServiceAccountWithResponse(ctx context.Context, projectId string, serviceAccountId string, reqEditors ...RequestEditorFn) (*DeleteProjectServiceAccountResp, error)

	// RetrieveProjectServiceAccountWithResponse request
	RetrieveProjectServiceAccountWithResponse(ctx context.Context, projectId string, serviceAccountId string, reqEditors ...RequestEditorFn) (*RetrieveProjectServiceAccountResp, error)

	// ListProjectUsersWithResponse request
	ListProjectUsersWithResponse(ctx context.Context, projectId string, params *ListProjectUsersParams, reqEditors ...RequestEditorFn) (*ListProjectUsersResp, error)

	// CreateProjectUserWithBodyWithResponse request with any body
	CreateProjectUserWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectUserResp, error)

	CreateProjectUserWithResponse(ctx context.Context, projectId string, body CreateProjectUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectUserResp, error)

	// DeleteProjectUserWithResponse request
	DeleteProjectUserWithResponse(ctx context.Context, projectId string, userId string, reqEditors ...RequestEditorFn) (*DeleteProjectUserResp, error)

	// RetrieveProjectUserWithResponse request
	RetrieveProjectUserWithResponse(ctx context.Context, projectId string, userId string, reqEditors ...RequestEditorFn) (*RetrieveProjectUserResp, error)

	// ModifyProjectUserWithBodyWithResponse request with any body
	ModifyProjectUserWithBodyWithResponse(ctx context.Context, projectId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyProjectUserResp, error)

	ModifyProjectUserWithResponse(ctx context.Context, projectId string, userId string, body ModifyProjectUserJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyProjectUserResp, error)

	// ListUsersWithResponse request
	ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResp, error)

	// DeleteUserWithResponse request
	DeleteUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*DeleteUserResp, error)

	// RetrieveUserWithResponse request
	RetrieveUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*RetrieveUserResp, error)

	// ModifyUserWithBodyWithResponse request with any body
	ModifyUserWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyUserResp, error)

	ModifyUserWithResponse(ctx context.Context, userId string, body ModifyUserJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyUserResp, error)

	// CreateThreadWithBodyWithResponse request with any body
	CreateThreadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateThreadResp, error)

	CreateThreadWithResponse(ctx context.Context, body CreateThreadJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateThreadResp, error)

	// CreateThreadAndRunWithBodyWithResponse request with any body
	CreateThreadAndRunWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateThreadAndRunResp, error)

	CreateThreadAndRunWithResponse(ctx context.Context, body CreateThreadAndRunJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateThreadAndRunResp, error)

	// DeleteThreadWithResponse request
	DeleteThreadWithResponse(ctx context.Context, threadId string, reqEditors ...RequestEditorFn) (*DeleteThreadResp, error)

	// GetThreadWithResponse request
	GetThreadWithResponse(ctx context.Context, threadId string, reqEditors ...RequestEditorFn) (*GetThreadResp, error)

	// ModifyThreadWithBodyWithResponse request with any body
	ModifyThreadWithBodyWithResponse(ctx context.Context, threadId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyThreadResp, error)

	ModifyThreadWithResponse(ctx context.Context, threadId string, body ModifyThreadJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyThreadResp, error)

	// ListMessagesWithResponse request
	ListMessagesWithResponse(ctx context.Context, threadId string, params *ListMessagesParams, reqEditors ...RequestEditorFn) (*ListMessagesResp, error)

	// CreateMessageWithBodyWithResponse request with any body
	CreateMessageWithBodyWithResponse(ctx context.Context, threadId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMessageResp, error)

	CreateMessageWithResponse(ctx context.Context, threadId string, body CreateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMessageResp, error)

	// DeleteMessageWithResponse request
	DeleteMessageWithResponse(ctx context.Context, threadId string, messageId string, reqEditors ...RequestEditorFn) (*DeleteMessageResp, error)

	// GetMessageWithResponse request
	GetMessageWithResponse(ctx context.Context, threadId string, messageId string, reqEditors ...RequestEditorFn) (*GetMessageResp, error)

	// ModifyMessageWithBodyWithResponse request with any body
	ModifyMessageWithBodyWithResponse(ctx context.Context, threadId string, messageId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyMessageResp, error)

	ModifyMessageWithResponse(ctx context.Context, threadId string, messageId string, body ModifyMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyMessageResp, error)

	// ListRunsWithResponse request
	ListRunsWithResponse(ctx context.Context, threadId string, params *ListRunsParams, reqEditors ...RequestEditorFn) (*ListRunsResp, error)

	// CreateRunWithBodyWithResponse request with any body
	CreateRunWithBodyWithResponse(ctx context.Context, threadId string, params *CreateRunParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRunResp, error)

	CreateRunWithResponse(ctx context.Context, threadId string, params *CreateRunParams, body CreateRunJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRunResp, error)

	// GetRunWithResponse request
	GetRunWithResponse(ctx context.Context, threadId string, runId string, reqEditors ...RequestEditorFn) (*GetRunResp, error)

	// ModifyRunWithBodyWithResponse request with any body
	ModifyRunWithBodyWithResponse(ctx context.Context, threadId string, runId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyRunResp, error)

	ModifyRunWithResponse(ctx context.Context, threadId string, runId string, body ModifyRunJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyRunResp, error)

	// CancelRunWithResponse request
	CancelRunWithResponse(ctx context.Context, threadId string, runId string, reqEditors ...RequestEditorFn) (*CancelRunResp, error)

	// ListRunStepsWithResponse request
	ListRunStepsWithResponse(ctx context.Context, threadId string, runId string, params *ListRunStepsParams, reqEditors ...RequestEditorFn) (*ListRunStepsResp, error)

	// GetRunStepWithResponse request
	GetRunStepWithResponse(ctx context.Context, threadId string, runId string, stepId string, params *GetRunStepParams, reqEditors ...RequestEditorFn) (*GetRunStepResp, error)

	// SubmitToolOuputsToRunWithBodyWithResponse request with any body
	SubmitToolOuputsToRunWithBodyWithResponse(ctx context.Context, threadId string, runId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubmitToolOuputsToRunResp, error)

	SubmitToolOuputsToRunWithResponse(ctx context.Context, threadId string, runId string, body SubmitToolOuputsToRunJSONRequestBody, reqEditors ...RequestEditorFn) (*SubmitToolOuputsToRunResp, error)

	// CreateUploadWithBodyWithResponse request with any body
	CreateUploadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUploadResp, error)

	CreateUploadWithResponse(ctx context.Context, body CreateUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUploadResp, error)

	// CancelUploadWithResponse request
	CancelUploadWithResponse(ctx context.Context, uploadId string, reqEditors ...RequestEditorFn) (*CancelUploadResp, error)

	// CompleteUploadWithBodyWithResponse request with any body
	CompleteUploadWithBodyWithResponse(ctx context.Context, uploadId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompleteUploadResp, error)

	CompleteUploadWithResponse(ctx context.Context, uploadId string, body CompleteUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*CompleteUploadResp, error)

	// AddUploadPartWithBodyWithResponse request with any body
	AddUploadPartWithBodyWithResponse(ctx context.Context, uploadId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUploadPartResp, error)

	// ListVectorStoresWithResponse request
	ListVectorStoresWithResponse(ctx context.Context, params *ListVectorStoresParams, reqEditors ...RequestEditorFn) (*ListVectorStoresResp, error)

	// CreateVectorStoreWithBodyWithResponse request with any body
	CreateVectorStoreWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVectorStoreResp, error)

	CreateVectorStoreWithResponse(ctx context.Context, body CreateVectorStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVectorStoreResp, error)

	// DeleteVectorStoreWithResponse request
	DeleteVectorStoreWithResponse(ctx context.Context, vectorStoreId string, reqEditors ...RequestEditorFn) (*DeleteVectorStoreResp, error)

	// GetVectorStoreWithResponse request
	GetVectorStoreWithResponse(ctx context.Context, vectorStoreId string, reqEditors ...RequestEditorFn) (*GetVectorStoreResp, error)

	// ModifyVectorStoreWithBodyWithResponse request with any body
	ModifyVectorStoreWithBodyWithResponse(ctx context.Context, vectorStoreId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyVectorStoreResp, error)

	ModifyVectorStoreWithResponse(ctx context.Context, vectorStoreId string, body ModifyVectorStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyVectorStoreResp, error)

	// CreateVectorStoreFileBatchWithBodyWithResponse request with any body
	CreateVectorStoreFileBatchWithBodyWithResponse(ctx context.Context, vectorStoreId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVectorStoreFileBatchResp, error)

	CreateVectorStoreFileBatchWithResponse(ctx context.Context, vectorStoreId string, body CreateVectorStoreFileBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVectorStoreFileBatchResp, error)

	// GetVectorStoreFileBatchWithResponse request
	GetVectorStoreFileBatchWithResponse(ctx context.Context, vectorStoreId string, batchId string, reqEditors ...RequestEditorFn) (*GetVectorStoreFileBatchResp, error)

	// CancelVectorStoreFileBatchWithResponse request
	CancelVectorStoreFileBatchWithResponse(ctx context.Context, vectorStoreId string, batchId string, reqEditors ...RequestEditorFn) (*CancelVectorStoreFileBatchResp, error)

	// ListFilesInVectorStoreBatchWithResponse request
	ListFilesInVectorStoreBatchWithResponse(ctx context.Context, vectorStoreId string, batchId string, params *ListFilesInVectorStoreBatchParams, reqEditors ...RequestEditorFn) (*ListFilesInVectorStoreBatchResp, error)

	// ListVectorStoreFilesWithResponse request
	ListVectorStoreFilesWithResponse(ctx context.Context, vectorStoreId string, params *ListVectorStoreFilesParams, reqEditors ...RequestEditorFn) (*ListVectorStoreFilesResp, error)

	// CreateVectorStoreFileWithBodyWithResponse request with any body
	CreateVectorStoreFileWithBodyWithResponse(ctx context.Context, vectorStoreId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVectorStoreFileResp, error)

	CreateVectorStoreFileWithResponse(ctx context.Context, vectorStoreId string, body CreateVectorStoreFileJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVectorStoreFileResp, error)

	// DeleteVectorStoreFileWithResponse request
	DeleteVectorStoreFileWithResponse(ctx context.Context, vectorStoreId string, fileId string, reqEditors ...RequestEditorFn) (*DeleteVectorStoreFileResp, error)

	// GetVectorStoreFileWithResponse request
	GetVectorStoreFileWithResponse(ctx context.Context, vectorStoreId string, fileId string, reqEditors ...RequestEditorFn) (*GetVectorStoreFileResp, error)
}

type ListAssistantsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListAssistantsResponse
}

// Status returns HTTPResponse.Status
func (r ListAssistantsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAssistantsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAssistantResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssistantObject
}

// Status returns HTTPResponse.Status
func (r CreateAssistantResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAssistantResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAssistantResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteAssistantResponse
}

// Status returns HTTPResponse.Status
func (r DeleteAssistantResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAssistantResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssistantResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssistantObject
}

// Status returns HTTPResponse.Status
func (r GetAssistantResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssistantResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModifyAssistantResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssistantObject
}

// Status returns HTTPResponse.Status
func (r ModifyAssistantResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModifyAssistantResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSpeechResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateSpeechResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSpeechResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTranscriptionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
}

// Status returns HTTPResponse.Status
func (r CreateTranscriptionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTranscriptionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTranslationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
}

// Status returns HTTPResponse.Status
func (r CreateTranslationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTranslationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBatchesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListBatchesResponse
}

// Status returns HTTPResponse.Status
func (r ListBatchesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBatchesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBatchResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Batch
}

// Status returns HTTPResponse.Status
func (r CreateBatchResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBatchResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveBatchResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Batch
}

// Status returns HTTPResponse.Status
func (r RetrieveBatchResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveBatchResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelBatchResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Batch
}

// Status returns HTTPResponse.Status
func (r CancelBatchResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelBatchResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateChatCompletionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateChatCompletionResponse
}

// Status returns HTTPResponse.Status
func (r CreateChatCompletionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateChatCompletionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCompletionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateCompletionResponse
}

// Status returns HTTPResponse.Status
func (r CreateCompletionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCompletionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEmbeddingResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateEmbeddingResponse
}

// Status returns HTTPResponse.Status
func (r CreateEmbeddingResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEmbeddingResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFilesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListFilesResponse
}

// Status returns HTTPResponse.Status
func (r ListFilesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFilesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFileResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OpenAIFile
}

// Status returns HTTPResponse.Status
func (r CreateFileResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFileResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFileResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteFileResponse
}

// Status returns HTTPResponse.Status
func (r DeleteFileResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFileResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveFileResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OpenAIFile
}

// Status returns HTTPResponse.Status
func (r RetrieveFileResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveFileResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadFileResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r DownloadFileResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadFileResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPaginatedFineTuningJobsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPaginatedFineTuningJobsResponse
}

// Status returns HTTPResponse.Status
func (r ListPaginatedFineTuningJobsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPaginatedFineTuningJobsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFineTuningJobResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FineTuningJob
}

// Status returns HTTPResponse.Status
func (r CreateFineTuningJobResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFineTuningJobResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveFineTuningJobResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FineTuningJob
}

// Status returns HTTPResponse.Status
func (r RetrieveFineTuningJobResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveFineTuningJobResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelFineTuningJobResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FineTuningJob
}

// Status returns HTTPResponse.Status
func (r CancelFineTuningJobResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelFineTuningJobResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFineTuningJobCheckpointsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListFineTuningJobCheckpointsResponse
}

// Status returns HTTPResponse.Status
func (r ListFineTuningJobCheckpointsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFineTuningJobCheckpointsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFineTuningEventsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListFineTuningJobEventsResponse
}

// Status returns HTTPResponse.Status
func (r ListFineTuningEventsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFineTuningEventsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateImageEditResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ImagesResponse
}

// Status returns HTTPResponse.Status
func (r CreateImageEditResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateImageEditResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateImageResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ImagesResponse
}

// Status returns HTTPResponse.Status
func (r CreateImageResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateImageResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateImageVariationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ImagesResponse
}

// Status returns HTTPResponse.Status
func (r CreateImageVariationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateImageVariationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListModelsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListModelsResponse
}

// Status returns HTTPResponse.Status
func (r ListModelsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListModelsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteModelResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteModelResponse
}

// Status returns HTTPResponse.Status
func (r DeleteModelResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteModelResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveModelResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Model
}

// Status returns HTTPResponse.Status
func (r RetrieveModelResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveModelResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateModerationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateModerationResponse
}

// Status returns HTTPResponse.Status
func (r CreateModerationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateModerationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAuditLogsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListAuditLogsResponse
}

// Status returns HTTPResponse.Status
func (r ListAuditLogsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAuditLogsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInvitesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InviteListResponse
}

// Status returns HTTPResponse.Status
func (r ListInvitesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInvitesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InviteUserResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Invite
}

// Status returns HTTPResponse.Status
func (r InviteUserResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InviteUserResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInviteResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InviteDeleteResponse
}

// Status returns HTTPResponse.Status
func (r DeleteInviteResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInviteResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveInviteResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Invite
}

// Status returns HTTPResponse.Status
func (r RetrieveInviteResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveInviteResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectListResponse
}

// Status returns HTTPResponse.Status
func (r ListProjectsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProjectResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Project
}

// Status returns HTTPResponse.Status
func (r CreateProjectResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProjectResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveProjectResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Project
}

// Status returns HTTPResponse.Status
func (r RetrieveProjectResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveProjectResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModifyProjectResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Project
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ModifyProjectResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModifyProjectResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectApiKeysResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectApiKeyListResponse
}

// Status returns HTTPResponse.Status
func (r ListProjectApiKeysResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectApiKeysResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProjectApiKeyResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectApiKeyDeleteResponse
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteProjectApiKeyResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProjectApiKeyResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveProjectApiKeyResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectApiKey
}

// Status returns HTTPResponse.Status
func (r RetrieveProjectApiKeyResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveProjectApiKeyResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveProjectResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Project
}

// Status returns HTTPResponse.Status
func (r ArchiveProjectResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveProjectResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectRateLimitsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectRateLimitListResponse
}

// Status returns HTTPResponse.Status
func (r ListProjectRateLimitsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectRateLimitsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProjectRateLimitsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectRateLimit
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateProjectRateLimitsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProjectRateLimitsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectServiceAccountsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectServiceAccountListResponse
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListProjectServiceAccountsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectServiceAccountsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProjectServiceAccountResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ProjectServiceAccountCreateResponse
}

// Status returns HTTPResponse.Status
func (r CreateProjectServiceAccountResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProjectServiceAccountResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProjectServiceAccountResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectServiceAccountDeleteResponse
}

// Status returns HTTPResponse.Status
func (r DeleteProjectServiceAccountResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProjectServiceAccountResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveProjectServiceAccountResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectServiceAccount
}

// Status returns HTTPResponse.Status
func (r RetrieveProjectServiceAccountResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveProjectServiceAccountResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectUsersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectUserListResponse
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListProjectUsersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectUsersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProjectUserResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ProjectUser
}

// Status returns HTTPResponse.Status
func (r CreateProjectUserResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProjectUserResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProjectUserResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectUserDeleteResponse
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteProjectUserResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProjectUserResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveProjectUserResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectUser
}

// Status returns HTTPResponse.Status
func (r RetrieveProjectUserResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveProjectUserResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModifyProjectUserResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectUser
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ModifyProjectUserResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModifyProjectUserResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserListResponse
}

// Status returns HTTPResponse.Status
func (r ListUsersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserDeleteResponse
}

// Status returns HTTPResponse.Status
func (r DeleteUserResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveUserResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
}

// Status returns HTTPResponse.Status
func (r RetrieveUserResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveUserResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModifyUserResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
}

// Status returns HTTPResponse.Status
func (r ModifyUserResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModifyUserResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateThreadResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ThreadObject
}

// Status returns HTTPResponse.Status
func (r CreateThreadResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateThreadResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateThreadAndRunResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RunObject
}

// Status returns HTTPResponse.Status
func (r CreateThreadAndRunResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateThreadAndRunResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteThreadResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteThreadResponse
}

// Status returns HTTPResponse.Status
func (r DeleteThreadResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteThreadResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetThreadResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ThreadObject
}

// Status returns HTTPResponse.Status
func (r GetThreadResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetThreadResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModifyThreadResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ThreadObject
}

// Status returns HTTPResponse.Status
func (r ModifyThreadResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModifyThreadResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMessagesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListMessagesResponse
}

// Status returns HTTPResponse.Status
func (r ListMessagesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMessagesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateMessageResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MessageObject
}

// Status returns HTTPResponse.Status
func (r CreateMessageResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateMessageResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMessageResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteMessageResponse
}

// Status returns HTTPResponse.Status
func (r DeleteMessageResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMessageResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMessageResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MessageObject
}

// Status returns HTTPResponse.Status
func (r GetMessageResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMessageResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModifyMessageResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MessageObject
}

// Status returns HTTPResponse.Status
func (r ModifyMessageResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModifyMessageResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRunsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListRunsResponse
}

// Status returns HTTPResponse.Status
func (r ListRunsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRunsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRunResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RunObject
}

// Status returns HTTPResponse.Status
func (r CreateRunResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRunResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRunResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RunObject
}

// Status returns HTTPResponse.Status
func (r GetRunResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRunResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModifyRunResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RunObject
}

// Status returns HTTPResponse.Status
func (r ModifyRunResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModifyRunResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelRunResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RunObject
}

// Status returns HTTPResponse.Status
func (r CancelRunResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelRunResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRunStepsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListRunStepsResponse
}

// Status returns HTTPResponse.Status
func (r ListRunStepsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRunStepsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRunStepResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RunStepObject
}

// Status returns HTTPResponse.Status
func (r GetRunStepResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRunStepResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubmitToolOuputsToRunResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RunObject
}

// Status returns HTTPResponse.Status
func (r SubmitToolOuputsToRunResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubmitToolOuputsToRunResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUploadResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Upload
}

// Status returns HTTPResponse.Status
func (r CreateUploadResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUploadResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelUploadResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Upload
}

// Status returns HTTPResponse.Status
func (r CancelUploadResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelUploadResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CompleteUploadResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Upload
}

// Status returns HTTPResponse.Status
func (r CompleteUploadResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompleteUploadResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddUploadPartResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UploadPart
}

// Status returns HTTPResponse.Status
func (r AddUploadPartResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddUploadPartResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVectorStoresResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListVectorStoresResponse
}

// Status returns HTTPResponse.Status
func (r ListVectorStoresResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVectorStoresResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVectorStoreResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VectorStoreObject
}

// Status returns HTTPResponse.Status
func (r CreateVectorStoreResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVectorStoreResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVectorStoreResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteVectorStoreResponse
}

// Status returns HTTPResponse.Status
func (r DeleteVectorStoreResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVectorStoreResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVectorStoreResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VectorStoreObject
}

// Status returns HTTPResponse.Status
func (r GetVectorStoreResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVectorStoreResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModifyVectorStoreResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VectorStoreObject
}

// Status returns HTTPResponse.Status
func (r ModifyVectorStoreResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModifyVectorStoreResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVectorStoreFileBatchResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VectorStoreFileBatchObject
}

// Status returns HTTPResponse.Status
func (r CreateVectorStoreFileBatchResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVectorStoreFileBatchResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVectorStoreFileBatchResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VectorStoreFileBatchObject
}

// Status returns HTTPResponse.Status
func (r GetVectorStoreFileBatchResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVectorStoreFileBatchResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelVectorStoreFileBatchResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VectorStoreFileBatchObject
}

// Status returns HTTPResponse.Status
func (r CancelVectorStoreFileBatchResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelVectorStoreFileBatchResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFilesInVectorStoreBatchResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListVectorStoreFilesResponse
}

// Status returns HTTPResponse.Status
func (r ListFilesInVectorStoreBatchResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFilesInVectorStoreBatchResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVectorStoreFilesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListVectorStoreFilesResponse
}

// Status returns HTTPResponse.Status
func (r ListVectorStoreFilesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVectorStoreFilesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVectorStoreFileResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VectorStoreFileObject
}

// Status returns HTTPResponse.Status
func (r CreateVectorStoreFileResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVectorStoreFileResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVectorStoreFileResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteVectorStoreFileResponse
}

// Status returns HTTPResponse.Status
func (r DeleteVectorStoreFileResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVectorStoreFileResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVectorStoreFileResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VectorStoreFileObject
}

// Status returns HTTPResponse.Status
func (r GetVectorStoreFileResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVectorStoreFileResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListAssistantsWithResponse request returning *ListAssistantsResp
func (c *ClientWithResponses) ListAssistantsWithResponse(ctx context.Context, params *ListAssistantsParams, reqEditors ...RequestEditorFn) (*ListAssistantsResp, error) {
	rsp, err := c.ListAssistants(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAssistantsResp(rsp)
}

// CreateAssistantWithBodyWithResponse request with arbitrary body returning *CreateAssistantResp
func (c *ClientWithResponses) CreateAssistantWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAssistantResp, error) {
	rsp, err := c.CreateAssistantWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAssistantResp(rsp)
}

func (c *ClientWithResponses) CreateAssistantWithResponse(ctx context.Context, body CreateAssistantJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAssistantResp, error) {
	rsp, err := c.CreateAssistant(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAssistantResp(rsp)
}

// DeleteAssistantWithResponse request returning *DeleteAssistantResp
func (c *ClientWithResponses) DeleteAssistantWithResponse(ctx context.Context, assistantId string, reqEditors ...RequestEditorFn) (*DeleteAssistantResp, error) {
	rsp, err := c.DeleteAssistant(ctx, assistantId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAssistantResp(rsp)
}

// GetAssistantWithResponse request returning *GetAssistantResp
func (c *ClientWithResponses) GetAssistantWithResponse(ctx context.Context, assistantId string, reqEditors ...RequestEditorFn) (*GetAssistantResp, error) {
	rsp, err := c.GetAssistant(ctx, assistantId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssistantResp(rsp)
}

// ModifyAssistantWithBodyWithResponse request with arbitrary body returning *ModifyAssistantResp
func (c *ClientWithResponses) ModifyAssistantWithBodyWithResponse(ctx context.Context, assistantId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyAssistantResp, error) {
	rsp, err := c.ModifyAssistantWithBody(ctx, assistantId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyAssistantResp(rsp)
}

func (c *ClientWithResponses) ModifyAssistantWithResponse(ctx context.Context, assistantId string, body ModifyAssistantJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyAssistantResp, error) {
	rsp, err := c.ModifyAssistant(ctx, assistantId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyAssistantResp(rsp)
}

// CreateSpeechWithBodyWithResponse request with arbitrary body returning *CreateSpeechResp
func (c *ClientWithResponses) CreateSpeechWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpeechResp, error) {
	rsp, err := c.CreateSpeechWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpeechResp(rsp)
}

func (c *ClientWithResponses) CreateSpeechWithResponse(ctx context.Context, body CreateSpeechJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpeechResp, error) {
	rsp, err := c.CreateSpeech(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpeechResp(rsp)
}

// CreateTranscriptionWithBodyWithResponse request with arbitrary body returning *CreateTranscriptionResp
func (c *ClientWithResponses) CreateTranscriptionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTranscriptionResp, error) {
	rsp, err := c.CreateTranscriptionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTranscriptionResp(rsp)
}

// CreateTranslationWithBodyWithResponse request with arbitrary body returning *CreateTranslationResp
func (c *ClientWithResponses) CreateTranslationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTranslationResp, error) {
	rsp, err := c.CreateTranslationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTranslationResp(rsp)
}

// ListBatchesWithResponse request returning *ListBatchesResp
func (c *ClientWithResponses) ListBatchesWithResponse(ctx context.Context, params *ListBatchesParams, reqEditors ...RequestEditorFn) (*ListBatchesResp, error) {
	rsp, err := c.ListBatches(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBatchesResp(rsp)
}

// CreateBatchWithBodyWithResponse request with arbitrary body returning *CreateBatchResp
func (c *ClientWithResponses) CreateBatchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBatchResp, error) {
	rsp, err := c.CreateBatchWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBatchResp(rsp)
}

func (c *ClientWithResponses) CreateBatchWithResponse(ctx context.Context, body CreateBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBatchResp, error) {
	rsp, err := c.CreateBatch(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBatchResp(rsp)
}

// RetrieveBatchWithResponse request returning *RetrieveBatchResp
func (c *ClientWithResponses) RetrieveBatchWithResponse(ctx context.Context, batchId string, reqEditors ...RequestEditorFn) (*RetrieveBatchResp, error) {
	rsp, err := c.RetrieveBatch(ctx, batchId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveBatchResp(rsp)
}

// CancelBatchWithResponse request returning *CancelBatchResp
func (c *ClientWithResponses) CancelBatchWithResponse(ctx context.Context, batchId string, reqEditors ...RequestEditorFn) (*CancelBatchResp, error) {
	rsp, err := c.CancelBatch(ctx, batchId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelBatchResp(rsp)
}

// CreateChatCompletionWithBodyWithResponse request with arbitrary body returning *CreateChatCompletionResp
func (c *ClientWithResponses) CreateChatCompletionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateChatCompletionResp, error) {
	rsp, err := c.CreateChatCompletionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateChatCompletionResp(rsp)
}

func (c *ClientWithResponses) CreateChatCompletionWithResponse(ctx context.Context, body CreateChatCompletionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateChatCompletionResp, error) {
	rsp, err := c.CreateChatCompletion(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateChatCompletionResp(rsp)
}

// CreateCompletionWithBodyWithResponse request with arbitrary body returning *CreateCompletionResp
func (c *ClientWithResponses) CreateCompletionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCompletionResp, error) {
	rsp, err := c.CreateCompletionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCompletionResp(rsp)
}

func (c *ClientWithResponses) CreateCompletionWithResponse(ctx context.Context, body CreateCompletionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCompletionResp, error) {
	rsp, err := c.CreateCompletion(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCompletionResp(rsp)
}

// CreateEmbeddingWithBodyWithResponse request with arbitrary body returning *CreateEmbeddingResp
func (c *ClientWithResponses) CreateEmbeddingWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEmbeddingResp, error) {
	rsp, err := c.CreateEmbeddingWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEmbeddingResp(rsp)
}

func (c *ClientWithResponses) CreateEmbeddingWithResponse(ctx context.Context, body CreateEmbeddingJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEmbeddingResp, error) {
	rsp, err := c.CreateEmbedding(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEmbeddingResp(rsp)
}

// ListFilesWithResponse request returning *ListFilesResp
func (c *ClientWithResponses) ListFilesWithResponse(ctx context.Context, params *ListFilesParams, reqEditors ...RequestEditorFn) (*ListFilesResp, error) {
	rsp, err := c.ListFiles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFilesResp(rsp)
}

// CreateFileWithBodyWithResponse request with arbitrary body returning *CreateFileResp
func (c *ClientWithResponses) CreateFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFileResp, error) {
	rsp, err := c.CreateFileWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFileResp(rsp)
}

// DeleteFileWithResponse request returning *DeleteFileResp
func (c *ClientWithResponses) DeleteFileWithResponse(ctx context.Context, fileId string, reqEditors ...RequestEditorFn) (*DeleteFileResp, error) {
	rsp, err := c.DeleteFile(ctx, fileId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFileResp(rsp)
}

// RetrieveFileWithResponse request returning *RetrieveFileResp
func (c *ClientWithResponses) RetrieveFileWithResponse(ctx context.Context, fileId string, reqEditors ...RequestEditorFn) (*RetrieveFileResp, error) {
	rsp, err := c.RetrieveFile(ctx, fileId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveFileResp(rsp)
}

// DownloadFileWithResponse request returning *DownloadFileResp
func (c *ClientWithResponses) DownloadFileWithResponse(ctx context.Context, fileId string, reqEditors ...RequestEditorFn) (*DownloadFileResp, error) {
	rsp, err := c.DownloadFile(ctx, fileId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadFileResp(rsp)
}

// ListPaginatedFineTuningJobsWithResponse request returning *ListPaginatedFineTuningJobsResp
func (c *ClientWithResponses) ListPaginatedFineTuningJobsWithResponse(ctx context.Context, params *ListPaginatedFineTuningJobsParams, reqEditors ...RequestEditorFn) (*ListPaginatedFineTuningJobsResp, error) {
	rsp, err := c.ListPaginatedFineTuningJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPaginatedFineTuningJobsResp(rsp)
}

// CreateFineTuningJobWithBodyWithResponse request with arbitrary body returning *CreateFineTuningJobResp
func (c *ClientWithResponses) CreateFineTuningJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFineTuningJobResp, error) {
	rsp, err := c.CreateFineTuningJobWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFineTuningJobResp(rsp)
}

func (c *ClientWithResponses) CreateFineTuningJobWithResponse(ctx context.Context, body CreateFineTuningJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFineTuningJobResp, error) {
	rsp, err := c.CreateFineTuningJob(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFineTuningJobResp(rsp)
}

// RetrieveFineTuningJobWithResponse request returning *RetrieveFineTuningJobResp
func (c *ClientWithResponses) RetrieveFineTuningJobWithResponse(ctx context.Context, fineTuningJobId string, reqEditors ...RequestEditorFn) (*RetrieveFineTuningJobResp, error) {
	rsp, err := c.RetrieveFineTuningJob(ctx, fineTuningJobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveFineTuningJobResp(rsp)
}

// CancelFineTuningJobWithResponse request returning *CancelFineTuningJobResp
func (c *ClientWithResponses) CancelFineTuningJobWithResponse(ctx context.Context, fineTuningJobId string, reqEditors ...RequestEditorFn) (*CancelFineTuningJobResp, error) {
	rsp, err := c.CancelFineTuningJob(ctx, fineTuningJobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelFineTuningJobResp(rsp)
}

// ListFineTuningJobCheckpointsWithResponse request returning *ListFineTuningJobCheckpointsResp
func (c *ClientWithResponses) ListFineTuningJobCheckpointsWithResponse(ctx context.Context, fineTuningJobId string, params *ListFineTuningJobCheckpointsParams, reqEditors ...RequestEditorFn) (*ListFineTuningJobCheckpointsResp, error) {
	rsp, err := c.ListFineTuningJobCheckpoints(ctx, fineTuningJobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFineTuningJobCheckpointsResp(rsp)
}

// ListFineTuningEventsWithResponse request returning *ListFineTuningEventsResp
func (c *ClientWithResponses) ListFineTuningEventsWithResponse(ctx context.Context, fineTuningJobId string, params *ListFineTuningEventsParams, reqEditors ...RequestEditorFn) (*ListFineTuningEventsResp, error) {
	rsp, err := c.ListFineTuningEvents(ctx, fineTuningJobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFineTuningEventsResp(rsp)
}

// CreateImageEditWithBodyWithResponse request with arbitrary body returning *CreateImageEditResp
func (c *ClientWithResponses) CreateImageEditWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateImageEditResp, error) {
	rsp, err := c.CreateImageEditWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateImageEditResp(rsp)
}

// CreateImageWithBodyWithResponse request with arbitrary body returning *CreateImageResp
func (c *ClientWithResponses) CreateImageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateImageResp, error) {
	rsp, err := c.CreateImageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateImageResp(rsp)
}

func (c *ClientWithResponses) CreateImageWithResponse(ctx context.Context, body CreateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateImageResp, error) {
	rsp, err := c.CreateImage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateImageResp(rsp)
}

// CreateImageVariationWithBodyWithResponse request with arbitrary body returning *CreateImageVariationResp
func (c *ClientWithResponses) CreateImageVariationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateImageVariationResp, error) {
	rsp, err := c.CreateImageVariationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateImageVariationResp(rsp)
}

// ListModelsWithResponse request returning *ListModelsResp
func (c *ClientWithResponses) ListModelsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListModelsResp, error) {
	rsp, err := c.ListModels(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListModelsResp(rsp)
}

// DeleteModelWithResponse request returning *DeleteModelResp
func (c *ClientWithResponses) DeleteModelWithResponse(ctx context.Context, model string, reqEditors ...RequestEditorFn) (*DeleteModelResp, error) {
	rsp, err := c.DeleteModel(ctx, model, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteModelResp(rsp)
}

// RetrieveModelWithResponse request returning *RetrieveModelResp
func (c *ClientWithResponses) RetrieveModelWithResponse(ctx context.Context, model string, reqEditors ...RequestEditorFn) (*RetrieveModelResp, error) {
	rsp, err := c.RetrieveModel(ctx, model, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveModelResp(rsp)
}

// CreateModerationWithBodyWithResponse request with arbitrary body returning *CreateModerationResp
func (c *ClientWithResponses) CreateModerationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateModerationResp, error) {
	rsp, err := c.CreateModerationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateModerationResp(rsp)
}

func (c *ClientWithResponses) CreateModerationWithResponse(ctx context.Context, body CreateModerationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateModerationResp, error) {
	rsp, err := c.CreateModeration(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateModerationResp(rsp)
}

// ListAuditLogsWithResponse request returning *ListAuditLogsResp
func (c *ClientWithResponses) ListAuditLogsWithResponse(ctx context.Context, params *ListAuditLogsParams, reqEditors ...RequestEditorFn) (*ListAuditLogsResp, error) {
	rsp, err := c.ListAuditLogs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAuditLogsResp(rsp)
}

// ListInvitesWithResponse request returning *ListInvitesResp
func (c *ClientWithResponses) ListInvitesWithResponse(ctx context.Context, params *ListInvitesParams, reqEditors ...RequestEditorFn) (*ListInvitesResp, error) {
	rsp, err := c.ListInvites(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListInvitesResp(rsp)
}

// InviteUserWithBodyWithResponse request with arbitrary body returning *InviteUserResp
func (c *ClientWithResponses) InviteUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteUserResp, error) {
	rsp, err := c.InviteUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteUserResp(rsp)
}

func (c *ClientWithResponses) InviteUserWithResponse(ctx context.Context, body InviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteUserResp, error) {
	rsp, err := c.InviteUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteUserResp(rsp)
}

// DeleteInviteWithResponse request returning *DeleteInviteResp
func (c *ClientWithResponses) DeleteInviteWithResponse(ctx context.Context, inviteId string, reqEditors ...RequestEditorFn) (*DeleteInviteResp, error) {
	rsp, err := c.DeleteInvite(ctx, inviteId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInviteResp(rsp)
}

// RetrieveInviteWithResponse request returning *RetrieveInviteResp
func (c *ClientWithResponses) RetrieveInviteWithResponse(ctx context.Context, inviteId string, reqEditors ...RequestEditorFn) (*RetrieveInviteResp, error) {
	rsp, err := c.RetrieveInvite(ctx, inviteId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveInviteResp(rsp)
}

// ListProjectsWithResponse request returning *ListProjectsResp
func (c *ClientWithResponses) ListProjectsWithResponse(ctx context.Context, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*ListProjectsResp, error) {
	rsp, err := c.ListProjects(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectsResp(rsp)
}

// CreateProjectWithBodyWithResponse request with arbitrary body returning *CreateProjectResp
func (c *ClientWithResponses) CreateProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectResp, error) {
	rsp, err := c.CreateProjectWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectResp(rsp)
}

func (c *ClientWithResponses) CreateProjectWithResponse(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectResp, error) {
	rsp, err := c.CreateProject(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectResp(rsp)
}

// RetrieveProjectWithResponse request returning *RetrieveProjectResp
func (c *ClientWithResponses) RetrieveProjectWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*RetrieveProjectResp, error) {
	rsp, err := c.RetrieveProject(ctx, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveProjectResp(rsp)
}

// ModifyProjectWithBodyWithResponse request with arbitrary body returning *ModifyProjectResp
func (c *ClientWithResponses) ModifyProjectWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyProjectResp, error) {
	rsp, err := c.ModifyProjectWithBody(ctx, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyProjectResp(rsp)
}

func (c *ClientWithResponses) ModifyProjectWithResponse(ctx context.Context, projectId string, body ModifyProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyProjectResp, error) {
	rsp, err := c.ModifyProject(ctx, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyProjectResp(rsp)
}

// ListProjectApiKeysWithResponse request returning *ListProjectApiKeysResp
func (c *ClientWithResponses) ListProjectApiKeysWithResponse(ctx context.Context, projectId string, params *ListProjectApiKeysParams, reqEditors ...RequestEditorFn) (*ListProjectApiKeysResp, error) {
	rsp, err := c.ListProjectApiKeys(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectApiKeysResp(rsp)
}

// DeleteProjectApiKeyWithResponse request returning *DeleteProjectApiKeyResp
func (c *ClientWithResponses) DeleteProjectApiKeyWithResponse(ctx context.Context, projectId string, keyId string, reqEditors ...RequestEditorFn) (*DeleteProjectApiKeyResp, error) {
	rsp, err := c.DeleteProjectApiKey(ctx, projectId, keyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectApiKeyResp(rsp)
}

// RetrieveProjectApiKeyWithResponse request returning *RetrieveProjectApiKeyResp
func (c *ClientWithResponses) RetrieveProjectApiKeyWithResponse(ctx context.Context, projectId string, keyId string, reqEditors ...RequestEditorFn) (*RetrieveProjectApiKeyResp, error) {
	rsp, err := c.RetrieveProjectApiKey(ctx, projectId, keyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveProjectApiKeyResp(rsp)
}

// ArchiveProjectWithResponse request returning *ArchiveProjectResp
func (c *ClientWithResponses) ArchiveProjectWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*ArchiveProjectResp, error) {
	rsp, err := c.ArchiveProject(ctx, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveProjectResp(rsp)
}

// ListProjectRateLimitsWithResponse request returning *ListProjectRateLimitsResp
func (c *ClientWithResponses) ListProjectRateLimitsWithResponse(ctx context.Context, projectId string, params *ListProjectRateLimitsParams, reqEditors ...RequestEditorFn) (*ListProjectRateLimitsResp, error) {
	rsp, err := c.ListProjectRateLimits(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectRateLimitsResp(rsp)
}

// UpdateProjectRateLimitsWithBodyWithResponse request with arbitrary body returning *UpdateProjectRateLimitsResp
func (c *ClientWithResponses) UpdateProjectRateLimitsWithBodyWithResponse(ctx context.Context, projectId string, rateLimitId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectRateLimitsResp, error) {
	rsp, err := c.UpdateProjectRateLimitsWithBody(ctx, projectId, rateLimitId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectRateLimitsResp(rsp)
}

func (c *ClientWithResponses) UpdateProjectRateLimitsWithResponse(ctx context.Context, projectId string, rateLimitId string, body UpdateProjectRateLimitsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectRateLimitsResp, error) {
	rsp, err := c.UpdateProjectRateLimits(ctx, projectId, rateLimitId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectRateLimitsResp(rsp)
}

// ListProjectServiceAccountsWithResponse request returning *ListProjectServiceAccountsResp
func (c *ClientWithResponses) ListProjectServiceAccountsWithResponse(ctx context.Context, projectId string, params *ListProjectServiceAccountsParams, reqEditors ...RequestEditorFn) (*ListProjectServiceAccountsResp, error) {
	rsp, err := c.ListProjectServiceAccounts(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectServiceAccountsResp(rsp)
}

// CreateProjectServiceAccountWithBodyWithResponse request with arbitrary body returning *CreateProjectServiceAccountResp
func (c *ClientWithResponses) CreateProjectServiceAccountWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectServiceAccountResp, error) {
	rsp, err := c.CreateProjectServiceAccountWithBody(ctx, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectServiceAccountResp(rsp)
}

func (c *ClientWithResponses) CreateProjectServiceAccountWithResponse(ctx context.Context, projectId string, body CreateProjectServiceAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectServiceAccountResp, error) {
	rsp, err := c.CreateProjectServiceAccount(ctx, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectServiceAccountResp(rsp)
}

// DeleteProjectServiceAccountWithResponse request returning *DeleteProjectServiceAccountResp
func (c *ClientWithResponses) DeleteProjectServiceAccountWithResponse(ctx context.Context, projectId string, serviceAccountId string, reqEditors ...RequestEditorFn) (*DeleteProjectServiceAccountResp, error) {
	rsp, err := c.DeleteProjectServiceAccount(ctx, projectId, serviceAccountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectServiceAccountResp(rsp)
}

// RetrieveProjectServiceAccountWithResponse request returning *RetrieveProjectServiceAccountResp
func (c *ClientWithResponses) RetrieveProjectServiceAccountWithResponse(ctx context.Context, projectId string, serviceAccountId string, reqEditors ...RequestEditorFn) (*RetrieveProjectServiceAccountResp, error) {
	rsp, err := c.RetrieveProjectServiceAccount(ctx, projectId, serviceAccountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveProjectServiceAccountResp(rsp)
}

// ListProjectUsersWithResponse request returning *ListProjectUsersResp
func (c *ClientWithResponses) ListProjectUsersWithResponse(ctx context.Context, projectId string, params *ListProjectUsersParams, reqEditors ...RequestEditorFn) (*ListProjectUsersResp, error) {
	rsp, err := c.ListProjectUsers(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectUsersResp(rsp)
}

// CreateProjectUserWithBodyWithResponse request with arbitrary body returning *CreateProjectUserResp
func (c *ClientWithResponses) CreateProjectUserWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectUserResp, error) {
	rsp, err := c.CreateProjectUserWithBody(ctx, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectUserResp(rsp)
}

func (c *ClientWithResponses) CreateProjectUserWithResponse(ctx context.Context, projectId string, body CreateProjectUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectUserResp, error) {
	rsp, err := c.CreateProjectUser(ctx, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectUserResp(rsp)
}

// DeleteProjectUserWithResponse request returning *DeleteProjectUserResp
func (c *ClientWithResponses) DeleteProjectUserWithResponse(ctx context.Context, projectId string, userId string, reqEditors ...RequestEditorFn) (*DeleteProjectUserResp, error) {
	rsp, err := c.DeleteProjectUser(ctx, projectId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectUserResp(rsp)
}

// RetrieveProjectUserWithResponse request returning *RetrieveProjectUserResp
func (c *ClientWithResponses) RetrieveProjectUserWithResponse(ctx context.Context, projectId string, userId string, reqEditors ...RequestEditorFn) (*RetrieveProjectUserResp, error) {
	rsp, err := c.RetrieveProjectUser(ctx, projectId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveProjectUserResp(rsp)
}

// ModifyProjectUserWithBodyWithResponse request with arbitrary body returning *ModifyProjectUserResp
func (c *ClientWithResponses) ModifyProjectUserWithBodyWithResponse(ctx context.Context, projectId string, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyProjectUserResp, error) {
	rsp, err := c.ModifyProjectUserWithBody(ctx, projectId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyProjectUserResp(rsp)
}

func (c *ClientWithResponses) ModifyProjectUserWithResponse(ctx context.Context, projectId string, userId string, body ModifyProjectUserJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyProjectUserResp, error) {
	rsp, err := c.ModifyProjectUser(ctx, projectId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyProjectUserResp(rsp)
}

// ListUsersWithResponse request returning *ListUsersResp
func (c *ClientWithResponses) ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResp, error) {
	rsp, err := c.ListUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersResp(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResp
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*DeleteUserResp, error) {
	rsp, err := c.DeleteUser(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResp(rsp)
}

// RetrieveUserWithResponse request returning *RetrieveUserResp
func (c *ClientWithResponses) RetrieveUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*RetrieveUserResp, error) {
	rsp, err := c.RetrieveUser(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveUserResp(rsp)
}

// ModifyUserWithBodyWithResponse request with arbitrary body returning *ModifyUserResp
func (c *ClientWithResponses) ModifyUserWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyUserResp, error) {
	rsp, err := c.ModifyUserWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyUserResp(rsp)
}

func (c *ClientWithResponses) ModifyUserWithResponse(ctx context.Context, userId string, body ModifyUserJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyUserResp, error) {
	rsp, err := c.ModifyUser(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyUserResp(rsp)
}

// CreateThreadWithBodyWithResponse request with arbitrary body returning *CreateThreadResp
func (c *ClientWithResponses) CreateThreadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateThreadResp, error) {
	rsp, err := c.CreateThreadWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateThreadResp(rsp)
}

func (c *ClientWithResponses) CreateThreadWithResponse(ctx context.Context, body CreateThreadJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateThreadResp, error) {
	rsp, err := c.CreateThread(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateThreadResp(rsp)
}

// CreateThreadAndRunWithBodyWithResponse request with arbitrary body returning *CreateThreadAndRunResp
func (c *ClientWithResponses) CreateThreadAndRunWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateThreadAndRunResp, error) {
	rsp, err := c.CreateThreadAndRunWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateThreadAndRunResp(rsp)
}

func (c *ClientWithResponses) CreateThreadAndRunWithResponse(ctx context.Context, body CreateThreadAndRunJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateThreadAndRunResp, error) {
	rsp, err := c.CreateThreadAndRun(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateThreadAndRunResp(rsp)
}

// DeleteThreadWithResponse request returning *DeleteThreadResp
func (c *ClientWithResponses) DeleteThreadWithResponse(ctx context.Context, threadId string, reqEditors ...RequestEditorFn) (*DeleteThreadResp, error) {
	rsp, err := c.DeleteThread(ctx, threadId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteThreadResp(rsp)
}

// GetThreadWithResponse request returning *GetThreadResp
func (c *ClientWithResponses) GetThreadWithResponse(ctx context.Context, threadId string, reqEditors ...RequestEditorFn) (*GetThreadResp, error) {
	rsp, err := c.GetThread(ctx, threadId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetThreadResp(rsp)
}

// ModifyThreadWithBodyWithResponse request with arbitrary body returning *ModifyThreadResp
func (c *ClientWithResponses) ModifyThreadWithBodyWithResponse(ctx context.Context, threadId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyThreadResp, error) {
	rsp, err := c.ModifyThreadWithBody(ctx, threadId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyThreadResp(rsp)
}

func (c *ClientWithResponses) ModifyThreadWithResponse(ctx context.Context, threadId string, body ModifyThreadJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyThreadResp, error) {
	rsp, err := c.ModifyThread(ctx, threadId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyThreadResp(rsp)
}

// ListMessagesWithResponse request returning *ListMessagesResp
func (c *ClientWithResponses) ListMessagesWithResponse(ctx context.Context, threadId string, params *ListMessagesParams, reqEditors ...RequestEditorFn) (*ListMessagesResp, error) {
	rsp, err := c.ListMessages(ctx, threadId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMessagesResp(rsp)
}

// CreateMessageWithBodyWithResponse request with arbitrary body returning *CreateMessageResp
func (c *ClientWithResponses) CreateMessageWithBodyWithResponse(ctx context.Context, threadId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMessageResp, error) {
	rsp, err := c.CreateMessageWithBody(ctx, threadId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMessageResp(rsp)
}

func (c *ClientWithResponses) CreateMessageWithResponse(ctx context.Context, threadId string, body CreateMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMessageResp, error) {
	rsp, err := c.CreateMessage(ctx, threadId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMessageResp(rsp)
}

// DeleteMessageWithResponse request returning *DeleteMessageResp
func (c *ClientWithResponses) DeleteMessageWithResponse(ctx context.Context, threadId string, messageId string, reqEditors ...RequestEditorFn) (*DeleteMessageResp, error) {
	rsp, err := c.DeleteMessage(ctx, threadId, messageId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMessageResp(rsp)
}

// GetMessageWithResponse request returning *GetMessageResp
func (c *ClientWithResponses) GetMessageWithResponse(ctx context.Context, threadId string, messageId string, reqEditors ...RequestEditorFn) (*GetMessageResp, error) {
	rsp, err := c.GetMessage(ctx, threadId, messageId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMessageResp(rsp)
}

// ModifyMessageWithBodyWithResponse request with arbitrary body returning *ModifyMessageResp
func (c *ClientWithResponses) ModifyMessageWithBodyWithResponse(ctx context.Context, threadId string, messageId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyMessageResp, error) {
	rsp, err := c.ModifyMessageWithBody(ctx, threadId, messageId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyMessageResp(rsp)
}

func (c *ClientWithResponses) ModifyMessageWithResponse(ctx context.Context, threadId string, messageId string, body ModifyMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyMessageResp, error) {
	rsp, err := c.ModifyMessage(ctx, threadId, messageId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyMessageResp(rsp)
}

// ListRunsWithResponse request returning *ListRunsResp
func (c *ClientWithResponses) ListRunsWithResponse(ctx context.Context, threadId string, params *ListRunsParams, reqEditors ...RequestEditorFn) (*ListRunsResp, error) {
	rsp, err := c.ListRuns(ctx, threadId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRunsResp(rsp)
}

// CreateRunWithBodyWithResponse request with arbitrary body returning *CreateRunResp
func (c *ClientWithResponses) CreateRunWithBodyWithResponse(ctx context.Context, threadId string, params *CreateRunParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRunResp, error) {
	rsp, err := c.CreateRunWithBody(ctx, threadId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRunResp(rsp)
}

func (c *ClientWithResponses) CreateRunWithResponse(ctx context.Context, threadId string, params *CreateRunParams, body CreateRunJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRunResp, error) {
	rsp, err := c.CreateRun(ctx, threadId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRunResp(rsp)
}

// GetRunWithResponse request returning *GetRunResp
func (c *ClientWithResponses) GetRunWithResponse(ctx context.Context, threadId string, runId string, reqEditors ...RequestEditorFn) (*GetRunResp, error) {
	rsp, err := c.GetRun(ctx, threadId, runId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRunResp(rsp)
}

// ModifyRunWithBodyWithResponse request with arbitrary body returning *ModifyRunResp
func (c *ClientWithResponses) ModifyRunWithBodyWithResponse(ctx context.Context, threadId string, runId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyRunResp, error) {
	rsp, err := c.ModifyRunWithBody(ctx, threadId, runId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyRunResp(rsp)
}

func (c *ClientWithResponses) ModifyRunWithResponse(ctx context.Context, threadId string, runId string, body ModifyRunJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyRunResp, error) {
	rsp, err := c.ModifyRun(ctx, threadId, runId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyRunResp(rsp)
}

// CancelRunWithResponse request returning *CancelRunResp
func (c *ClientWithResponses) CancelRunWithResponse(ctx context.Context, threadId string, runId string, reqEditors ...RequestEditorFn) (*CancelRunResp, error) {
	rsp, err := c.CancelRun(ctx, threadId, runId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelRunResp(rsp)
}

// ListRunStepsWithResponse request returning *ListRunStepsResp
func (c *ClientWithResponses) ListRunStepsWithResponse(ctx context.Context, threadId string, runId string, params *ListRunStepsParams, reqEditors ...RequestEditorFn) (*ListRunStepsResp, error) {
	rsp, err := c.ListRunSteps(ctx, threadId, runId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRunStepsResp(rsp)
}

// GetRunStepWithResponse request returning *GetRunStepResp
func (c *ClientWithResponses) GetRunStepWithResponse(ctx context.Context, threadId string, runId string, stepId string, params *GetRunStepParams, reqEditors ...RequestEditorFn) (*GetRunStepResp, error) {
	rsp, err := c.GetRunStep(ctx, threadId, runId, stepId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRunStepResp(rsp)
}

// SubmitToolOuputsToRunWithBodyWithResponse request with arbitrary body returning *SubmitToolOuputsToRunResp
func (c *ClientWithResponses) SubmitToolOuputsToRunWithBodyWithResponse(ctx context.Context, threadId string, runId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubmitToolOuputsToRunResp, error) {
	rsp, err := c.SubmitToolOuputsToRunWithBody(ctx, threadId, runId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubmitToolOuputsToRunResp(rsp)
}

func (c *ClientWithResponses) SubmitToolOuputsToRunWithResponse(ctx context.Context, threadId string, runId string, body SubmitToolOuputsToRunJSONRequestBody, reqEditors ...RequestEditorFn) (*SubmitToolOuputsToRunResp, error) {
	rsp, err := c.SubmitToolOuputsToRun(ctx, threadId, runId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubmitToolOuputsToRunResp(rsp)
}

// CreateUploadWithBodyWithResponse request with arbitrary body returning *CreateUploadResp
func (c *ClientWithResponses) CreateUploadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUploadResp, error) {
	rsp, err := c.CreateUploadWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUploadResp(rsp)
}

func (c *ClientWithResponses) CreateUploadWithResponse(ctx context.Context, body CreateUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUploadResp, error) {
	rsp, err := c.CreateUpload(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUploadResp(rsp)
}

// CancelUploadWithResponse request returning *CancelUploadResp
func (c *ClientWithResponses) CancelUploadWithResponse(ctx context.Context, uploadId string, reqEditors ...RequestEditorFn) (*CancelUploadResp, error) {
	rsp, err := c.CancelUpload(ctx, uploadId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelUploadResp(rsp)
}

// CompleteUploadWithBodyWithResponse request with arbitrary body returning *CompleteUploadResp
func (c *ClientWithResponses) CompleteUploadWithBodyWithResponse(ctx context.Context, uploadId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompleteUploadResp, error) {
	rsp, err := c.CompleteUploadWithBody(ctx, uploadId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompleteUploadResp(rsp)
}

func (c *ClientWithResponses) CompleteUploadWithResponse(ctx context.Context, uploadId string, body CompleteUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*CompleteUploadResp, error) {
	rsp, err := c.CompleteUpload(ctx, uploadId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompleteUploadResp(rsp)
}

// AddUploadPartWithBodyWithResponse request with arbitrary body returning *AddUploadPartResp
func (c *ClientWithResponses) AddUploadPartWithBodyWithResponse(ctx context.Context, uploadId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUploadPartResp, error) {
	rsp, err := c.AddUploadPartWithBody(ctx, uploadId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUploadPartResp(rsp)
}

// ListVectorStoresWithResponse request returning *ListVectorStoresResp
func (c *ClientWithResponses) ListVectorStoresWithResponse(ctx context.Context, params *ListVectorStoresParams, reqEditors ...RequestEditorFn) (*ListVectorStoresResp, error) {
	rsp, err := c.ListVectorStores(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVectorStoresResp(rsp)
}

// CreateVectorStoreWithBodyWithResponse request with arbitrary body returning *CreateVectorStoreResp
func (c *ClientWithResponses) CreateVectorStoreWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVectorStoreResp, error) {
	rsp, err := c.CreateVectorStoreWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVectorStoreResp(rsp)
}

func (c *ClientWithResponses) CreateVectorStoreWithResponse(ctx context.Context, body CreateVectorStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVectorStoreResp, error) {
	rsp, err := c.CreateVectorStore(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVectorStoreResp(rsp)
}

// DeleteVectorStoreWithResponse request returning *DeleteVectorStoreResp
func (c *ClientWithResponses) DeleteVectorStoreWithResponse(ctx context.Context, vectorStoreId string, reqEditors ...RequestEditorFn) (*DeleteVectorStoreResp, error) {
	rsp, err := c.DeleteVectorStore(ctx, vectorStoreId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVectorStoreResp(rsp)
}

// GetVectorStoreWithResponse request returning *GetVectorStoreResp
func (c *ClientWithResponses) GetVectorStoreWithResponse(ctx context.Context, vectorStoreId string, reqEditors ...RequestEditorFn) (*GetVectorStoreResp, error) {
	rsp, err := c.GetVectorStore(ctx, vectorStoreId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVectorStoreResp(rsp)
}

// ModifyVectorStoreWithBodyWithResponse request with arbitrary body returning *ModifyVectorStoreResp
func (c *ClientWithResponses) ModifyVectorStoreWithBodyWithResponse(ctx context.Context, vectorStoreId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyVectorStoreResp, error) {
	rsp, err := c.ModifyVectorStoreWithBody(ctx, vectorStoreId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyVectorStoreResp(rsp)
}

func (c *ClientWithResponses) ModifyVectorStoreWithResponse(ctx context.Context, vectorStoreId string, body ModifyVectorStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyVectorStoreResp, error) {
	rsp, err := c.ModifyVectorStore(ctx, vectorStoreId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseModifyVectorStoreResp(rsp)
}

// CreateVectorStoreFileBatchWithBodyWithResponse request with arbitrary body returning *CreateVectorStoreFileBatchResp
func (c *ClientWithResponses) CreateVectorStoreFileBatchWithBodyWithResponse(ctx context.Context, vectorStoreId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVectorStoreFileBatchResp, error) {
	rsp, err := c.CreateVectorStoreFileBatchWithBody(ctx, vectorStoreId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVectorStoreFileBatchResp(rsp)
}

func (c *ClientWithResponses) CreateVectorStoreFileBatchWithResponse(ctx context.Context, vectorStoreId string, body CreateVectorStoreFileBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVectorStoreFileBatchResp, error) {
	rsp, err := c.CreateVectorStoreFileBatch(ctx, vectorStoreId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVectorStoreFileBatchResp(rsp)
}

// GetVectorStoreFileBatchWithResponse request returning *GetVectorStoreFileBatchResp
func (c *ClientWithResponses) GetVectorStoreFileBatchWithResponse(ctx context.Context, vectorStoreId string, batchId string, reqEditors ...RequestEditorFn) (*GetVectorStoreFileBatchResp, error) {
	rsp, err := c.GetVectorStoreFileBatch(ctx, vectorStoreId, batchId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVectorStoreFileBatchResp(rsp)
}

// CancelVectorStoreFileBatchWithResponse request returning *CancelVectorStoreFileBatchResp
func (c *ClientWithResponses) CancelVectorStoreFileBatchWithResponse(ctx context.Context, vectorStoreId string, batchId string, reqEditors ...RequestEditorFn) (*CancelVectorStoreFileBatchResp, error) {
	rsp, err := c.CancelVectorStoreFileBatch(ctx, vectorStoreId, batchId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelVectorStoreFileBatchResp(rsp)
}

// ListFilesInVectorStoreBatchWithResponse request returning *ListFilesInVectorStoreBatchResp
func (c *ClientWithResponses) ListFilesInVectorStoreBatchWithResponse(ctx context.Context, vectorStoreId string, batchId string, params *ListFilesInVectorStoreBatchParams, reqEditors ...RequestEditorFn) (*ListFilesInVectorStoreBatchResp, error) {
	rsp, err := c.ListFilesInVectorStoreBatch(ctx, vectorStoreId, batchId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFilesInVectorStoreBatchResp(rsp)
}

// ListVectorStoreFilesWithResponse request returning *ListVectorStoreFilesResp
func (c *ClientWithResponses) ListVectorStoreFilesWithResponse(ctx context.Context, vectorStoreId string, params *ListVectorStoreFilesParams, reqEditors ...RequestEditorFn) (*ListVectorStoreFilesResp, error) {
	rsp, err := c.ListVectorStoreFiles(ctx, vectorStoreId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVectorStoreFilesResp(rsp)
}

// CreateVectorStoreFileWithBodyWithResponse request with arbitrary body returning *CreateVectorStoreFileResp
func (c *ClientWithResponses) CreateVectorStoreFileWithBodyWithResponse(ctx context.Context, vectorStoreId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVectorStoreFileResp, error) {
	rsp, err := c.CreateVectorStoreFileWithBody(ctx, vectorStoreId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVectorStoreFileResp(rsp)
}

func (c *ClientWithResponses) CreateVectorStoreFileWithResponse(ctx context.Context, vectorStoreId string, body CreateVectorStoreFileJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVectorStoreFileResp, error) {
	rsp, err := c.CreateVectorStoreFile(ctx, vectorStoreId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVectorStoreFileResp(rsp)
}

// DeleteVectorStoreFileWithResponse request returning *DeleteVectorStoreFileResp
func (c *ClientWithResponses) DeleteVectorStoreFileWithResponse(ctx context.Context, vectorStoreId string, fileId string, reqEditors ...RequestEditorFn) (*DeleteVectorStoreFileResp, error) {
	rsp, err := c.DeleteVectorStoreFile(ctx, vectorStoreId, fileId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVectorStoreFileResp(rsp)
}

// GetVectorStoreFileWithResponse request returning *GetVectorStoreFileResp
func (c *ClientWithResponses) GetVectorStoreFileWithResponse(ctx context.Context, vectorStoreId string, fileId string, reqEditors ...RequestEditorFn) (*GetVectorStoreFileResp, error) {
	rsp, err := c.GetVectorStoreFile(ctx, vectorStoreId, fileId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVectorStoreFileResp(rsp)
}

// ParseListAssistantsResp parses an HTTP response from a ListAssistantsWithResponse call
func ParseListAssistantsResp(rsp *http.Response) (*ListAssistantsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAssistantsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListAssistantsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateAssistantResp parses an HTTP response from a CreateAssistantWithResponse call
func ParseCreateAssistantResp(rsp *http.Response) (*CreateAssistantResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAssistantResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssistantObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteAssistantResp parses an HTTP response from a DeleteAssistantWithResponse call
func ParseDeleteAssistantResp(rsp *http.Response) (*DeleteAssistantResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAssistantResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteAssistantResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAssistantResp parses an HTTP response from a GetAssistantWithResponse call
func ParseGetAssistantResp(rsp *http.Response) (*GetAssistantResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssistantResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssistantObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseModifyAssistantResp parses an HTTP response from a ModifyAssistantWithResponse call
func ParseModifyAssistantResp(rsp *http.Response) (*ModifyAssistantResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModifyAssistantResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssistantObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSpeechResp parses an HTTP response from a CreateSpeechWithResponse call
func ParseCreateSpeechResp(rsp *http.Response) (*CreateSpeechResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSpeechResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateTranscriptionResp parses an HTTP response from a CreateTranscriptionWithResponse call
func ParseCreateTranscriptionResp(rsp *http.Response) (*CreateTranscriptionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTranscriptionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateTranslationResp parses an HTTP response from a CreateTranslationWithResponse call
func ParseCreateTranslationResp(rsp *http.Response) (*CreateTranslationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTranslationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListBatchesResp parses an HTTP response from a ListBatchesWithResponse call
func ParseListBatchesResp(rsp *http.Response) (*ListBatchesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBatchesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListBatchesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateBatchResp parses an HTTP response from a CreateBatchWithResponse call
func ParseCreateBatchResp(rsp *http.Response) (*CreateBatchResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBatchResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Batch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRetrieveBatchResp parses an HTTP response from a RetrieveBatchWithResponse call
func ParseRetrieveBatchResp(rsp *http.Response) (*RetrieveBatchResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveBatchResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Batch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCancelBatchResp parses an HTTP response from a CancelBatchWithResponse call
func ParseCancelBatchResp(rsp *http.Response) (*CancelBatchResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelBatchResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Batch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateChatCompletionResp parses an HTTP response from a CreateChatCompletionWithResponse call
func ParseCreateChatCompletionResp(rsp *http.Response) (*CreateChatCompletionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateChatCompletionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateChatCompletionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateCompletionResp parses an HTTP response from a CreateCompletionWithResponse call
func ParseCreateCompletionResp(rsp *http.Response) (*CreateCompletionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCompletionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateCompletionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateEmbeddingResp parses an HTTP response from a CreateEmbeddingWithResponse call
func ParseCreateEmbeddingResp(rsp *http.Response) (*CreateEmbeddingResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEmbeddingResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateEmbeddingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListFilesResp parses an HTTP response from a ListFilesWithResponse call
func ParseListFilesResp(rsp *http.Response) (*ListFilesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFilesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListFilesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateFileResp parses an HTTP response from a CreateFileWithResponse call
func ParseCreateFileResp(rsp *http.Response) (*CreateFileResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFileResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OpenAIFile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteFileResp parses an HTTP response from a DeleteFileWithResponse call
func ParseDeleteFileResp(rsp *http.Response) (*DeleteFileResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFileResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteFileResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRetrieveFileResp parses an HTTP response from a RetrieveFileWithResponse call
func ParseRetrieveFileResp(rsp *http.Response) (*RetrieveFileResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveFileResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OpenAIFile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDownloadFileResp parses an HTTP response from a DownloadFileWithResponse call
func ParseDownloadFileResp(rsp *http.Response) (*DownloadFileResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadFileResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPaginatedFineTuningJobsResp parses an HTTP response from a ListPaginatedFineTuningJobsWithResponse call
func ParseListPaginatedFineTuningJobsResp(rsp *http.Response) (*ListPaginatedFineTuningJobsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPaginatedFineTuningJobsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPaginatedFineTuningJobsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateFineTuningJobResp parses an HTTP response from a CreateFineTuningJobWithResponse call
func ParseCreateFineTuningJobResp(rsp *http.Response) (*CreateFineTuningJobResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFineTuningJobResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FineTuningJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRetrieveFineTuningJobResp parses an HTTP response from a RetrieveFineTuningJobWithResponse call
func ParseRetrieveFineTuningJobResp(rsp *http.Response) (*RetrieveFineTuningJobResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveFineTuningJobResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FineTuningJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCancelFineTuningJobResp parses an HTTP response from a CancelFineTuningJobWithResponse call
func ParseCancelFineTuningJobResp(rsp *http.Response) (*CancelFineTuningJobResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelFineTuningJobResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FineTuningJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListFineTuningJobCheckpointsResp parses an HTTP response from a ListFineTuningJobCheckpointsWithResponse call
func ParseListFineTuningJobCheckpointsResp(rsp *http.Response) (*ListFineTuningJobCheckpointsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFineTuningJobCheckpointsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListFineTuningJobCheckpointsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListFineTuningEventsResp parses an HTTP response from a ListFineTuningEventsWithResponse call
func ParseListFineTuningEventsResp(rsp *http.Response) (*ListFineTuningEventsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFineTuningEventsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListFineTuningJobEventsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateImageEditResp parses an HTTP response from a CreateImageEditWithResponse call
func ParseCreateImageEditResp(rsp *http.Response) (*CreateImageEditResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateImageEditResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ImagesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateImageResp parses an HTTP response from a CreateImageWithResponse call
func ParseCreateImageResp(rsp *http.Response) (*CreateImageResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateImageResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ImagesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateImageVariationResp parses an HTTP response from a CreateImageVariationWithResponse call
func ParseCreateImageVariationResp(rsp *http.Response) (*CreateImageVariationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateImageVariationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ImagesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListModelsResp parses an HTTP response from a ListModelsWithResponse call
func ParseListModelsResp(rsp *http.Response) (*ListModelsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListModelsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListModelsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteModelResp parses an HTTP response from a DeleteModelWithResponse call
func ParseDeleteModelResp(rsp *http.Response) (*DeleteModelResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteModelResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteModelResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRetrieveModelResp parses an HTTP response from a RetrieveModelWithResponse call
func ParseRetrieveModelResp(rsp *http.Response) (*RetrieveModelResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveModelResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Model
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateModerationResp parses an HTTP response from a CreateModerationWithResponse call
func ParseCreateModerationResp(rsp *http.Response) (*CreateModerationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateModerationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateModerationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAuditLogsResp parses an HTTP response from a ListAuditLogsWithResponse call
func ParseListAuditLogsResp(rsp *http.Response) (*ListAuditLogsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAuditLogsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListAuditLogsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListInvitesResp parses an HTTP response from a ListInvitesWithResponse call
func ParseListInvitesResp(rsp *http.Response) (*ListInvitesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInvitesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InviteListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInviteUserResp parses an HTTP response from a InviteUserWithResponse call
func ParseInviteUserResp(rsp *http.Response) (*InviteUserResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InviteUserResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Invite
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteInviteResp parses an HTTP response from a DeleteInviteWithResponse call
func ParseDeleteInviteResp(rsp *http.Response) (*DeleteInviteResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInviteResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InviteDeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRetrieveInviteResp parses an HTTP response from a RetrieveInviteWithResponse call
func ParseRetrieveInviteResp(rsp *http.Response) (*RetrieveInviteResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveInviteResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Invite
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListProjectsResp parses an HTTP response from a ListProjectsWithResponse call
func ParseListProjectsResp(rsp *http.Response) (*ListProjectsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateProjectResp parses an HTTP response from a CreateProjectWithResponse call
func ParseCreateProjectResp(rsp *http.Response) (*CreateProjectResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProjectResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Project
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseRetrieveProjectResp parses an HTTP response from a RetrieveProjectWithResponse call
func ParseRetrieveProjectResp(rsp *http.Response) (*RetrieveProjectResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveProjectResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Project
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseModifyProjectResp parses an HTTP response from a ModifyProjectWithResponse call
func ParseModifyProjectResp(rsp *http.Response) (*ModifyProjectResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModifyProjectResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Project
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListProjectApiKeysResp parses an HTTP response from a ListProjectApiKeysWithResponse call
func ParseListProjectApiKeysResp(rsp *http.Response) (*ListProjectApiKeysResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectApiKeysResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectApiKeyListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteProjectApiKeyResp parses an HTTP response from a DeleteProjectApiKeyWithResponse call
func ParseDeleteProjectApiKeyResp(rsp *http.Response) (*DeleteProjectApiKeyResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProjectApiKeyResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectApiKeyDeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseRetrieveProjectApiKeyResp parses an HTTP response from a RetrieveProjectApiKeyWithResponse call
func ParseRetrieveProjectApiKeyResp(rsp *http.Response) (*RetrieveProjectApiKeyResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveProjectApiKeyResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectApiKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseArchiveProjectResp parses an HTTP response from a ArchiveProjectWithResponse call
func ParseArchiveProjectResp(rsp *http.Response) (*ArchiveProjectResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveProjectResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Project
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListProjectRateLimitsResp parses an HTTP response from a ListProjectRateLimitsWithResponse call
func ParseListProjectRateLimitsResp(rsp *http.Response) (*ListProjectRateLimitsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectRateLimitsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectRateLimitListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateProjectRateLimitsResp parses an HTTP response from a UpdateProjectRateLimitsWithResponse call
func ParseUpdateProjectRateLimitsResp(rsp *http.Response) (*UpdateProjectRateLimitsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProjectRateLimitsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectRateLimit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListProjectServiceAccountsResp parses an HTTP response from a ListProjectServiceAccountsWithResponse call
func ParseListProjectServiceAccountsResp(rsp *http.Response) (*ListProjectServiceAccountsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectServiceAccountsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectServiceAccountListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateProjectServiceAccountResp parses an HTTP response from a CreateProjectServiceAccountWithResponse call
func ParseCreateProjectServiceAccountResp(rsp *http.Response) (*CreateProjectServiceAccountResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProjectServiceAccountResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ProjectServiceAccountCreateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteProjectServiceAccountResp parses an HTTP response from a DeleteProjectServiceAccountWithResponse call
func ParseDeleteProjectServiceAccountResp(rsp *http.Response) (*DeleteProjectServiceAccountResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProjectServiceAccountResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectServiceAccountDeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRetrieveProjectServiceAccountResp parses an HTTP response from a RetrieveProjectServiceAccountWithResponse call
func ParseRetrieveProjectServiceAccountResp(rsp *http.Response) (*RetrieveProjectServiceAccountResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveProjectServiceAccountResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectServiceAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListProjectUsersResp parses an HTTP response from a ListProjectUsersWithResponse call
func ParseListProjectUsersResp(rsp *http.Response) (*ListProjectUsersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectUsersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectUserListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateProjectUserResp parses an HTTP response from a CreateProjectUserWithResponse call
func ParseCreateProjectUserResp(rsp *http.Response) (*CreateProjectUserResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProjectUserResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ProjectUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteProjectUserResp parses an HTTP response from a DeleteProjectUserWithResponse call
func ParseDeleteProjectUserResp(rsp *http.Response) (*DeleteProjectUserResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProjectUserResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectUserDeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseRetrieveProjectUserResp parses an HTTP response from a RetrieveProjectUserWithResponse call
func ParseRetrieveProjectUserResp(rsp *http.Response) (*RetrieveProjectUserResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveProjectUserResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseModifyProjectUserResp parses an HTTP response from a ModifyProjectUserWithResponse call
func ParseModifyProjectUserResp(rsp *http.Response) (*ModifyProjectUserResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModifyProjectUserResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListUsersResp parses an HTTP response from a ListUsersWithResponse call
func ParseListUsersResp(rsp *http.Response) (*ListUsersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteUserResp parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResp(rsp *http.Response) (*DeleteUserResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserDeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRetrieveUserResp parses an HTTP response from a RetrieveUserWithResponse call
func ParseRetrieveUserResp(rsp *http.Response) (*RetrieveUserResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveUserResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseModifyUserResp parses an HTTP response from a ModifyUserWithResponse call
func ParseModifyUserResp(rsp *http.Response) (*ModifyUserResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModifyUserResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateThreadResp parses an HTTP response from a CreateThreadWithResponse call
func ParseCreateThreadResp(rsp *http.Response) (*CreateThreadResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateThreadResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ThreadObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateThreadAndRunResp parses an HTTP response from a CreateThreadAndRunWithResponse call
func ParseCreateThreadAndRunResp(rsp *http.Response) (*CreateThreadAndRunResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateThreadAndRunResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RunObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteThreadResp parses an HTTP response from a DeleteThreadWithResponse call
func ParseDeleteThreadResp(rsp *http.Response) (*DeleteThreadResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteThreadResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteThreadResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetThreadResp parses an HTTP response from a GetThreadWithResponse call
func ParseGetThreadResp(rsp *http.Response) (*GetThreadResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetThreadResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ThreadObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseModifyThreadResp parses an HTTP response from a ModifyThreadWithResponse call
func ParseModifyThreadResp(rsp *http.Response) (*ModifyThreadResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModifyThreadResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ThreadObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListMessagesResp parses an HTTP response from a ListMessagesWithResponse call
func ParseListMessagesResp(rsp *http.Response) (*ListMessagesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMessagesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListMessagesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateMessageResp parses an HTTP response from a CreateMessageWithResponse call
func ParseCreateMessageResp(rsp *http.Response) (*CreateMessageResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateMessageResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MessageObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteMessageResp parses an HTTP response from a DeleteMessageWithResponse call
func ParseDeleteMessageResp(rsp *http.Response) (*DeleteMessageResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMessageResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteMessageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMessageResp parses an HTTP response from a GetMessageWithResponse call
func ParseGetMessageResp(rsp *http.Response) (*GetMessageResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMessageResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MessageObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseModifyMessageResp parses an HTTP response from a ModifyMessageWithResponse call
func ParseModifyMessageResp(rsp *http.Response) (*ModifyMessageResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModifyMessageResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MessageObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListRunsResp parses an HTTP response from a ListRunsWithResponse call
func ParseListRunsResp(rsp *http.Response) (*ListRunsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRunsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListRunsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateRunResp parses an HTTP response from a CreateRunWithResponse call
func ParseCreateRunResp(rsp *http.Response) (*CreateRunResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRunResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RunObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRunResp parses an HTTP response from a GetRunWithResponse call
func ParseGetRunResp(rsp *http.Response) (*GetRunResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRunResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RunObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseModifyRunResp parses an HTTP response from a ModifyRunWithResponse call
func ParseModifyRunResp(rsp *http.Response) (*ModifyRunResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModifyRunResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RunObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCancelRunResp parses an HTTP response from a CancelRunWithResponse call
func ParseCancelRunResp(rsp *http.Response) (*CancelRunResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelRunResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RunObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListRunStepsResp parses an HTTP response from a ListRunStepsWithResponse call
func ParseListRunStepsResp(rsp *http.Response) (*ListRunStepsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRunStepsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListRunStepsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRunStepResp parses an HTTP response from a GetRunStepWithResponse call
func ParseGetRunStepResp(rsp *http.Response) (*GetRunStepResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRunStepResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RunStepObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSubmitToolOuputsToRunResp parses an HTTP response from a SubmitToolOuputsToRunWithResponse call
func ParseSubmitToolOuputsToRunResp(rsp *http.Response) (*SubmitToolOuputsToRunResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubmitToolOuputsToRunResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RunObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateUploadResp parses an HTTP response from a CreateUploadWithResponse call
func ParseCreateUploadResp(rsp *http.Response) (*CreateUploadResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUploadResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Upload
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCancelUploadResp parses an HTTP response from a CancelUploadWithResponse call
func ParseCancelUploadResp(rsp *http.Response) (*CancelUploadResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelUploadResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Upload
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCompleteUploadResp parses an HTTP response from a CompleteUploadWithResponse call
func ParseCompleteUploadResp(rsp *http.Response) (*CompleteUploadResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CompleteUploadResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Upload
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddUploadPartResp parses an HTTP response from a AddUploadPartWithResponse call
func ParseAddUploadPartResp(rsp *http.Response) (*AddUploadPartResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddUploadPartResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UploadPart
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListVectorStoresResp parses an HTTP response from a ListVectorStoresWithResponse call
func ParseListVectorStoresResp(rsp *http.Response) (*ListVectorStoresResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVectorStoresResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListVectorStoresResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateVectorStoreResp parses an HTTP response from a CreateVectorStoreWithResponse call
func ParseCreateVectorStoreResp(rsp *http.Response) (*CreateVectorStoreResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVectorStoreResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VectorStoreObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteVectorStoreResp parses an HTTP response from a DeleteVectorStoreWithResponse call
func ParseDeleteVectorStoreResp(rsp *http.Response) (*DeleteVectorStoreResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVectorStoreResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteVectorStoreResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetVectorStoreResp parses an HTTP response from a GetVectorStoreWithResponse call
func ParseGetVectorStoreResp(rsp *http.Response) (*GetVectorStoreResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVectorStoreResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VectorStoreObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseModifyVectorStoreResp parses an HTTP response from a ModifyVectorStoreWithResponse call
func ParseModifyVectorStoreResp(rsp *http.Response) (*ModifyVectorStoreResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ModifyVectorStoreResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VectorStoreObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateVectorStoreFileBatchResp parses an HTTP response from a CreateVectorStoreFileBatchWithResponse call
func ParseCreateVectorStoreFileBatchResp(rsp *http.Response) (*CreateVectorStoreFileBatchResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVectorStoreFileBatchResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VectorStoreFileBatchObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetVectorStoreFileBatchResp parses an HTTP response from a GetVectorStoreFileBatchWithResponse call
func ParseGetVectorStoreFileBatchResp(rsp *http.Response) (*GetVectorStoreFileBatchResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVectorStoreFileBatchResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VectorStoreFileBatchObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCancelVectorStoreFileBatchResp parses an HTTP response from a CancelVectorStoreFileBatchWithResponse call
func ParseCancelVectorStoreFileBatchResp(rsp *http.Response) (*CancelVectorStoreFileBatchResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelVectorStoreFileBatchResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VectorStoreFileBatchObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListFilesInVectorStoreBatchResp parses an HTTP response from a ListFilesInVectorStoreBatchWithResponse call
func ParseListFilesInVectorStoreBatchResp(rsp *http.Response) (*ListFilesInVectorStoreBatchResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFilesInVectorStoreBatchResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListVectorStoreFilesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListVectorStoreFilesResp parses an HTTP response from a ListVectorStoreFilesWithResponse call
func ParseListVectorStoreFilesResp(rsp *http.Response) (*ListVectorStoreFilesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVectorStoreFilesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListVectorStoreFilesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateVectorStoreFileResp parses an HTTP response from a CreateVectorStoreFileWithResponse call
func ParseCreateVectorStoreFileResp(rsp *http.Response) (*CreateVectorStoreFileResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVectorStoreFileResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VectorStoreFileObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteVectorStoreFileResp parses an HTTP response from a DeleteVectorStoreFileWithResponse call
func ParseDeleteVectorStoreFileResp(rsp *http.Response) (*DeleteVectorStoreFileResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVectorStoreFileResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteVectorStoreFileResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetVectorStoreFileResp parses an HTTP response from a GetVectorStoreFileWithResponse call
func ParseGetVectorStoreFileResp(rsp *http.Response) (*GetVectorStoreFileResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVectorStoreFileResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VectorStoreFileObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
